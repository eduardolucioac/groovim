" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"LICENSE (Apache License "Version 2.0")
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"
"                                  Apache License
"                            Version 2.0, January 2004
"                         http://www.apache.org/licenses/
"
"    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
"
"    1. Definitions.
"
"       "License" shall mean the terms and conditions for use, reproduction,
"       and distribution as defined by Sections 1 through 9 of this document.
"
"       "Licensor" shall mean the copyright owner or entity authorized by
"       the copyright owner that is granting the License.
"
"       "Legal Entity" shall mean the union of the acting entity and all
"       other entities that control, are controlled by, or are under common
"       control with that entity. For the purposes of this definition,
"       "control" means (i) the power, direct or indirect, to cause the
"       direction or management of such entity, whether by contract or
"       otherwise, or (ii) ownership of fifty percent (50%) or more of the
"       outstanding shares, or (iii) beneficial ownership of such entity.
"
"       "You" (or "Your") shall mean an individual or Legal Entity
"       exercising permissions granted by this License.
"
"       "Source" form shall mean the preferred form for making modifications,
"       including but not limited to software source code, documentation
"       source, and configuration files.
"
"       "Object" form shall mean any form resulting from mechanical
"       transformation or translation of a Source form, including but
"       not limited to compiled object code, generated documentation,
"       and conversions to other media types.
"
"       "Work" shall mean the work of authorship, whether in Source or
"       Object form, made available under the License, as indicated by a
"       copyright notice that is included in or attached to the work
"       (an example is provided in the Appendix below).
"
"       "Derivative Works" shall mean any work, whether in Source or Object
"       form, that is based on (or derived from) the Work and for which the
"       editorial revisions, annotations, elaborations, or other modifications
"       represent, as a whole, an original work of authorship. For the purposes
"       of this License, Derivative Works shall not include works that remain
"       separable from, or merely link (or bind by name) to the interfaces of,
"       the Work and Derivative Works thereof.
"
"       "Contribution" shall mean any work of authorship, including
"       the original version of the Work and any modifications or additions
"       to that Work or Derivative Works thereof, that is intentionally
"       submitted to Licensor for inclusion in the Work by the copyright owner
"       or by an individual or Legal Entity authorized to submit on behalf of
"       the copyright owner. For the purposes of this definition, "submitted"
"       means any form of electronic, verbal, or written communication sent
"       to the Licensor or its representatives, including but not limited to
"       communication on electronic mailing lists, source code control systems,
"       and issue tracking systems that are managed by, or on behalf of, the
"       Licensor for the purpose of discussing and improving the Work, but
"       excluding communication that is conspicuously marked or otherwise
"       designated in writing by the copyright owner as "Not a Contribution."
"
"       "Contributor" shall mean Licensor and any individual or Legal Entity
"       on behalf of whom a Contribution has been received by Licensor and
"       subsequently incorporated within the Work.
"
"    2. Grant of Copyright License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       copyright license to reproduce, prepare Derivative Works of,
"       publicly display, publicly perform, sublicense, and distribute the
"       Work and such Derivative Works in Source or Object form.
"
"    3. Grant of Patent License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       (except as stated in this section) patent license to make, have made,
"       use, offer to sell, sell, import, and otherwise transfer the Work,
"       where such license applies only to those patent claims licensable
"       by such Contributor that are necessarily infringed by their
"       Contribution(s) alone or by combination of their Contribution(s)
"       with the Work to which such Contribution(s) was submitted. If You
"       institute patent litigation against any entity (including a
"       cross-claim or counterclaim in a lawsuit) alleging that the Work
"       or a Contribution incorporated within the Work constitutes direct
"       or contributory patent infringement, then any patent licenses
"       granted to You under this License for that Work shall terminate
"       as of the date such litigation is filed.
"
"    4. Redistribution. You may reproduce and distribute copies of the
"       Work or Derivative Works thereof in any medium, with or without
"       modifications, and in Source or Object form, provided that You
"       meet the following conditions:
"
"       (a) You must give any other recipients of the Work or
"           Derivative Works a copy of this License; and
"
"       (b) You must cause any modified files to carry prominent notices
"           stating that You changed the files; and
"
"       (c) You must retain, in the Source form of any Derivative Works
"           that You distribute, all copyright, patent, trademark, and
"           attribution notices from the Source form of the Work,
"           excluding those notices that do not pertain to any part of
"           the Derivative Works; and
"
"       (d) If the Work includes a "NOTICE" text file as part of its
"           distribution, then any Derivative Works that You distribute must
"           include a readable copy of the attribution notices contained
"           within such NOTICE file, excluding those notices that do not
"           pertain to any part of the Derivative Works, in at least one
"           of the following places: within a NOTICE text file distributed
"           as part of the Derivative Works; within the Source form or
"           documentation, if provided along with the Derivative Works; or,
"           within a display generated by the Derivative Works, if and
"           wherever such third-party notices normally appear. The contents
"           of the NOTICE file are for informational purposes only and
"           do not modify the License. You may add Your own attribution
"           notices within Derivative Works that You distribute, alongside
"           or as an addendum to the NOTICE text from the Work, provided
"           that such additional attribution notices cannot be construed
"           as modifying the License.
"
"       You may add Your own copyright statement to Your modifications and
"       may provide additional or different license terms and conditions
"       for use, reproduction, or distribution of Your modifications, or
"       for any such Derivative Works as a whole, provided Your use,
"       reproduction, and distribution of the Work otherwise complies with
"       the conditions stated in this License.
"
"    5. Submission of Contributions. Unless You explicitly state otherwise,
"       any Contribution intentionally submitted for inclusion in the Work
"       by You to the Licensor shall be under the terms and conditions of
"       this License, without any additional terms or conditions.
"       Notwithstanding the above, nothing herein shall supersede or modify
"       the terms of any separate license agreement you may have executed
"       with Licensor regarding such Contributions.
"
"    6. Trademarks. This License does not grant permission to use the trade
"       names, trademarks, service marks, or product names of the Licensor,
"       except as required for reasonable and customary use in describing the
"       origin of the Work and reproducing the content of the NOTICE file.
"
"    7. Disclaimer of Warranty. Unless required by applicable law or
"       agreed to in writing, Licensor provides the Work (and each
"       Contributor provides its Contributions) on an "AS IS" BASIS,
"       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
"       implied, including, without limitation, any warranties or conditions
"       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
"       PARTICULAR PURPOSE. You are solely responsible for determining the
"       appropriateness of using or redistributing the Work and assume any
"       risks associated with Your exercise of permissions under this License.
"
"    8. Limitation of Liability. In no event and under no legal theory,
"       whether in tort (including negligence), contract, or otherwise,
"       unless required by applicable law (such as deliberate and grossly
"       negligent acts) or agreed to in writing, shall any Contributor be
"       liable to You for damages, including any direct, indirect, special,
"       incidental, or consequential damages of any character arising as a
"       result of this License or out of the use or inability to use the
"       Work (including but not limited to damages for loss of goodwill,
"       work stoppage, computer failure or malfunction, or any and all
"       other commercial damages or losses), even if such Contributor
"       has been advised of the possibility of such damages.
"
"    9. Accepting Warranty or Additional Liability. While redistributing
"       the Work or Derivative Works thereof, You may choose to offer,
"       and charge a fee for, acceptance of support, warranty, indemnity,
"       or other liability obligations and/or rights consistent with this
"       License. However, in accepting such obligations, You may act only
"       on Your own behalf and on Your sole responsibility, not on behalf
"       of any other Contributor, and only if You agree to indemnify,
"       defend, and hold each Contributor harmless for any liability
"       incurred by, or claims asserted against, such Contributor by reason
"       of your accepting any such warranty or additional liability.
"
"    END OF TERMS AND CONDITIONS
"
"    APPENDIX: How to apply the Apache License to your work.
"
"       To apply the Apache License to your work, attach the following
"       boilerplate notice, with the fields enclosed by brackets "[]"
"       replaced with your own identifying information. (Don't include
"       the brackets!)  The text should be enclosed in the appropriate
"       comment syntax for the file format. We also recommend that a
"       file or class name and description of purpose be included on the
"       same "printed page" as the copyright notice for easier
"       identification within third-party archives.
"
"    Copyright 2014 Eduardo Lúcio Amorim Costa
"
"    Licensed under the Apache License, Version 2.0 (the "License");
"    you may not use this file except in compliance with the License.
"    You may obtain a copy of the License at
"
"        http://www.apache.org/licenses/LICENSE-2.0
"
"    Unless required by applicable law or agreed to in writing, software
"    distributed under the License is distributed on an "AS IS" BASIS,
"    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
"    See the License for the specific language governing permissions and
"    limitations under the License.

let g:grooVimVersion = "v2.0.8b"
" Eduardo Lúcio
" 2014

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"TASK LIST/BUGS LIST
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" ToDo: On "copy file" ("GrooVim_SaveACopy()") functionality suggest a name to new file automatically! Questor

" Bug: The "F3+c" ("GrooVim_CommandZ()") functionality must be disabled for NerdTree (interface problems)! Questor

" ToDo: Provide the search "for whole word only" ("GrooVim_SearchWithMyOptions()")! Questor

" Bug: "GrooVim_GroovyMove()" not working (for *.py files) in insert/visual mode (loss "set virtualedit=all")! (PRIORITY) Questor

" ToDo: Create a configuration scheme according to the type of file. This scheme  must be in the end of ".vimrc"
" to work properly! Questor

" ToDo: Using python scripts to substitute functions that use the terminal/shell to improve the operation and ease
" of maintenance! (EXAMINE THIS POSSIBILITY) Questor

" ToDo: The "GrooVim_GroovyMove()" do not work with "visual block mode"! (PRIORITY) Questor

" ToDo: Improve syntax and lexers (mainly for python)! By Questor

" ToDo: Try a solution to "set expandtab" X "set listchars=tab:▒░,trail:·" problem! How we can "listchars" spaces
" as "tabs"? By Questor

" ToDo: Create configurable settings for each distribution (extendable to help)! By Questor

" ToDo: Create OS context shortcuts (second button click context) and use double-click to open any file! This can be done
" using a script that works according with user distro/UI! By Questor

" Bug: "Enter" (carriage return) on normal mode fails for certain types of files ("GrooVim_NormalEnterOnNormalMode()")! By Questor

" ToDo: Show cursor position (blink a "scope")! (NOT A PRIORITY) By Questor

" ToDo: Improve the presentation of the tabs flaps. Using a similar idea to a scroll bar? (EXAMINE THIS POSSIBILITY) By Questor

" ToDo: Allow all script features to work with "virtualedit=all"? (EXAMINE THIS POSSIBILITY/NOT A PRIORITY) By Questor

" Bug: Treating problem of slowness with long lines! By Questor

" ToDo: Create verification of operating system for commands (shell/"system()" calls) that depend on it! By Questor

" ToDo: Create command that completely disables GrooVim. This command needs to write this option to disk to disable GrooVim at
" vim startup (see "GrooVim_OptsUpdate()")! By Questor

" ToDo: Review the commands that dependents of "learderkey" combinations ("GrooVim_CommandZ()")! (NOT A PRIORITY) By Questor

" ToDo: Mark lines and navigate to these (bookmarks). Use "mark.vim"? By Questor

" ToDo: Create "expand/collapse an area" ("" TEXT AREA {{{ }}}") features and shorcuts! By Questor

" ToDo: Test GrooVim for multiple distributions! By Questor

" Bug: Adjust colum when use "Enter" (carriage return) on end of lines! By Questor

" ToDo: Treating when duplicate a selection using "F2+d" and there is a line just below the selection! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"MAIN
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"GENERAL BEHAVIOR
"$$$$$$$$$$$$$"

" Note: Use vim settings, rather then vi settings (much better!)! This must be
" first, because it changes other options as a side effect! By Questor
set nocompatible

" Note: Enable "pathogen" plugin! By Questor
" Note: Force reloading *after* pathogen loaded! Trying avoid override! By Questor
filetype plugin indent on
execute pathogen#infect()
execute pathogen#helptags()

" Note: Enable mouse! By Questor
set mouse=a

" Note: Avoids compatibility issues when copying to an external application! By Questor
if has('unnamedplus')
	set clipboard=unnamedplus
else
	set clipboard=unnamed
endif

" Note: Don't create swap files! By Questor
set noswapfile

" Note: Solve read only problem! Some files opens as read only! By Questor
set ma

" Note: When reload ".vimrc" the last search is " highlighted again! By Questor
" set hlsearch

" Note: Allows an "extra" column at the end of the lines (You want this!)! By Questor
set virtualedit=onemore

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"FILE SYNTAX ASSOCIATIONS AND SPECIFIC CONFIGURATION
"$$$$$$$$$$$$$

" Note: General tab conf! By Questor

" Note: Size of a hard tabstop! By Questor
set tabstop=2

" Note: Size of an "indent"! By Questor
set shiftwidth=2

" Note: A combination of spaces and tabs are used to simulate tab stops at a width
" other than the (hard) tabstop! By Questor
set softtabstop=2

" Note: General tab conf! By Questor
func! SpecificTabConf(tabWidth)

	" Note: Size of a hard tabstop! By Questor
	exec "set tabstop=" . a:tabWidth

	" Note: Size of an "indent"! By Questor
	exec "set shiftwidth=" . a:tabWidth

	" Note: A combination of spaces and tabs are used to simulate tab stops at a width
	" other than the (hard) tabstop! By Questor
	exec "set softtabstop=" . a:tabWidth

endfun

"  * .inc

autocmd! BufReadPost *.inc set syntax=html | set filetype=html

"  * .gds

autocmd! BufReadPost *.gds set syntax=vb | set filetype=vb

"  * .py

autocmd! BufReadPost *.py call SpecificTabConf(4)

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENABLE PLUGINS
"$$$$$$$$$$$$$

" Note: Enable all plugins! By Questor
let g:enable_all_plugins = 1

" Note: tcomment.vim! By Questor
let g:enable_tcomment_vim = 1

" Note: nerdtree.vim! By Questor
let g:enable_nerdtree_vim = 1

" Note: debugger.vim! By Questor
let g:enable_debugger_vim = 1

" Note: move.vim! By Questor
let g:enable_move_vim = 1

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"PERFORMANCE
"$$$$$$$$$$$$$

" Note: You got a fast terminal! By Questor
set ttyfast

" Note: Increase scroll speed! By Questor
set ttyscroll=3

" Note: Remove cursor effects to improve performance! By Questor
set nocursorcolumn
set nocursorline

" Note: Limit the scope of syntax in very long lines to improve performance! By Questor
set synmaxcol=1000

" Note: Don't redraw while executing macros (good performance config)!
" Causes scroll "flickering"! By Questor
" set lazyredraw

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"SHORTCUTS (AND REMOVE VIM STUPID BEHAVIOR)
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Swap : and ; to make colon commands easier to type! By Questor
nnoremap  ;  :
nnoremap  :  ;
" Note: Important for the execution of certain commands in some functionalies! By Questor
let g:cmdLineCaller = ";"

nnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"l\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"d\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"u\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"r\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")

" Note: The variable ":let g:onMoveScreen = 1<cr>" is setted in another opportunity
" for the visual mode! Questor
vnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"l\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"d\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"u\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"r\", 0, 0)<cr>" : "")

inoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"l\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"d\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"u\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"r\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")

nnoremap <silent> <PageDown> :call GrooVim_GroovyMove("n", "d", 1, 0)<cr>
nnoremap <silent> <PageUp> :call GrooVim_GroovyMove("n", "u", 1, 0)<cr>

vnoremap <silent> <PageDown> :<C-u>call GrooVim_GroovyMove("v", "d", 1, 0)<cr>
vnoremap <silent> <PageUp> :<C-u>call GrooVim_GroovyMove("v", "u", 1, 0)<cr>

inoremap <silent> <PageDown> <C-o>:call GrooVim_GroovyMove("i", "d", 1, 0)<cr>
inoremap <silent> <PageUp> <C-o>:call GrooVim_GroovyMove("i", "u", 1, 0)<cr>

nnoremap <silent> <C-A-Left> :call GrooVim_GroovyMove("n", "l", 0, 1)<cr>
nnoremap <silent> <C-A-Down> :call GrooVim_GroovyMove("n", "d", 0, 1)<cr>
nnoremap <silent> <C-A-Up> :call GrooVim_GroovyMove("n", "u", 0, 1)<cr>
nnoremap <silent> <C-A-Right> :call GrooVim_GroovyMove("n", "r", 0, 1)<cr>

vnoremap <silent> <C-A-Left> :<C-u>call GrooVim_GroovyMove("v", "l", 0, 1)<cr>
vnoremap <silent> <C-A-Down> :<C-u>call GrooVim_GroovyMove("v", "d", 0, 1)<cr>
vnoremap <silent> <C-A-Up> :<C-u>call GrooVim_GroovyMove("v", "u", 0, 1)<cr>
vnoremap <silent> <C-A-Right> :<C-u>call GrooVim_GroovyMove("v", "r", 0, 1)<cr>

inoremap <silent> <C-A-Left> <C-o>:call GrooVim_GroovyMove("i", "l", 0, 1)<cr>
inoremap <silent> <C-A-Down> <C-o>:call GrooVim_GroovyMove("i", "d", 0, 1)<cr>
inoremap <silent> <C-A-Up> <C-o>:call GrooVim_GroovyMove("i", "u", 0, 1)<cr>
inoremap <silent> <C-A-Right> <C-o>:call GrooVim_GroovyMove("i", "r", 1, 1)<cr>

" Note: Allows fluid cursor movement on the screen! By Questor
let g:onMoveScreen = 0
let g:GrooVim_GroovyMoveType = 0
let g:cursorHoldVisualExec = ""
let g:cursorHoldVisual = 0
let g:GrooVim_GroovyMoveEnabled = 1
func! GrooVim_GroovyMove(mod, direction, blockSmoothness, GrooVim_GroovyMoveType) range

	let g:GrooVim_GroovyMoveEnabled = 0

	if a:blockSmoothness == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0 && a:GrooVim_GroovyMoveType == 0
		call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
	endif

	if &virtualedit == "onemore"
		set virtualedit=all
	endif

	let l:disableSmoothness = 0
	let l:disableHorizontalSmoothness = 0
	let l:horizontalSmoothnessFactor = 2
	let l:verticalSmoothnessFactor = 10

	if a:GrooVim_GroovyMoveType == 0
		let l:horizontalMovementFactor = 20
		let l:verticalMovementFactor = 15
	elseif a:GrooVim_GroovyMoveType == 1
		let l:horizontalMovementFactor = 1
		let l:verticalMovementFactor = 1
	endif

	if a:mod == "n" || a:mod == "i"

		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

	elseif a:mod == "v"

		exec "norm gv"
		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

		" Note: This workaround is to use "CursorHold" event in visual mode. This event is only possible in normal mode! By Questor
		let g:cursorHoldVisualExec = "call GrooVim_GroovyMoveAdjuster(\"" . a:direction . "\", " . a:blockSmoothness . ", " . l:disableSmoothness . ", " . l:verticalSmoothnessFactor . ")"
		let g:cursorHoldVisual = 1
		exec "norm \<Esc>"

	endif

	let g:onMoveScreen = 1

	" Note: "set virtualedit=onemore" if the area is already valid! By Questor
	if virtcol('.') <= virtcol('$')

		if &virtualedit == "all"
			set virtualedit=onemore
		endif

		if a:direction == "r" && a:mod != "v"
			call GrooVim_GroovyMoveAdjuster(a:direction, a:blockSmoothness, l:disableSmoothness, l:verticalSmoothnessFactor)
		endif

	endif

endfunc

" Note: Adjusts the cursor position when this ends the movement ("GrooVim_GroovyMove()") over a tab char! By Questor
func! GrooVim_GroovyMoveAdjuster(direction, blockSmoothness, disableSmoothness, verticalSmoothnessFactor) range

	let l:lineNow = getline(".")
	let l:lineSplited = split(l:lineNow, '\zs')

	if len(l:lineSplited) >= 1 && len(l:lineSplited) > (col(".") - 1)

		if l:lineSplited[col(".") - 1] == "	"

			if a:blockSmoothness == 0 && a:disableSmoothness == 0
				exec "sleep " . a:verticalSmoothnessFactor . "m"
			endif

			let l:cursorPosInsert = getpos(".")
			" ldur
			if a:direction == "l"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			elseif a:direction == "r"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2] + 1, 0])
			elseif a:direction == "d" || a:direction == "u"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			endif

			if a:blockSmoothness == 0
				redraw
			endif

			let g:cursorHoldVisual = 0
			let g:onMoveScreen = 1

		endif

	endif

endfunc

nnoremap <silent> <A-End> :call GrooVim_SelWord("n", "r", 1)<cr>
nnoremap <silent> <A-Home> :call GrooVim_SelWord("n", "l", 1)<cr>
inoremap <silent> <A-End> <C-o>:call GrooVim_SelWord("i", "r", 1)<cr>
inoremap <silent> <A-Home> <C-o>:call GrooVim_SelWord("i", "l", 1)<cr>
nnoremap <silent> <script> <A-Left> :call GrooVim_SelWord("n", "l", 0)<cr>
inoremap <silent> <script> <A-Left> <C-o>:call GrooVim_SelWord("i", "l", 0)<cr>
vnoremap <silent> <script> <A-Left> :<C-u>call GrooVim_SelWord("v", "l", 0)<cr>
nnoremap <silent> <script> <A-Right> :call GrooVim_SelWord("n", "r", 0)<cr>
inoremap <silent> <script> <A-Right> <C-o>:call GrooVim_SelWord("i", "r", 0)<cr>
vnoremap <silent> <script> <A-Right> :<C-u>call GrooVim_SelWord("v", "r", 0)<cr>

" Note: Allows selection of words quickly (for copying or deletion)! By Questor
func! GrooVim_SelWord(mod, direction, fullMove) range

	let l:wordMove = ""
	let l:wordMoveInsert = ""

	if a:direction == "l"
		if a:fullMove == 0
			let l:wordMove = "b"
		elseif a:fullMove == 1
			let l:wordMove = "0"
		endif
		let l:wordMoveInsert = "\<Left>"
	elseif a:direction == "r"
		if a:fullMove == 0
			let l:wordMove = "e"
		elseif a:fullMove == 1
			let l:wordMove = "$\<Left>"
		endif
	endif

	if a:mod == "v"
		exec "norm gv" . l:wordMove
	elseif a:mod == "i"
		if virtcol('.') == (virtcol('$') - 1)
			if a:direction == "r"
				exec "norm \<Esc>\<Down>0v" . l:wordMove
			else
				exec "norm \<Esc>v" . l:wordMove
			endif
		else
			exec "norm \<Esc>" . l:wordMoveInsert . "v" . l:wordMove
		endif
	elseif a:mod == "n"
		exec "norm v" . l:wordMove
	endif

endfunc

" Note: Allows go to the "real" end of the line in normal mode. Is an offshoot of "set virtualedit=onemore"! By Questor
nnoremap <silent> <End> $<Right>

nnoremap <silent> <A-DOWN> :call GrooVim_TabToReturn()<cr>
inoremap <silent> <A-DOWN> <C-O>:call GrooVim_TabToReturn()<cr>
vnoremap <silent> <A-DOWN> :<C-U>call GrooVim_TabToReturn()<cr>v

" Note: Return to last tab in use! By Questor
let g:lastTab = 1
autocmd! TabLeave * let g:lastTab = tabpagenr()

func! GrooVim_TabToReturn()
	if g:GrooVim_TabToReturnNumber == 0
		exe "tabn " . g:lastTab
	else
		if g:GrooVim_TabToReturnNumber == tabpagenr()
			exe "tabn " . g:lastTab
		else
			exe "tabn " . g:GrooVim_TabToReturnNumber
			" Note: "redraw" ensures the message display! By Questor
			redraw
			echo "Tab to return is ENabled to this tab!"
		endif
	endif
endfunc

" Note: Allows returning to a particular tab "forever"! By Questor
let g:GrooVim_TabToReturnNumber = 0
func! GrooVim_TabToReturnSet()
	if g:GrooVim_TabToReturnNumber == 0
		let g:GrooVim_TabToReturnNumber = tabpagenr()
		call GrooVim_GrooVimBarMsg("Tab to return was ENabled to this tab!", 4)
	else
		let g:GrooVim_TabToReturnNumber = 0
		call GrooVim_GrooVimBarMsg("Tab to return was DISabled!", 4)
	endif
endfunc

if g:enable_tcomment_vim == 1 && g:enable_all_plugins == 1
	nnoremap <silent> <A-Up> :exec "norm gcc"<cr>
	inoremap <silent> <A-Up> <C-o>:exec "norm gcc"<cr>
	vnoremap <silent> <A-Up> :<C-u>call GrooVim_VisualComment()<cr>
	" Note: Allows comment the current line in a simple and fast way! By Questor
	func! GrooVim_VisualComment() range
		" Note: Lets see if the selection involves more than one line comparing the
		" "start" and "end" line position of the selection!! By Questorr
		if   getpos("'<")[1] == getpos("'>")[1]
			exec "norm gcc"
		else
			exec "norm gv"
			exec "norm gc"
		endif
	endfunc
endif

" Note: Get shown messages! By Questor
let g:messagesHolder = ""
func! GrooVim_GetMessages()
	let g:messagesHolder = ""
	redir => g:messagesHolder
		silent exec "messages"
	redir end
endfunc

" Note: Return the last shown message! By Questor
func! GrooVim_ReturnLastMessage()
	call GrooVim_GetMessages()
	let l:messagesHolderSplitted = split(g:messagesHolder, "\n")
	if len(l:messagesHolderSplitted) >= 1
		return [l:messagesHolderSplitted[len(l:messagesHolderSplitted) - 1], len(l:messagesHolderSplitted)]
	else
		return ["", 0]
	endif
endfunc

let g:lastMessageWorkaroundShowed = ""
let g:lastMessageWorkaroundShowedIndex = 0
" Note: Redisplays the last shown message! By Questor
func! GrooVim_ShowLastMessageWorkaround()

	let l:GrooVim_ReturnLastMessageReturn = GrooVim_ReturnLastMessage()

	if l:GrooVim_ReturnLastMessageReturn[0] != ""
		if l:GrooVim_ReturnLastMessageReturn[0] != g:lastMessageWorkaroundShowed || g:lastMessageWorkaroundShowed == "" || g:lastMessageWorkaroundShowedIndex < l:GrooVim_ReturnLastMessageReturn[1]

			let l:messageBlock = 1
			if l:GrooVim_ReturnLastMessageReturn[0] == "Messages maintainer: Bram Moolenaar <Bram@vim.org>"
			elseif l:GrooVim_ReturnLastMessageReturn[0] =~ "replace with" && l:GrooVim_ReturnLastMessageReturn[0] =~ "(y/n/a/q/l/"
			else
				let l:messageBlock = 0
			endif

			if l:messageBlock == 0

				let l:messageType = "n"
				try

					let l:messageNowToSplit = l:GrooVim_ReturnLastMessageReturn[0]
					let l:messageNowSplitted = split(l:messageNowToSplit[0:6], ": ")

					if len(l:messageNowSplitted) > 0

						let l:messageNowTreated = substitute(l:messageNowSplitted[0], "E", "", "")

						if l:messageNowTreated != 0
							" Note: The quotes serve to make the result of "str2nr" be "transformed" into a string! By Questor
							if l:messageNowTreated == "" . str2nr(l:messageNowTreated) . ""
								if type(str2nr(l:messageNowTreated)) == type(0)
									if l:messageNowTreated > 0 && l:messageNowTreated < 10000
										let l:messageType = "e"
									endif
								endif
							endif
						endif

						
					endif

				catch
					
				endtry

				if l:messageType == "e"
					echohl Error | echo l:GrooVim_ReturnLastMessageReturn[0] | echohl None
				elseif l:messageType == "n"
					echo l:GrooVim_ReturnLastMessageReturn[0]
				endif
			endif

		endif
	endif

	let g:lastMessageWorkaroundShowed = l:GrooVim_ReturnLastMessageReturn[0]
	let g:lastMessageWorkaroundShowedIndex = l:GrooVim_ReturnLastMessageReturn[1]

endfunc

" Note: Check if caps lock is on! By Questor
let g:GrooVim_CheckCapsLockReturn = 0
let g:GrooVim_CheckCapsLockLastExec = 0
let g:GrooVim_CheckCapsLockMsg = 0
func! GrooVim_CheckCapsLock() range

	if (strftime("%Y%m%d%H%M%S") - g:GrooVim_CheckCapsLockLastExec) > 1 || g:GrooVim_CheckCapsLockLastExec == ""

		let l:result = system("xset -q | grep \"Caps Lock:   on\"")

		" Note: In terminal vim, prevent ghost echoing while running a shell command by "system()"! By Questor
		redraw!

		" Note: Redisplays the last message for correcting the "collateral" effect of
		" redraw"!! By Questor
			call GrooVim_ShowLastMessageWorkaround()


		if l:result != ""
			" Note: To debug! By Questor
			if g:GrooVim_CheckCapsLockReturn == 0
				" Note: This warning have a special condition and only
				" disappears if capslock is off! When caps lock is on
				" any other message will be shown! By Questor
				call GrooVim_GrooVimBarMsg("((( CAPS LOCK IS ON, OH NO!!! =| )))", 0)
				let g:GrooVim_CheckCapsLockMsg = 1
			endif
			let g:GrooVim_CheckCapsLockReturn = 1
		else
			let g:GrooVim_CheckCapsLockReturn = 0
		endif
	endif

	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

endfunc

" Note: The exclamation in "autocmd!" avoids redefining this event when reload
" ".vimrc"! By Questor

" Note: Ensures state of "virtualedit" before any editing! By Questor
autocmd! InsertEnter * call GrooVim_InsertEnterPerforms()
func! GrooVim_InsertEnterPerforms()
	if g:onMoveScreen == 0
		if &virtualedit == "all"
			set virtualedit=onemore
		endif
	endif
endfunc

" Note: Repositions the cursor in the correct location when exiting insert mode! By Questor
autocmd! InsertLeave * call GrooVim_InsertLeavePerforms()
func! GrooVim_InsertLeavePerforms()
	exec "norm `^"
endfunc

" Note: Ensures state of "virtualedit" before any editing! By Questor
autocmd! InsertCharPre * call GrooVim_InsertCharPrePerforms()
func! GrooVim_InsertCharPrePerforms()
	if &virtualedit == "all"
		set virtualedit=onemore
	endif
endfunc

" Note: Check caps lock status! By Questor
autocmd! CursorHold * call GrooVim_CheckCapsLockTimer()
autocmd! CursorHoldI * call GrooVim_CheckCapsLockTimer()
let g:reloadVimrc = 0
func! GrooVim_CheckCapsLockTimer()
	if g:onCursorMoved == 0 && g:onMoveScreen == 0

		call GrooVim_CheckCapsLock()
		if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:onMoveScreen == 0
			if (strftime("%Y%m%d%H%M%S") - g:GrooVim_GrooVimBarMsgMoment) > g:GrooVim_GrooVimBarMsgDuration
				call GrooVim_GrooVimBarMsg("", "")
			endif
		endif

	else
		let g:onMoveScreen = 0
		let g:GrooVim_GroovyMoveEnabled = 1
	endif

	" Note: This workaround is to use "CursorHold" event in visual mode. This event is only possible in normal mode! By Questor
	if g:cursorHoldVisual == 1
		exec "norm gv"
		if g:cursorHoldVisualExec != ""
			exec g:cursorHoldVisualExec
			let g:cursorHoldVisualExec = ""
		endif
		let g:cursorHoldVisual = 0
		let g:onMoveScreen = 1
	endif

	checktime
endfunc
" Note: Execution delay (in milliseconds)! By Questor
set updatetime=0

" Note: Allows controlling the status of a number of GrooVim features! By Questor
autocmd! CursorMoved * call GrooVim_VimStatus()
autocmd! CursorMovedI * call GrooVim_VimStatus()
let g:lastMode = ""
let g:onCursorMoved = 0
let g:modeNow = ""
func! GrooVim_VimStatus()

	let g:onCursorMoved = 1
	if g:onMoveScreen == 0

" 		Note: Checks the status of the capslock when Vim the changes its mode or
" 		if Vim is in visual mode!! By Questor

		let g:modeNow = mode()

		if g:modeNow != g:lastMode || g:modeNow == "v"
			" Note: Avoids the need to fire twice "GrooVim_GroovyMove()" when we change
			" the mode! By Questor
				let g:GrooVim_GroovyMoveEnabled = 1
			call GrooVim_CheckCapsLock()
			if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:GrooVim_CheckCapsLockMsg == 1
				call GrooVim_GrooVimBarMsg("", "")
				let g:GrooVim_CheckCapsLockMsg = 0
			endif
		endif

		" Note: When on visual-block mode allows select any area! By Questor
		if mode() != "\<C-v>"
			if &virtualedit == "all"
				set virtualedit=onemore
			endif
		endif

		let g:lastMode = g:modeNow

	endif
	let g:onCursorMoved = 0
endfunc

nnoremap <silent> <ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <S-ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>
nnoremap <silent> <S-ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>

inoremap <silent> <ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <S-ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>
inoremap <silent> <S-ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>

vnoremap <silent> <ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <S-ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>
vnoremap <silent> <S-ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>

" Note: Serves to avoid the side effect of capslock status checking! By Questor
func! GrooVim_ScrollAdm(mod, direction) range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

	if a:mod == "v"
		exec "norm gv"
	endif

	if a:direction == "u"
		exec "norm \<Up>\<Up>\<Up>"
	elseif a:direction == "d"
		exec "norm \<Down>\<Down>\<Down>"
	endif

	let g:onMoveScreen = 1
endfunc

" Note: Serves to avoid the side effect of capslock status checking! By Questor
nnoremap <silent> <LeftMouse> :let g:onMoveScreen = 1<cr><LeftMouse>

nnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
inoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
vnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>

" Note: When enter "visual block" mode and allows select any area! By Questor
func! GrooVim_SetVisualBlock() range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
endfunc

" Note: Avoid "accidents" with "Ctrl+z"! "<nop>" equates to a "null" command! By Questor
nnoremap <silent> <C-z> <Nop>
inoremap <silent> <C-z> <Nop>
vnoremap <silent> <C-z> <Nop>

" Note: Allows "undo"/"redo" on normal mode homogeneously! By Questor
nnoremap <silent> <C-u> u

" Note: Allows undo in a conventional way in the visual mode! By Questor
vnoremap <silent> <C-u> :<C-u>call GrooVim_VisualUndo()<cr>v
func! GrooVim_VisualUndo() range
	exec "norm u"
endfunc

" Note: Allows redo in a conventional way in the visual mode! By Questor
vnoremap <silent> <C-r> :<C-u>call GrooVim_VisualRedo()<cr>v
func! GrooVim_VisualRedo() range
	exec "norm \<C-r>"
endfunc

" Note: Allows undo in a conventional way in the insert mode! By Questor
inoremap <silent> <script> <C-u> <Esc><bar>:call GrooVim_InsertUndo()<cr>i
func! GrooVim_InsertUndo()
	exec "norm u"
endfunc

" Note: Allows redo in a conventional way in the insert mode! By Questor
inoremap <silent> <script> <C-r> <Esc><bar>:call GrooVim_InsertRedo()<cr>i
func! GrooVim_InsertRedo()
	exec "norm \<C-r>"
endfunc

" Note: Allows "Space" in normal mode! By Questor
noremap <silent> <script> <Space> :call GrooVim_SpaceOnNormalMode()<cr>
func! GrooVim_SpaceOnNormalMode()
	exec "norm i\<Space>"
endfunc

" Note: Allows faster switching between windows with "Ctrl+w"! By Questor
nnoremap <silent> <C-w> <C-w><C-w>
inoremap <silent> <C-w> <Esc><C-w><C-w>
vnoremap <silent> <C-w> <Esc><C-w><C-w>

" Note: Gets the number of lines in the current transfer area! Questor
func! GrooVim_NumberOfLinesOnDefaultTransferArea()
	" Note: Get transfer area! By Questor
	let l:lastYank = @+
	let l:lastYankNumbOfLines = split(l:lastYank, "\n")
	" Note: Checks how many lines have! Questor
	return len(l:lastYankNumbOfLines)
endfunc

" Note: Allows yank a line without the return character! By Questor
nnoremap <silent> yy 0y$

nnoremap <silent> <script> p P`]<Right>
nnoremap <silent> <script> <C-v> P`]<Right>

" Note: Allows "normal" paste in insert mode (no line breaks and without need of
" "Shift" key) (Ctrl+v)! By Questor
inoremap <silent> <script> <C-v> <C-o>P<C-o>`]<Right>

" Note: Allows cut to insert mode in a conventional manner (Ctrl-x/Ctrl-v cycle)
" (do not need the "Shift" key)! By Questor
vnoremap <silent> <C-x> di

" Note: Allows copy to insert mode in a conventional manner (Ctrl-c/Ctrl-v cycle)
" (do not need the "Shift" key)! By Questor
vnoremap <silent> <C-c> yi

" Note: Delete and backspace without yank! By Questor
nnoremap d "_d
nnoremap x "_x
vnoremap x "_x

" Note: Paste without yank (visual mode)! By Questor
vnoremap <silent> <script> p "_dP`]<Right>
vnoremap <silent> <script> <C-v> "_dP`]<Right>

" Note: "Normal" movement with "Ctrl+Right"! By Questor
nmap <silent> <C-Right> e
imap <silent> <C-Right> <C-o>e<Right>
vmap <silent> <C-Right> e

" Note: "Normal" movement with "Ctrl+Left"! By Questor
nmap <silent> <C-Left> b
imap <silent> <C-Left> <C-o>b
vmap <silent> <C-Left> b

" Note: The <script> parameter prevents mapping to be overridden by a plugin! By Questor

" Note: Allows "multimode" use of enter key in a conventional way! By Questor
nnoremap <silent> <script> <Enter> :call GrooVim_NormalEnterOnNormalMode()<cr>
func! GrooVim_NormalEnterOnNormalMode()
	exec "norm i\<cr>\<Esc>"
endfunc

" Note: "Normal" backspace/delete in visual mode! By Questor
vmap <silent> <script> <Backspace> "_x
vmap <silent> <script> <Del> "_d

" Note: Allows "multimode" use of backspace key in a conventional way! By Questor
nmap <silent> <script> <Backspace> :call GrooVim_NormalBackspace()<cr>

func! GrooVim_NormalBackspace()

	let l:continue = 1

	if col(".") == 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\i")
		call feedkeys("\<Backspace>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if col(".") > 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\<Left>")
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note:  Move to the next tab! By Questor
nnoremap <silent> <C-Up> :tabnext<cr>
inoremap <silent> <C-Up> <C-O>:tabnext<cr>
vnoremap <silent> <C-Up> :<C-U>tabnext<cr>v

" Note:  Move to the previous tab! By Questor
nnoremap <silent> <C-Down> :tabprevious<cr>
inoremap <silent> <C-Down> <C-O>:tabprevious<cr>
vnoremap <silent> <C-Down> :<C-U>tabprevious<cr>v

" Note: Permite que uso "multimodo" do del! By Questor
func! GrooVim_NormalDel()

	let l:continue = 1

	" Note: This workaround is necessary when the line is empty to remove it! By Questor
	if getline(".") == "" && l:continue == 1
		call feedkeys("_dd")
		" call feedkeys("0")
		let l:continue = 0
	endif

	if col(".") == col("$") && l:continue == 1
		call feedkeys("\i")
		call feedkeys("\<Right>")
		call feedkeys("\<Del>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if l:continue == 1
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note: "Multimode" tab! By Questor
nnoremap <silent> <Tab> :call GrooVim_NormalTab()<cr>

" Note: Allows Tab on normal mode when the line is empty! By Questor
func! GrooVim_NormalTab()
	if col(".") == 1 && getline(".") == ""
		exec "normal i\<Tab>"
	else
		exec "normal >>"
		if len(split(getline("."), '\zs')) == col(".")
			exec "normal \<Right>"
		endif
	endif
endfunc

inoremap <silent> <S-Tab> <C-o><<
nnoremap <silent> <S-Tab> <<
vnoremap <silent> <Tab> >><Esc>gv
vnoremap <silent> <S-Tab> <<<Esc>gv

" Note: Allows Tab on normal mode when the line is empty! By Questor
inoremap <silent> <S-Down> <Esc>v:<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: Exit visual mode! Questor
vnoremap <silent> <S-Down> <Esc>:call GrooVim_VirtualEditAdjust()<cr>

" Note: Allows exit of the current mode using a second "<C-S-Up>" or "<C-S-Down>"! By Questor
inoremap <silent> <S-Up> <Esc>:call GrooVim_VirtualEditAdjust()<cr>
nnoremap <silent> <S-Down> :call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: The "<Esc>" "case" has influence in the code! By Questor

" Note: Allows adjust the "set virtualedit=onemore" parameter when exit the current
" mode you are! By Questor
func! GrooVim_VirtualEditAdjust() range
	set virtualedit=onemore
endfunc

" Note: Enter in insert mode simply and quickly!! By Questor
vnoremap <silent> <script> <S-Up> <Esc>i
nnoremap <silent> <script> <S-Up> i

" Note: Allows adjust the "set virtualedit=onemore" parameter when enter visual
" mode! By Questor
nnoremap <silent> <script> v :<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v
func! GrooVim_AdjustOnEnterVisualMode() range
	set virtualedit=onemore
endfunc

" Note: Like tabdo but restore the current tab! By Questor
let g:tryCathOnTabDo = 0
func! TabDo(command)
	let currTab=tabpagenr()
	if g:tryCathOnTabDo == 0
		exec "tabdo " . a:command
	elseif g:tryCathOnTabDo == 1
		try
			exec "tabdo " . a:command
		catch
		endtry
	endif
	exec "tabn " . currTab
endfunc
com! -nargs=+ -complete=command Tabdo call TabDo(<q-args>)

nnoremap <silent> <script> <2-Leftmouse> :call GrooVim_SelectNSearch(0, "n")<cr>
inoremap <silent> <script> <2-Leftmouse> <Esc>:call GrooVim_SelectNSearch(0, "i")<cr>
vnoremap <silent> <script> <2-Leftmouse> :<C-u>call GrooVim_SelectNSearch(0, "v")<cr>

" Note: Select and search with a double click and z key otherwise select the
" word under cursor! By Questor
func! GrooVim_SelectNSearch(type, mode) range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Set "hlsearch" if is off! By Questor
		if !&hlsearch
			" Note: Highlight search results! By Questor
			set hlsearch
		endif

		set noignorecase
		let l:initialPos = getpos(".")
		if a:type == 0
			exec "sleep 250m"
			let l:enableSearch = getchar(0)
			if l:enableSearch == "122"
				let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
				call feedkeys("/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			else
				call feedkeys("viw")
			endif
		elseif a:type == 1
			let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
			call feedkeys("\<Esc>/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			if a:mode == "i"
				call feedkeys("\<Esc>i")
			else
				" Note: This workaround is to prevent the cursor to moves to the next occurrence when press <Up> or <Down> key! By Questor
				call feedkeys("\<Esc>i\<Esc>")
			endif
		endif

	endif
endfunc

" Note: Select a range based on first and last positions! By Questor
let g:lastCursorPos = [0,0]
let g:GrooVim_SelectRangeInitialize = 1
func! GrooVim_SelectRange(mod) range

	let l:selDirection = "nothing"
	if g:GrooVim_SelectRangeInitialize == 0 && a:mod == "i"
		let l:cursorPosInsert = getpos(".")
		if g:lastCursorPos[1] < l:cursorPosInsert[1]
			let l:selDirection = "lessMoreLine"
		elseif g:lastCursorPos[1] > l:cursorPosInsert[1]
			let l:selDirection = "moreLessLine"
		elseif g:lastCursorPos[1] == l:cursorPosInsert[1]
			if g:lastCursorPos[2] < l:cursorPosInsert[2]
				let l:selDirection = "lessMoreCol"
			elseif g:lastCursorPos[2] > l:cursorPosInsert[2]
				let l:selDirection = "moreLessCol"
			endif
		endif
	endif

	if g:GrooVim_SelectRangeInitialize == 1
		let g:lastCursorPos = getpos(".")
		let g:GrooVim_SelectRangeInitialize = 0
		echomsg "Beginning of the range selected!"
	elseif g:GrooVim_SelectRangeInitialize == 0
		let l:cursorPos = getpos(".")
		call setpos('.', g:lastCursorPos)
		if (l:selDirection == "moreLessLine" || l:selDirection == "moreLessCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		exec "norm v"
		call setpos('.', l:cursorPos)
		if (l:selDirection == "lessMoreLine" || l:selDirection == "lessMoreCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		let g:GrooVim_SelectRangeInitialize = 1
		echomsg "Range selected!"
	endif

endfunc

" Note: Updates an option if it already exists or insert it if not. It also creates the configuration file if it does not exist! By Questor
let g:optsTemp = []
func! GrooVim_OptsUpdate(valueToSearch, valueToReplace, persistently)

	let l:CoolAndVimOptsArrayUpdated = []

	let l:thisOptionDoesNotExistInTheConfiguration = 1

	if a:persistently == 0

		" Note: To update temporary options when necessary! By Questor
		for l:value in g:optsTemp
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		let g:optsTemp = l:CoolAndVimOptsArrayUpdated

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(g:optsTemp, a:valueToReplace)
		endif

		exec a:valueToReplace

	else

		if filereadable(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
			let l:CoolAndVimOptsArrayOriginal = readfile(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
		endif

		let l:CoolAndVimOptsArrayUpdated = []
		for l:value in l:CoolAndVimOptsArrayOriginal
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
				exec a:valueToSearch . a:valueToReplace
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(l:CoolAndVimOptsArrayUpdated, l:value)
		endif

		call writefile(l:CoolAndVimOptsArrayUpdated, expand('~/.vim/plugin/CoolAndVimOpts.vim'))

	endif

endfunc

" Note: Configures the search and/or replace depending on the parameters passed! By Questor
func! GrooVim_ConfigureSearchReplace(typeOfConfig) range

	let l:whileControl = 1

	if a:typeOfConfig == "search"
		echomsg "Configure Search (use empty for default or option now):"
	elseif a:typeOfConfig != "search"
		echomsg "Configure Search and Replace (use empty for default or option now):"
	endif

	let g:searchReplace_CaseSensitive = GrooVim_GetOptions("Case sensitive (replaced/search) [0[default]/1][now: \"" . g:searchReplace_CaseSensitive . "\" ]? ", [1,0], g:searchReplace_CaseSensitive)
	call GrooVim_OptsUpdate("let g:searchReplace_CaseSensitive =", "let g:searchReplace_CaseSensitive = " . g:searchReplace_CaseSensitive, 0)
	if g:searchReplace_CaseSensitive == 1
		echomsg " -> Case sensitive is enabled!"
		call GrooVim_OptsUpdate("set ignorecase", "set noignorecase", 0)
	else
		echomsg " -> Case sensitive is disabled!"
		call GrooVim_OptsUpdate("set noignorecase", "set ignorecase", 0)
	endif

	let g:searchReplace_InAllOpened = GrooVim_GetOptions("In all tabs (replace/search) [0[default]/1][now: \"" . g:searchReplace_InAllOpened . "\" ]? ", [1,0], g:searchReplace_InAllOpened)
	call GrooVim_OptsUpdate("let g:searchReplace_InAllOpened =", "let g:searchReplace_InAllOpened = " . g:searchReplace_InAllOpened, 0)
	if g:searchReplace_InAllOpened == 1
		echomsg " -> Replace/search in all tabs is enabled!"
	else
		echomsg " -> Replace/search in all tabs is disabled!"
	endif

	if a:typeOfConfig != "search"
		let g:configureGrooVim_EntertainmentReplace_Confirmation = GrooVim_GetOptions("Replace with confirmation [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_Confirmation . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_Confirmation)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_Confirmation =", "let g:configureGrooVim_EntertainmentReplace_Confirmation = " . g:configureGrooVim_EntertainmentReplace_Confirmation, 0)
		if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
			echomsg " -> Confirmation is enabled!"
		else
			echomsg " -> Confirmation is disabled!"
		endif
		let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = GrooVim_GetOptions("Ask the value to be replaced [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced =", "let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = " . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced, 0)
		if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
			echomsg " -> The value to be replaced will be asked!"
		else
			echomsg " -> The value to be replaced will NOT be asked!"
		endif
		let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = GrooVim_GetOptions("Replace begin from current position [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_FromCurrentPosition)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition =", "let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = " . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition, 0)
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			echomsg " -> Replace begin from current position is enabled!"
		else
			echomsg " -> Replace begin from current position is disabled!"
		endif
	elseif a:typeOfConfig == "search"
		let g:search_Direction = GrooVim_GetOptions("Search forward/backyard [f[default]/b][now: \"" . g:search_Direction . "\" ]? ", ["f","b"], g:search_Direction)
		call GrooVim_OptsUpdate("let g:search_Direction =", "let g:search_Direction = \"" . g:search_Direction . "\"", 0)
		" Note: Needed to reverse the search! By Questor
		if g:search_Direction == "b"
			let g:grooVimSearchFoward = 0
		elseif g:search_Direction == "f"
			let g:grooVimSearchFoward = 1
		endif
		if g:search_Direction == "f"
			echomsg " -> Search forward is enabled!"
		else
			echomsg " -> Search backyard is enabled!"
		endif
		let g:search_WithList = GrooVim_GetOptions("Search with list [0[default]/1][now: \"" . g:search_WithList . "\" ]? ", [1,0], g:search_WithList)
		call GrooVim_OptsUpdate("let g:search_WithList =", "let g:search_WithList = \"" . g:search_WithList . "\"", 0)
		if g:search_WithList == 1
			echomsg " -> Search with list is enabled!"
		else
			echomsg " -> Search with list is disabled!"
		endif
	endif

endfunc

" Note: Get and validate a givem option! By Questor
func! GrooVim_GetOptions(optionToGet, possibleOptions, defaultOption) range
	let l:stopWhile = 0
	let l:optionReturn = ""
	while l:stopWhile == 0
		let l:optionReturn = input(a:optionToGet)
		let l:stopWhile = GrooVim_ValidateOptions(l:optionReturn, a:possibleOptions, a:defaultOption)
		if ("" . l:optionReturn . "") == ""
			let l:optionReturn = a:defaultOption
		endif
	endwhile
	return l:optionReturn
endfunc

" Note: Check if a given option is valid! By Questor
func! GrooVim_ValidateOptions(optionNow, possibleOptions, defaultOption) range
	for l:value in a:possibleOptions
		" Note: "("" . l:value . "")" -> To force string compare! By Questor
		if ("" . l:value . "") == a:optionNow || (a:optionNow == "" && ("" . a:defaultOption . "") != "")
			return 1
		endif
	endfor
	return 0
endfunc

" Note: Highlight matches when jumping to next! This rewires n and N to do
" the highlighing the match in red! By Questor
nnoremap <silent> <expr> n ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'n' : 'N') : (g:grooVimSearchFoward ? 'N' : 'n')) . ":call GrooVim_HLNext(\"f\", 0.4, \"1\", 1)<cr>"
nnoremap <silent> <expr> N ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'N' : 'n') : (g:grooVimSearchFoward ? 'n' : 'N')) . ":call GrooVim_HLNext(\"b\", 0.4, \"0\", 1)<cr>"

let g:tabChanged = 0
let g:block_GrooVim_HLNext = 0
highlight WhiteOnRed ctermbg=red ctermfg=white
highlight WhiteOnBlue ctermbg=blue ctermfg=white
func! GrooVim_HLNext(moveType, blinkTime, searchMoveInverter, moment)

	let g:GrooVim_XenPlayRunningWithSearch = 1

	if g:block_GrooVim_HLNext == 0

		if a:moment == 0

			let g:cursor_pos_last = getpos(".")

		elseif a:moment == 1

			" * System (v:searchforward) is forward!
			if v:searchforward == 1
				" n -> forward
				" N -> backward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			" * System (v:searchforward) is backward!
			elseif v:searchforward == 0
				" n -> backward
				" N -> forward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			endif

			let [bufnum, lnum, col, off] = getpos('.')
			let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
			let target_pat = '\c\%#'.@/

			" Note: Foward -> blink: red/Backyard -> blink: blue! By Questor
			if l:searchMoveDirection == 1
				let ring = matchadd('WhiteOnRed', target_pat, 101)
			elseif l:searchMoveDirection == 0
				let ring = matchadd('WhiteOnBlue', target_pat, 101)
			endif

			redraw
			exec 'sleep ' . float2nr(a:blinkTime * 200) . 'm'
			call matchdelete(ring)
			redraw

			let l:cursor_pos_now = getpos(".")

			let l:tabChanged = 0

			if g:searchReplace_InAllOpened == 1
				if l:searchMoveDirection == 1 && l:cursor_pos_now[1] < g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabnext
				elseif l:searchMoveDirection == 0 && l:cursor_pos_now[1] > g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabprev
				elseif l:cursor_pos_now[1] == g:cursor_pos_last[1] && l:cursor_pos_now[2] == g:cursor_pos_last[2]
					if l:searchMoveDirection == 1
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabnext
					elseif l:searchMoveDirection == 0
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabprev
					endif
				endif
			endif

			while g:tabChanged == 1

				" Note: Positioning in the correct window! By Questor

				call GrooVim_PutOnEditWindow()

				try
					if l:searchMoveDirection == 1
						exec "norm gg0n"
					elseif l:searchMoveDirection == 0
						exec "norm G$N"
					endif
					let g:block_GrooVim_HLNext = 0
					let g:tabChanged = 0
				catch
					if l:searchMoveDirection == 1
						tabnext
					elseif l:searchMoveDirection == 0
						tabprev
					endif
				endtry
			endwhile

		endif

	endif

endfunc

" Note: Sets the type of search to be performed depending on user choice! By Questor
let g:search_WithList = 0
func! GrooVim_SearchWithMyOptions(mod) range

	let l:callGrooVim_SearchGuy = 1

	" Note: If the search with lists is enabled closes the lists and allows
	" performing the search on next call only! By Questor
	if g:GrooVim_SearchGuyEnabled == 1

		let g:matchedLinesGlobal = ""
		let g:matchedLinesGlobalNavArray = []
		let g:GrooVim_SearchGuyEnabled = 0
		let l:callGrooVim_SearchGuy = 0
		call TabDo("call GrooVim_SearchGuyPrepare()")

	endif

	if l:callGrooVim_SearchGuy == 1
		if g:search_WithList == 1
			call GrooVim_SearchGuy(a:mod)
		elseif g:search_WithList == 0
			call GrooVim_EasySearch(a:mod)
		endif
	endif

endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:search_Direction = "f"
let g:searchReplace_CaseSensitive = 0
let g:grooVimSearchFoward = 1
func! GrooVim_EasySearch(mod) range

	" Note: Set "hlsearch" if is off! By Questor
	if !&hlsearch
		" Note: Highlight search results! By Questor
		set hlsearch
	endif

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	" Note: Initialize the search! By Questor
	let g:block_GrooVim_HLNext = 0

	let l:valueToSearch = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToSearch = @+
	else
		let l:valueToSearch = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	let l:valueToSearchTemp = ""

	let l:valueToSearchTemp = input("You want to use this value (use empty to yes)? \"" . GrooVim_SubstringToPrompt(l:valueToSearch) . "\": ")

	" Note: Define search pathern automatically! By Questor
	if l:valueToSearchTemp != ""
		let l:valueToSearch = l:valueToSearchTemp
	endif

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToSearch)
	let l:search_Operator = ""

	" Note: Select operation type! By Questor
	if g:search_Direction == "b" && g:grooVimSearchFowardBlock == 0
		let l:search_Operator = "?"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f" || g:grooVimSearchFowardBlock == 1
		let l:search_Operator = "/"
		let g:grooVimSearchFoward = 1
	endif

	" Note: This structure was made so that the search can be executed "immediately". With
	" "feedkeys" (below) this does not happen, causing sync issues with functions that
	" depend on "GrooVim_EasySearch" function runs first! By Questor
	" Note: Works but does not allow default "backward search"! By Questor

	let @/ = l:pattern
	let l:initialPos = getpos(".")

	" Note: This operation is duplicated ("feedkeys" and "exec") causing a double
	" execution of the search, but it was the only way to not have problems with "n"
	" and "N" navigating and the search with list! If not done, the highlight is lost
	" after a few movements of the cursor! By Questor
	if g:search_WithList == 0
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
	else
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>")
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"d\"!", 4)

endfunc

" Note: Organizes occurrences and navigation lists! By Questor
let g:matchedLines = ""
func! GrooVim_SearchGuyMatches(linePosition, lineValue, tab, bufferName, line, column) range
	if a:linePosition != ""
		let l:linePositionPrefix = "|" . a:linePosition . "|        "
		let g:matchedLines =  g:matchedLines . strpart(l:linePositionPrefix, 0, 8) . a:lineValue . "\n"
	else
		let g:matchedLines =  g:matchedLines . a:lineValue . "\n"
	endif
	if a:tab != "" && a:line != "" && a:column != ""
		call add(g:matchedLinesGlobalNavArray, a:tab . "," . a:bufferName . "," . a:line . "," . a:column)
	else
		call add(g:matchedLinesGlobalNavArray, "0")
	endif
endfunc

" Note: Performs search in multiple tabs creating lists of occurrences! By Questor
func! GrooVim_SearchGuyTraveler(mod) range

	let l:theresAMatch = 1

	try
		exec "norm gg0n"
	catch
		let l:theresAMatch = 0
	endtry

	if l:theresAMatch == 1

		let g:matchedLines = ""
		" let l:theresAMatch = 0
		let l:cur_pos_last = [0,0,0]

		if g:matchedLinesGlobal == ""
			call GrooVim_SearchGuyMatches("", "-------------------------------------------[ Search List ]-------------------------------------------", "", "", "", "")
		else
			call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------------------------------------", "", "", "", "")
		endif

		call GrooVim_SearchGuyMatches("", expand('%:p'), "", "", "", "")
		call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------", "", "", "", "")

		while (getpos(".")[1] > l:cur_pos_last[1] || (getpos(".")[1] == l:cur_pos_last[1] && getpos(".")[2] > l:cur_pos_last[2])) && l:theresAMatch == 1
			let l:cur_pos_last = getpos(".")
			call GrooVim_SearchGuyMatches(getpos(".")[1], getline("."), tabpagenr(), expand('%:t'), getpos(".")[1], getpos(".")[2])
			exec "norm n"
		endwhile

		let g:matchedLinesGlobal = g:matchedLinesGlobal . g:matchedLines

	endif

endfunc

" Note: Searches for current selection or word under cursor. This is the main
" method of the functionality! By Questor
let g:matchedLinesGlobal = ""
let g:matchedLinesGlobalNavArray = []
let g:GrooVim_SearchGuyEnabled = 0
let g:grooVimSearchFowardBlock = 0
func! GrooVim_SearchGuy(mod) range

	" Note: Avoid search backward! By Questor
	let g:grooVimSearchFowardBlock = 1

	let l:searchMoveInverterHolder = getpos(".")

	let l:initialPos = getpos(".")

	call GrooVim_EasySearch(a:mod)

	let g:matchedLinesGlobal = ""
	let g:block_GrooVim_HLNext = 1
	let g:matchedLinesGlobalNavArray = []
	let g:GrooVim_SearchGuyEnabled = 0

	if g:searchReplace_InAllOpened == 1
		call TabDo("call GrooVim_SearchGuyTraveler(\"" . a:mod . "\")")
	else
		call GrooVim_SearchGuyTraveler(a:mod)
	endif

	let g:block_GrooVim_HLNext = 0
	let g:GrooVim_SearchGuyEnabled = 1

	call setpos(".", l:initialPos)

	call GrooVim_SearchGuySync()

	" Note: This "workaround" is to prevent a side effect that occurs when script
	" changing tab which that is the loss of search highlight. The presence of redraw
	" serves to remove the message generated by "set hlsearch"! By Questor
	" call feedkeys("\<Esc>" . g:cmdLineCaller . "set hlsearch\<cr>\<Esc>" . g:cmdLineCaller . "redraw!\<cr>")

	let g:grooVimSearchFowardBlock = 0

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

	call GrooVim_GrooVimBarMsg("Use Del or double click to navigate!", 4)

endfunc

" Note: Serves to synchronize in others tabs certain "states"! Always runs when a tab is accessed! By Questor
autocmd! TabEnter * call GrooVim_TabParadise()
func! GrooVim_TabParadise()
	" Note: If there is a search list this list is open in the current tab if the
	" functionality is enabled! By Questor
	if g:GrooVim_SearchGuyEnabled == 1 && g:searchReplace_InAllOpened == 1
		call GrooVim_SearchGuySync()
	endif
endfunc

if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
	" Note: Opens and closes the "Nerd Tree" through the "vim-nerdtree-tabs" component! By Questor
	let g:NERDTreeTabsOpen = 0
	func! GrooVim_ToggleNERDTreeTabs()
		if g:NERDTreeTabsOpen == 1
			exec "NERDTreeTabsClose"
			let g:NERDTreeTabsOpen = 0
		else
			exec "NERDTreeTabsOpen"
			let g:NERDTreeTabsOpen = 1

			" Note: Focus on "Nerd Tree" when opens it! By Questor
			let l:exitWhile = 0
			let l:firstBufferOnThisTab = expand('%:t')
			while ! (expand('%:t') =~ "NERD_tree_") && l:exitWhile == 0
				exec "norm \<C-w>"
				if expand('%:t') == l:firstBufferOnThisTab
					let l:exitWhile = 1
				endif
			endwhile

		endif
	endfunc
endif

" Note: When entering a tab opens the occurrences list if the search with list
" is enabled! By Questor
func! GrooVim_SearchGuySync()
	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 0

		call GrooVim_PutOnEditWindow()

		" Note: O "set ma" e "set noma" abre e bloqueia edição do 
		" buffer! By Questor
		set ma
		exec "set splitbelow"
		silent exec "split GrooVim_SearchGuyResults" . tabpagenr()
		exec "put =g:matchedLinesGlobal"
		set cursorline
		exec "norm ggdd"
		set noma
	endif
endfunc

" Note: Allows browsing the results using "Del"! By Questor
func! GrooVim_SearchGuyNavigate() range

	" Note: The list navigation is always forward to facilitate! By Questor
	let g:grooVimSearchFoward = 1

	let l:listPosLinCol = getpos(".")
	let l:listPosLinToArray = (l:listPosLinCol[1] - 1)
	if l:listPosLinToArray >= 0 && g:matchedLinesGlobalNavArray[l:listPosLinToArray] != 0

		exec "tabn " . split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[0]

		while !(expand('%:t') =~ "GrooVim_SearchGuyResults")
			exec "norm \<C-w>"
		endwhile

		set ma
		exec "norm ggdG"
		exec "put =g:matchedLinesGlobal"
		exec "norm ggdd"
		call setpos(".", l:listPosLinCol)
		exec "norm 0i->"
		set noma

		while expand('%:t') != split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[1]
			exec "norm \<C-w>"
		endwhile
		call setpos(".", [0, split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[2], split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[3]])
		exec "norm \<Left>n"

	endif

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

endfunc

" Note: Prepare "GrooVim_SearchGuy()" for a new run or closes it! By Questor
func! GrooVim_SearchGuyPrepare()

	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 1

		try
			" Note: With this approach I can effectively "destroy" the buffer not returning
			" "false" positives on "bufexists()" above! By Questor
			exec "bwipeout! GrooVim_SearchGuyResults" . tabpagenr()
		catch
			
		endtry

	endif

endfunc

" Note: For debugging purposes. To stop uses "0". Allows a "stop" on the line in that
" is called and displays a message! By Questor
func! GrooVim_PauseExecution(msg)
	echo "msg: \"" . a:msg . "\""
	while getchar() != 48
		exec "sleep 1000m"
	endwhile
endfunc

" Note: Allows normal use of the Enter (carriage return) key in visual mode! By Questor
vnoremap <buffer> <Enter>  "_x<bar>i<cr><Esc>

" Note: Sets the behavior of Del key depending on the context! By Questor
nnoremap <script> <Del> :call GrooVim_DelBehavior()<cr>
func! GrooVim_DelBehavior() range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Allows "multimode" normal use (delete) of the Del key! By Questor
		call GrooVim_NormalDel()
	endif
endfunc

" Note: Treat a string and return a substring to use in prompts! By Questor
func! GrooVim_SubstringToPrompt(stringToBeTreated)
	let l:lineSplited = split(a:stringToBeTreated, "\n")
	let l:transferAreaToShow = ""
	try
		" if len(l:lineSplited) > 1
			if strlen(l:lineSplited[0]) > 70
				let l:transferAreaToShow = l:lineSplited[0][0:70] . "..."
			else
				if len(l:lineSplited) > 1
					let l:transferAreaToShow = l:lineSplited[0] . "..."
				else
					let l:transferAreaToShow = l:lineSplited[0]
				endif
			endif
	catch

	endtry
	return l:transferAreaToShow
endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:configureGrooVim_EntertainmentReplace_Confirmation = 1
let g:searchReplace_InAllOpened = 0
let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = 1
let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = 0
func! GrooVim_EntertainmentReplace(mod) range

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	let l:valueToReplace = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToReplace = @+
	else
		let l:valueToReplace = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToReplaceTemp = GrooVim_EscapeSubstituteValueToSearch(input("Value that will be REPLACED (empty to use \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\"): "))
			if ("" . l:valueToReplaceTemp . "") != "" || ("" . l:valueToReplace . "") != ""
				let l:stopWhile = 1
				if l:valueToReplaceTemp != ""
					let l:valueToReplace = l:valueToReplaceTemp
				endif
			endif
		endwhile
	endif

	let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(input("Value that will REPLACE \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\" (empty to use transfer área value \"" . GrooVim_SubstringToPrompt(@+) . "\"): "))

	if l:valueThatWillReplace == ""
		" Note: "GrooVim_EscapeSubstituteValueToSearch()" is not required when the value
		" comes from "input()" since it already handles this need! By Questor
		let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(@+)
	endif

	let l:valueThatWillReplace = l:valueThatWillReplace

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToReplace)

	let l:confirmOrNot = ""

	if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
		let l:confirmOrNot = "c"
	endif

	if a:mod == "v"
		exec "norm \<Left>"
	else
		exec "norm b\<Left>"
	endif

	if g:searchReplace_InAllOpened != 1
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			" Note: Replace begin from current position! By Questor
			exec ".,$s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		else
			exec "%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		endif
	else
		" Note: "let g:tryCathOnTabDo = 1" -> If there is no value to replace in one
		" of the tabs, the process do not raises an error! By Questor
		let g:tryCathOnTabDo = 1
		call TabDo("%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot)
		let g:tryCathOnTabDo = 0
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"h\"!", 4)

endfunc

" Note: Create search pattern! By Questor
func! GrooVim_EscapeSubstituteValueToSearch(valueToTreat)
	let l:pattern = escape(a:valueToTreat, '\\/.*$^~[]')
	let l:pattern = substitute(l:pattern, "\n$", "", "")
	return l:pattern
endfunc

" Note: Workaround to get milliseconds! By Questor
func! GrooVim_GetMilliseconds()
	let l:format = "+%s%3N"
	let l:cmd = "/bin/date -u " . shellescape(format)
	let l:result = substitute(system(cmd), "[\]\|[[:cntrl:]]", "", "g")
	return l:result
endfunc

" Note: Allows a "super leader" that fires in any mode! With this approach I can map a
" larger amount of keys combinations! Note the use of the keys z, a and t in leader
" commands required for certain worarounds! By Questor

nnoremap <silent> <script> <F2> :call GrooVim_CommandZ("F2", "n")<cr>
inoremap <silent> <script> <F2> <C-o>:call GrooVim_CommandZ("F2", "i")<cr>
vnoremap <silent> <script> <F2> :<C-u>call GrooVim_CommandZ("F2", "v")<cr>

nnoremap <silent> <script> <F3> :call GrooVim_CommandZ("F3", "n")<cr>
inoremap <silent> <script> <F3> <C-o>:call GrooVim_CommandZ("F3", "i")<cr>
vnoremap <silent> <script> <F3> :<C-u>call GrooVim_CommandZ("F3", "v")<cr>

nnoremap <silent> <script> <F4> :call GrooVim_CommandZ("F4", "n")<cr>
inoremap <silent> <script> <F4> <C-o>:call GrooVim_CommandZ("F4", "i")<cr>
vnoremap <silent> <script> <F4> :<C-u>call GrooVim_CommandZ("F4", "v")<cr>

nnoremap <silent> <script> <F5> :call GrooVim_CommandZ("F5", "n")<cr>
inoremap <silent> <script> <F5> <C-o>:call GrooVim_CommandZ("F5", "i")<cr>
vnoremap <silent> <script> <F5> :<C-u>call GrooVim_CommandZ("F5", "v")<cr>

nnoremap <silent> <script> <F5> :norm q<cr>

" Tip: Try to "balance" the distribution of the keys to preserve your
" hands! By Questor

let g:GrooVim_CommandZMoment = 0
let g:GrooVim_CommandZChar = ""
let g:GrooVim_CommandZUnblock = 1
let g:GrooVim_CommandZFCaller = ""
func! GrooVim_CommandZ(GrooVim_CommandZFCallerNow, modType)

	let l:GrooVim_CommandZNowChar = ""

	" Note: This logic allows rerun the last command just using an F key (1, 2, 3...). If
	" there is a single F? in few milliseconds, the last command is executed without
	" waiting for a new key to compose a command. If a new key was informed fast enough
	" it rerun the last command! If an different F? is informed it will wait for a key
	" combination to compose the command! By Questor

	let l:GrooVim_CommandZMomentNow = GrooVim_GetMilliseconds()

	" Note: In terminal vim, prevent ghost echoing while running a shell command via system()! By Questor
	redraw!

	if (l:GrooVim_CommandZMomentNow - g:GrooVim_CommandZMoment) > 400 || g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow
		exec "sleep 400m"
		let l:GrooVim_CommandZNowChar = getchar(0)
		if l:GrooVim_CommandZNowChar != "" && l:GrooVim_CommandZNowChar != "\<f2>" && l:GrooVim_CommandZNowChar != "\<f3>" && l:GrooVim_CommandZNowChar != "\<f4>" && l:GrooVim_CommandZNowChar != "\<f5>"
			let g:GrooVim_CommandZChar = l:GrooVim_CommandZNowChar
		endif
		if g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow && l:GrooVim_CommandZNowChar == ""
			let g:GrooVim_CommandZChar = ""
		endif
	endif
	" Note: To debug! By Questor
	" echo g:GrooVim_CommandZChar
	let g:GrooVim_CommandZMoment = l:GrooVim_CommandZMomentNow
	if g:GrooVim_CommandZChar != "" && g:GrooVim_CommandZUnblock == 1
		" Note: Prevents rerun a command while another is in progress! By Questor
		let g:GrooVim_CommandZUnblock = 0
		" Note: Edit commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F2"
			" Note: Used keys for F2: h k j up down c a d q w e end del! By Questor
			" Note: To debug! By Questor
			" Note: Aligns to left (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				:left
			endif
			" Note: Aligns to right (k)! By Questor
			if g:GrooVim_CommandZChar == "107"
				:right
			endif
			" Note: Aligns to center (j)! By Questor
			if g:GrooVim_CommandZChar == "106"
				:center
			endif
			" Note: Changes to uppercase (normal/insert) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType != "v"
				exec "norm gUiwe"
			endif
			" Note: Changes to lowercase (normal/insert) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType != "v"
				exec "norm guiwe"
			endif
			" Note: Changes to uppercase (visual) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType == "v"
				call GrooVim_ToUpperLower("Upper")
			endif
			" Note: Changes to lowercase (visual) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType == "v"
				call GrooVim_ToUpperLower("Lower")
			endif
			" Note:  Copy all text in the current buffer (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				exec "%y+"
			endif
			" Note: Select all text in the current buffer (a)! By Questor
			if g:GrooVim_CommandZChar == "97"
				exec "norm ggVG$"
			endif
			" Note: Duplicates the current line/selection (normal) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "n"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplicates the current line/selection (insert) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "i"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplicates the current line/selection (visual) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "v"
				call GrooVim_DuplicateVisualSelection()
				" Note: If in the visual mode this command can not be replicated hold F key! By Questor
				let g:GrooVim_CommandZChar = ""
			endif
			" Note: Record a macro (q)! By Questor
			if g:GrooVim_CommandZChar == "113"
				call GrooVim_XenRec()
			endif
			" Note: Run a macro (w)! By Questor
			if g:GrooVim_CommandZChar == "119"
				call GrooVim_XenPlay(0)
			endif
			" Note: Run a macro certain number of times or repeatedly until the last line (e)! By Questor
			if g:GrooVim_CommandZChar == "101"
				call GrooVim_XenPlay(1)
			endif
			" Note: Selects the word under the cursor (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				exec "norm viw"
			endif
			" Note: Selects an area (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				call GrooVim_SelectRange(a:modType)
			endif
		endif
		" Note: Control commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F3"
			" Note: Used keys for F3: n c o v r / s f d h j [ ]! By Questor
			" Note: Open a new tab (n)! By Questor
			if g:GrooVim_CommandZChar == "110"
				tabnew
				" Note: Solve read only problem! By Questor
				set ma
			endif
			" Note: Close current tab (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				tabc
			endif
			" Note: Close all other tabs (o)! By Questor
			if g:GrooVim_CommandZChar == "111"
				tabonly
			endif
			" Note: Opens the file .vimrc (normal/visual) (v)! By Questor
			if g:GrooVim_CommandZChar == "118" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\zv")
			endif
			" Note: '' (insert) (v)! By Questor
			if g:GrooVim_CommandZChar == "118" && a:modType == "i"
				" Note: Workaround to avoid incompatibility! By Questor
				call feedkeys("\<Esc>\\zvi")
			endif
			" Note: Reloads the file .vimrc in all tabs (r)! By Questor
			if g:GrooVim_CommandZChar == "114" && a:modType == "i"
				" Note: Workaround to avoid incompatibility! By Questor
				call feedkeys("\<Esc>\\zvvi")
			endif
			" Note: '' (normal/visual) (r)! By Questor
			if g:GrooVim_CommandZChar == "114" && a:modType != "i"
				" Note: Workaround to avoid incompatibility! By Questor
				call feedkeys("\\zvv")
			endif
			" Note: Removes search highlights (visual/normal) (/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType != "i"
				" Note: Workaround to avoid incompatibility! By Questor
				call feedkeys("\\z/")
			endif
			" Note: '' (insert)(/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType == "i"
				" Note: Workaround to avoid incompatibility! By Questor
				call feedkeys("\<Esc>\\z/i")
			endif
			" Note: Save to disk (normal/insert) (s)! By Questor
			if g:GrooVim_CommandZChar == "115" && a:modType != "v"
				:w
			endif
			" Note: '' (visual) (s)! By Questor
			if g:GrooVim_CommandZChar == "115" && a:modType == "v"
				call GrooVim_VisualWrite()
			endif
			" Note: Opens for search (insert/normal) (f)! By Questor
			if g:GrooVim_CommandZChar == "102" && a:modType != "v"
				call GrooVim_SearchWithMyOptions("n")
			endif
			" Note: '' (visual) (f)! By Questor
			if g:GrooVim_CommandZChar == "102" && a:modType == "v"
				call GrooVim_SearchWithMyOptions("v")
			endif
			" Note: Opens to configure the search (d)! By Questor
			if g:GrooVim_CommandZChar == "100"
				call GrooVim_ConfigureSearchReplace("search")
			endif
			" Note: Opens to configure the replace (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				call GrooVim_ConfigureSearchReplace("replace")
			endif
			" Note: Opens to replace (normal/insert) (j)! By Questor
			if g:GrooVim_CommandZChar == "106" && a:modType != "v"
				call GrooVim_EntertainmentReplace("n")
			endif
			" Note: '' (visual) (j)! By Questor
			if g:GrooVim_CommandZChar == "106" && a:modType == "v"
				call GrooVim_EntertainmentReplace("v")
			endif
			" Note: Save session ([)! By Questor
			if g:GrooVim_CommandZChar == "91"
				exec "mksession! ~/vim_session"
				echomsg "Session saved!"
			endif
			" Note: Reload session (])! By Questor
			if g:GrooVim_CommandZChar == "93"
				exec "source ~/vim_session"
			endif
			" Note: Get current filename or filename and path and put on transfer area (p)! By Questor
			if g:GrooVim_CommandZChar == "112"
				call GrooVim_GetFileNameAndPath()
			endif
			" Note: Allows always returning to a particular tab using <Alt-Down> (t)! By Questor
			if g:GrooVim_CommandZChar == "116"
				call GrooVim_TabToReturnSet()
			endif
			" Note: Select and search the word under the cursor (case sensitive) (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				call GrooVim_SelectNSearch(1, a:modType)
			endif
			" Note: Reselect area (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				exec "norm gv"
			endif
			" Note: Save to disk and open in a new tab a copy of the current file (y)! By Questor
			if g:GrooVim_CommandZChar == "121"
				call GrooVim_SaveACopy()
			endif
		endif
		" Note: Plugin commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F4"
			" Note: Used keys for F4: f d! By Questor
			" Note: Opens/closes the "NerdTree" (n)! By Questor
			if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "110"
					" call ToggleNERDTree()
					call GrooVim_ToggleNERDTreeTabs()
				endif
			endif
			" Note: Opens/closes the "Vim Debug" (d)! By Questor
			if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "100"
					call GrooVim_ToggleDbg()
				endif
			endif
		endif
		" Note: Other commands! By Questor
		" Note: Used keys for F5: ! By Questor
		if a:GrooVim_CommandZFCallerNow == "F5"
		endif
		let g:GrooVim_CommandZUnblock = 1
	endif
	let g:GrooVim_CommandZFCaller = a:GrooVim_CommandZFCallerNow

endfunc

nnoremap <silent> <script> <F9> :call GrooVim_ToogleGrooVimHelp()<cr>

" Note: Try to ensure that open in an editor window! By Questor
func! GrooVim_PutOnEditWindow() range
	while expand('%:t') =~ "GrooVim_SearchGuyResults" || expand('%:t') =~ "NERD_tree_" || expand('%:t') =~ "GrooVimHelp"
		exec "norm \<C-w>"
	endwhile
endfunc

" Note: Displays the help for GrooVim. This text is in the own GrooVim body!! By Questor
func! GrooVim_ToogleGrooVimHelp() range

	if bufexists("GrooVimHelp") == 0

		call GrooVim_PutOnEditWindow()

		" Note: The "set ma" and "set noma" opens and locks the buffer editing! By Questor
		set ma
		silent exec "split GrooVimHelp"
		exec "put =g:GrooVimHelp"
		exec "norm ggdd"
		exec "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapmargin=0 | set formatoptions+=l | set syntax=help"
		set noma
	else
		" Note: With this approach I can effectively "destroy" the "buffer" not
		" returning false "positives" in "bufexists()" above! By Questor
		exec "bwipeout! GrooVimHelp"
	endif

endfunc

" Note: Get current filename or filename and path and put on transfer area! By Questor
func! GrooVim_GetFileNameAndPath() range

	let l:filenameOrFilenameAndPath = ""

	let l:getFilenameOrFilenameAndPath = GrooVim_GetOptions("Get [0]filename or [1]filename and path [0[default]/1]? ", [1,0], 0)
	if l:getFilenameOrFilenameAndPath == 0
		let l:filenameOrFilenameAndPath = expand('%:t')
		echomsg " -> Filename \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	elseif l:getFilenameOrFilenameAndPath == 1
		let l:filenameOrFilenameAndPath = expand('%:p')
		echomsg " -> Filename and path \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	endif

	" Note: Set the clipboard register! By Questor
	let @+ = l:filenameOrFilenameAndPath

endfunc

" Note: Record a macro! By Questor
func! GrooVim_XenRec() range
	call GrooVim_GrooVimBarMsg("Use \"q\" to stop macro recording!", 5)
	exec "norm qa"
	echo "Starting a NEW recording!"
endfunc

" Note: Run a macro certain number of times or repeatedly until the last line! By Questor
let g:GrooVim_XenPlayRunningWithSearch = 0
func! GrooVim_XenPlay(repeatExecution) range

	if a:repeatExecution == 0
		exec "norm @a"
		" Note: For unknown reasons the value of the variable "g: GrooVim_CommandZChar"
		" lost in the execution of the command, not allowing simple repetition and so
		" the workaround! By Questor
		let g:GrooVim_CommandZChar = "119"
	elseif a:repeatExecution == 1
		let g:block_GrooVim_HLNext = 1
		let g:GrooVim_XenPlayRunningWithSearch = 0
		let l:numberOfRepetitions = input("Number of repetitions (use \"x\" to excute to last/first line): ")
		" Note: Runs up to the last/first row!! By Questor
		if l:numberOfRepetitions == "x"
			" Note: "set nowrapscan" serves to avoid going back to the beginning! By Questor
			set nowrapscan
			let l:stopWhile = 0
			let l:firstExecution = 1
			let l:executionDirection = ""
			while l:stopWhile == 0
				let l:posBefore = getpos(".")
				if (l:posBefore[1] >= getpos("$")[1] || l:posBefore[1] == 1) && l:firstExecution == 0 && g:GrooVim_XenPlayRunningWithSearch == 0
					let l:stopWhile = 1
				endif

				" Note: If there are no more occurrences of a search then stops execution! By Questor
				try
					" Note: Tests if still there are occurrences! By Questor
					if l:executionDirection != "" && g:GrooVim_XenPlayRunningWithSearch == 1
						if l:executionDirection == "d"
							exec "norm n"
						endif
						if l:executionDirection == "u"
							exec "norm N"
						endif
						call setpos(".", l:posBefore)
					endif
					exec "norm @a"

				catch
					let l:stopWhile = 1
				endtry

				let l:posAfter = getpos(".")

				if l:posBefore[1] == l:posAfter[1] && l:firstExecution == 1 && g:GrooVim_XenPlayRunningWithSearch == 0

					if l:posBefore[1] != getpos("$")[1] && l:posBefore[1] != 1
						call GrooVim_GrooVimBarMsg("This macro isn't compatible with the execution that you selected. The current line will be always the same!", 4)
					endif
					let l:stopWhile = 1

				endif

				if l:executionDirection != ""
					if l:executionDirection == "d"
						if l:posBefore[1] > l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
					if l:executionDirection == "u"
						if l:posBefore[1] < l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
				endif

				if l:executionDirection == ""
					if l:posBefore[1] < l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] < l:posAfter[2])
						let l:executionDirection = "d"
					endif
					if l:posBefore[1] > l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] > l:posAfter[2])
						let l:executionDirection = "u"
					endif
				endif

				if l:stopWhile == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: The "redraw!" is to ensure that the message is displayed!! By Questor
					redraw!
				endif

				" Note: To see execution! By Questor
				redraw!

				let l:firstExecution = 0

			endwhile
			set wrapscan
		else

			" Note: Performs "n" times! By Questor

			" Note: Check for valid numbers! By Questor
			let l:invalidNumber = 1
			while l:invalidNumber == 1

				let l:invalidNumber = 0

				if l:numberOfRepetitions != str2nr(l:numberOfRepetitions)
					let l:invalidNumber = 1
				endif

				if l:numberOfRepetitions <= 0
					let l:invalidNumber = 1
				endif

				if l:invalidNumber == 1
					let l:numberOfRepetitions = input("Number of repetitions (use a valid one!): ")
				endif

			endwhile

			for i in range(1, l:numberOfRepetitions)

				" Note: If there are no more occurrences of a search then stops execution! By Questor
				try
					exec "norm @a"
				catch
					let l:stopWhile = 1
				endtry

				let g:onMoveScreen = 1
				if g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: The "redraw!" is to ensure that the message is displayed! By Questor
					redraw!
				endif
				" Note: To see execution! By Questor
				redraw!
			endfor

		endif

		" Note: For unknown reasons the value of the variable "g: GrooVim_CommandZChar"
		" lost in the execution of the command, not allowing simple repetition and so
		" the workaround! By Questor
		let g:GrooVim_CommandZChar = "101"

		let g:GrooVim_XenPlayRunningWithSearch = 0

	endif

	let g:block_GrooVim_HLNext = 0

endfunc

" Note: Duplicates the current line/selection! By Questor
func! GrooVim_DuplicateVisualSelection() range
	let l:saved_reg = @+
	exec "norm gvygv\<Esc>p"
	let @+ = l:saved_reg
endfunc

" Note: Reloads the .vimrc file! By Questor
nnoremap <silent> <leader>zv :tabedit $MYVIMRC<cr>
" Note: Opens the .vimrc file! By Questor
nnoremap <silent> <leader>zvv :tabdo source $MYVIMRC<cr><bar>:tabfirst<cr>

" Note: Clears the search register! By Questor
nnoremap <silent> <leader>z/ :nohlsearch<cr>

if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
	" Note: Opens and closes the "VIM Debug" depending on if it is open or closed! By Questor
	let g:NERDTreeIsOpen = 0
	func! GrooVim_ToggleDbg()
		if exists("g:Dbg")
			unlet g:Dbg
			Dbg quit
		else
			try
				if exists("g:NERDTreeIsOpen")
					unlet g:NERDTreeIsOpen
					NERDTreeTabsClose
				endif
					Dbg .
				let g:Dbg = 1
			catch
				echo "No Errors found!"
			endtry
		endif
	endfunc
endif

" Note: Save to disk and open in a new tab a copy of the current file! By Questor
func! GrooVim_SaveACopy() range

		let l:valueToPath = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToPath = input("PATH to save your file copy (type \"0\" to use transfer area \"" . GrooVim_SubstringToPrompt(@+) . "\", \"1\" to use empty, \"2\" to use current file path or enter one): ")
			if l:valueToPath == "0"
				if !empty(matchstr(@+, "\/$"))
					let l:stopWhile = 1
					let l:valueToPath = @+
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					" Note: The "redraw!" is to ensure that the message is displayed! By Questor
					redraw!
				endif
			elseif l:valueToPath == "1"
				let l:stopWhile = 1
				let l:valueToPath = ""
			elseif l:valueToPath == "2"
				let l:stopWhile = 1
				let l:valueToPath = expand("%:h") . "/"
			elseif ("" . l:valueToPath . "") != ""
				if !empty(matchstr(l:valueToPath, "\/$"))
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					redraw!
				endif
			endif
		endwhile

		let l:definePathWarning = ""
		let l:valueToName = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			if l:valueToPath == ""
				let l:definePathWarning = " (DEFINE A PATH TOO!)"
			endif
			let l:valueToName = input("NAME of the file copy to be saved" . l:definePathWarning . ": ")
			if ("" . l:valueToName . "") != ""
				if ("" . l:valueToName . "") != expand('%:t') || l:valueToPath != expand("%:h") . "/"
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Same name and path as the current file!", 1)
					redraw!
				endif
			endif
		endwhile

		try
			exec "w " . l:valueToPath . l:valueToName
			exec "tabnew " . l:valueToPath . l:valueToName
			call GrooVim_GrooVimBarMsg("A file copy was created!", 1)
			redraw!
		catch
			call GrooVim_GrooVimBarMsg("The file copy can't be saved! Reason: \"" . v:exception . "\"", 1)
			redraw!
		endtry

endfunc

" Note: Saves to disk! By Questor
func! GrooVim_VisualWrite() range
	" Note: Witre! By Questor
	exec "w"
	" Note: Reselect area! By Questor
	exec "norm gv"
endfunc

" Note: Changes to uppercase/lowercase! By Questor
func! GrooVim_ToUpperLower(modType) range
	" Note: Reselect area! By Questor
	exec "norm gv"

	if a:modType == "Upper"
		exec "norm gU"
	endif

	if a:modType == "Lower"
		exec "norm gu"
	endif

	" Note: Repositioning on final! By Questor
	exec "norm gv\<Esc>"
endfunc

" Note: Sudo to write! By Questor
"cnoremap w!! w !sudo tee % >/dev/null

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"APPEARANCE
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Displays the number of each line! By Questor
set number

" Note: Always show current position! By Questor
set ruler

" Note: Height of the command bar! By Questor
set cmdheight=2

" Note: For regular expressions turn magic on! By Questor
set magic

" Note: Show matching brackets when text indicator is over them! By Questor
set showmatch

" Note: How many tenths of a second to blink when matching brackets! By Questor
set mat=2

" Note: No annoying sound on errors! By Questor
set noerrorbells
set novisualbell

" ToDo: What comes to be? By Questor
" set t_vb=

" ToDo: Line break? By Questor
" set tm=500

" Note: Allow the cursor to go into "invalid" places! By Questor
" set virtualedit=all

" Note: Always turn on syntax highlighting for diffs (select by the file-suffix directly)! By Questor
augroup PatchDiffHighlight
	autocmd! BufEnter  *.patch,*.rej,*.diff   syntax enable
augroup end

" Note: Displays messages on the scroll bar! By Questor
let g:GrooVim_GrooVimBarMsgValue = ""
let g:GrooVim_GrooVimBarMsgMoment = ""
let g:GrooVim_GrooVimBarMsgEnabled = 0
let g:GrooVim_GrooVimBarMsgDuration = 0
func! GrooVim_GrooVimBarMsg(msgValue, msgDuration)

	if g:GrooVim_CheckCapsLockReturn == 0
		if a:msgValue != ""
			let g:GrooVim_GrooVimBarMsgValue = " Hey: " . a:msgValue
			let g:GrooVim_GrooVimBarMsgMoment = strftime("%Y%m%d%H%M%S")
			let g:GrooVim_GrooVimBarMsgEnabled = 1
			let g:GrooVim_GrooVimBarMsgDuration = a:msgDuration
		else
			let g:GrooVim_GrooVimBarMsgValue = ""
			let g:GrooVim_GrooVimBarMsgEnabled = 0
		endif
		call GrooVim_GrooVimBar()
	endif

endfun

" Note: Displays an information bar! By Questor
set laststatus=2
func! GrooVim_GrooVimBar()

	let l:barContents = '%f [%{(&fenc==""?&enc:&fenc).((exists("+bomb") && &bomb)?",B":"")}%M%R%H%W] %y [%l/%L,%v] [%p%%]'
	return l:barContents . " Powered by [GrooVim =D " . g:grooVimVersion . "]!" . g:GrooVim_GrooVimBarMsgValue

endfun
set stl=%!GrooVim_GrooVimBar()
" Note: Displays a message on the initial run! By Questor
call GrooVim_GrooVimBarMsg("To see GrooVim help use F9!", 10)

" Note: Make the 81st column stand out (just the 80st column of wide lines...)! By Questor
highlight GrooVim_ColorColumn ctermbg=blue
augroup GrooVim_ColorColumn
	autocmd! VimEnter,WinEnter * call matchadd('GrooVim_ColorColumn', '\%81v', 100)
augroup end

" Note: Make tabs, trailing whitespace and non-breaking spaces visible! By Questor
set list
" Note: Type I! By Questor
"exec "set listchars=tab:\uBB\uBB,trail:\uB7,nbsp:~"
" Note: Type II! By Questor
exec "set listchars=tab:▒░,trail:\uB7,nbsp:~"

" Note: Switch syntax highlighting on, when the terminal has colors! By Questor
if &t_Co > 2 || has("gui_running")
	syntax on
endif

" Note: Switch from block-cursor to vertical-line-cursor when going into/out of insert mode! By Questor
" let &t_SI = "\<Esc>]50;CursorShape=1\x7"
" let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" Note: " Cursor -> Orange in insert mode and red in command mode!
" if you want to use rgb color formatting: konsoleprofile
" CustomCursorColor=#255255255! By Questor
let g:cursorColorI = "orange"
let g:cursorColorNV = "red"
let g:cursorColorBlock = 0

func! SetCursorColor()
	let &t_SI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorI . ";BlinkingCursorEnabled=1\x7"
	let &t_EI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorNV . ";BlinkingCursorEnabled=0\x7"
endfun

if &term =~ "xterm\\|rxvt" && $COLORTERM != "gnome-terminal"
	autocmd VimEnter * silent !konsoleprofile UseCustomCursorColor=1
	call SetCursorColor()
	silent !konsoleprofile CustomCursorColor=red
	autocmd VimLeave * silent !konsoleprofile CustomCursorColor=default;BlinkingCursorEnabled=0
endif

" " Note: Displays a line below the cursor (causes slowdown)! By Questor
" if exists('+cursorline')
" 	set cursorline cursorcolumn
" endif
"
" " Note: Displays a column over the cursor (causes slowdown)! By Questor
" hi CursorLine cterm=NONE,underline guibg=#F4F4F4
" hi! link CursorColumn CursorLine

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"USABILITY
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always show what mode we're currently editing in! By Questor
set showmode

" Note: Don't wrap lines! By Questor
set nowrap

" Note: Allow backspacing over everything in insert mode! By Questor
set backspace=indent,eol,start

" Note: Remember more commands and search history! By Questor
set history=1000

" Note: Use many/muchos levels of undo! By Questor
set undolevels=1000

" Note: Ignore case when searching! By Questor
set ignorecase

" Note: When searching try to be smart about cases! By Questor 
" set smartcase

" Note: Makes search act like search in modern browsers ("highlight"
" occurrences already in typing)! By Questor
set incsearch

" Note: Search/replace "globally" (on a line) by default! By Questor
set gdefault

" Note: Return to last edit position when opening files (you want this!)! By Questor
autocmd! BufReadPost *
	\ if line("'\"") > 0 && line("'\"") <= line("$") |
	\   exe "normal! g`\"" |
	\ endif
set viminfo^=%

" Note: Bind <F1> to show the keyword under cursor general help that can still be
" entered manually, with :h! By Questor
if has("autocmd")
	augroup vim_files
		autocmd! filetype vim noremap <buffer> <F1> <Esc>:help <C-r><C-w><cr>
		autocmd! filetype vim noremap! <buffer> <F1> <Esc>:help <C-r><C-w><cr>
	augroup end
endif

" Note: Turn persistent undo on means that you can undo even when you close a
" buffer/VIM! By Questor
" ToDo: Document the need for this directory! By Questor
try
	set undodir=~/.vim/Temp/Undodir
	set undofile
catch
endtry

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"INDENTATION AND SYNTAX
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always set autoindenting on! By Questor
" set autoindent

" Note: Copy the previous indentation on autoindenting! By Questor
" set copyindent

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"PLUGINS CONFIGURATION
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"* NERDTree

" Note: Store the bookmarks file! By Questor
let NERDTreeBookmarksFile = expand("$HOME/.vim/NERDTreeBookmarks")

" Note: Show the bookmarks table on startup! By Questor
let NERDTreeShowBookmarks = 1

" Note: Show hidden files, too! By Questor
let NERDTreeShowFiles = 1

" Note: Quit on opening files from the tree! By Questor
" let NERDTreeQuitOnOpen = 1

" Note: Highlight the selected entry in the tree! By Questor
let NERDTreeHighlightCursorline = 1

" Note: Use a single click to fold/unfold directories and a double click to open
" files! By Questor
let NERDTreeMouseMode=2

" Note: NERDTree always open on the right side! By Questor
let NERDTreeWinPos = "right"

"* move-vim

" Note: Mapping to move-vim! By Questor
if g:enable_move_vim == 1 && g:enable_all_plugins == 1
	let g:move_key_modifier = "C"
	inoremap <silent> <C-k> <C-o>:call GrooVim_Move_Vim_OnInsert("up")<cr>
	inoremap <silent> <C-j> <C-o>:call GrooVim_Move_Vim_OnInsert("down")<cr>
	" Note: This workaround is for the "Move Vim" can be fired in insert mode! By Questor
	func! GrooVim_Move_Vim_OnInsert(direc)
		if a:direc == "up"
			exec "norm \<C-k>"
		elseif a:direc == "down"
			exec "norm \<C-j>"
		endif
	endfun
endif

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENCODING
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,big5,gb2312,latin1

fun! ViewUTF8()
	set encoding=utf-8
	set termencoding=big5
endfun

fun! UTF8()
	set encoding=utf-8
	set termencoding=big5
	set fileencoding=utf-8
	set fileencodings=ucs-bom,big5,utf-8,latin1
endfun

fun! Big5()
	set encoding=big5
	set fileencoding=big5
endfun

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"HELP
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: To facilitate and avoid performance problems that text should always be
" the last! By Questor

let g:GrooVimHelp = "*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n|GrooVim|=D|2.0.7b|-|Vi|IMproved\'n\'GrooVIed!|".
\"\n Last change: 2014 June 12".
\"\n Eduardo L\u00facio Amorim Costa~".
\"\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n".
\"\n                   {+}".
\"\n                  {+++}".
\"\n                 {+++++}".
\"\n                {+++++++}".
\"\n               {+++++++++}".
\"\n             {+++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n{+++++++++++++++++++++++++++++++++++++++}".
\"\n  {++++++++++++++GrooVim++++++++++++++}".
\"\n    {+++++++++++++++++++++++++++++++}".
\"\n      {+++++++++++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n           {+++++++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n        {+++++++++++++++++++++++}".
\"\n       {++++++++}       {++++++++}".
\"\n      {+++++}               {+++++}".
\"\n     {++}                       {++}".
\"\n".
\"\n|BETA|VERSION!|".
\"\n".
\"\n * What is GrooVim?~".
\"\n".
\"\n The|GrooVim|is an extensive script (it\'s a|.vimrc|) that modifies the behavior of Vim to facilitate your work and increase your productivity aim the following objectives:".
\"\n*o*  Allow use with just a few instructions by a public accustomed to editors/IDEs default;".
\"\n*o*  Facilitate and accelerate widely the use, being also a integrated \"UI\";".
\"\n*o*  Preserving always that possible the default behavior of Vim;".
\"\n*o*  Enhancing Vim project as a general purpose IDE;".
\"\n*o*  Approach Vim of \"standard\" text editors in what is convenient and positive and modify Vim in its negative aspects;".
\"\n*o*  Promote Vim as a better and faster alternative to market text editors and IDEs as well as a general-purpose editor;".
\"\n*o*  Enhancing Vim project as a free alternative (this script is Apache License - Version 2.0), independent and community-supported initiative;".
\"\n*o*  Encourage the use of shell Vim;".
\"\n*o*  Being a \"all in one\" package, ie, depend only on the contents of the file|.vimrc|to work (no plugin scenario);".
\"\n*o*  Being a script for all types of terminals;".
\"\n".
\"\n * Before you start with the GrooVim!~".
\"\n".
\"\n--------".
\"\n *IMPORTANT_I!* If you do not know how Vim works, please open a terminal, run|vimtutor|and do the exercises (takes 25 to 30 minutes). Then continue reading this document! IT IS VERY IMPORTANT TO KNOW THE DEFAULT VIM IN ITS BASIC, SO YOU CAN USE IT BETTER AND CONTRIBUTE WITH NEW FEATURES!".
\"\n *IMPORTANT_II!* The Vim is a powerful general purpose text editor/IDE. Keep in mind that the GrooVim was made possible through its great API (script) and wide versatility!".
\"\n *IMPORTANT_III!* Certain terminal emulators limits the possibility of Vim and GrooVim. Therefore, we recommend that for your \"all day\" Vim use a terminal that allows more possibilities and features!".
\"\n--------".
\"\n".
\"\n*o*  The GrooVim was designed to work with a wide range of keyboard shortcuts. Eventually, such shortcuts may present conflicts with shortcuts from your OS. This is normal and if conflicts occur we recommend that you modify the shortcuts of your OS, because the terminal environment does not allow a large number of combinations to form shortcuts;".
\"\n*o*  To further facilitate your life and increase productivity we recommend you make a mapping in your terminal to navigate between tabs using <Shift-Left>/<Shift-Right>. These two keyboard shortcuts (<Shift-Left>/<Shift-Right>) are not mapped in GrooVim to that you use in the way mentioned;".
\"\n   |-|Note: KDE desktop environment already works in that way with its terminal;".
\"\n*o*  The GrooVim was designed to work with tabs;".
\"\n*o*  The GrooVim was designed to work without constant use of \'virtualedit\' (\"virtualedit set=all\") to facilitate cursor navigation \"despising invalid areas\" (or without character) when convenient;".
\"\n*o*  The GrooVim was designed to work with the best plugins;".
\"\n   |-|We recommend install ALL the following plugins:".
\"\n      |-|*NERDTree*".
\"\n         |[https://github.com/scrooloose/nerdtree]|".
\"\n      |-|*tcomment*".
\"\n         |[https://github.com/tomtom/tcomment_vim]|".
\"\n      |-|*move*".
\"\n         |[https://github.com/matze/vim-move]|".
\"\n*o*  When using plugins *Pathogen* plugin needs to be intalled|[https://github.com/tpope/vim-pathogen];".
\"\n*o*  By default GrooVim not have any enabled plugin (see|let|g:enable_all_plugins|=|0|). You can also enable the plugins individually;".
\"\n".
\"\n * The GrooVim solves the following \"problems\"!!~".
\"\n".
\"\n*o*  <Ctrl-Left>/<Ctrl-Right> (normal mode/insert/visual) - Navigate by words in a conventional and practical way;".
\"\n*o*  <Tab> (normal mode/visual)- Indent in a conventional and practical way;".
\"\n*o*  <Enter> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Backspace> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Del> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Space> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  In the alternation between modes the cursor stays correctly positioned;".
\"\n*o*  Use default clipboard in a correct and conventional way (copy, cut and paste);".
\"\n*o* |Replace|, <x> (remove) and <d> (delete) preserving the clipboard;".
\"\n*o*  <PageDown>/<PageUp> - With navigation across the screen (invalid areas);".
\"\n*o*  <MouseScrollDown>/<MouseScrollUp> - With navigation across the screen (invalid areas);".
\"\n*o*  <MouseClick> (normal mode) - Across the screen (invalid areas);".
\"\n*o*  Just a <Ctrl-w> switches between windows;".
\"\n*o*  Etc...".
\"\n".
\"\n * Editor features!~".
\"\n".
\"\n*o*  Switching between modes:".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Enter or exit the insert mode;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Enter or exit the visual mode;".
\"\n".
\"\n*o*  Sele\u00e7\u00e3o de texto:".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert) - Word selection to the right/left;".
\"\n   |-|<Alt-End>/<Alt-Home> (normal mode/insert) - Select text on the line until the end/beginning from the current point;".
\"\n".
\"\n*o*  Conventional text editors commands:".
\"\n   |-|<Ctrl-c> (visual mode) - Copy to clipboard;".
\"\n   |-|<Ctrl-v> (normal mode/insert/visual) - Paste from clipboard;".
\"\n   |-|<Ctrl-x> (visual mode) - Cut to the clipboard;".
\"\n   |-|<Ctrl-u> (normal mode/insert/visual) - Undo;".
\"\n   |-|<Ctrl-r> (normal mode/insert/visual) - Redo;".
\"\n".
\"\n*o*  Plugins:".
\"\n   |-|move-vim;|".
\"\n        <Ctrl-j>/<Ctrl-k> (normal mode/insert/visual) - Move line or selection up/down;".
\"\n".
\"\n * Relevant changes in the default Vim behavior!~".
\"\n".
\"\n   |-|Use |Ctrl+b| to enable visual block mode;".
\"\n   |-|When changes from |visual|mode| to |insert|mode|the cursor do not move;".
\"\n   |-|Use default OS clipboard;".
\"\n   |-|The \"insert\" and \"paste\" from the same cursor position;".
\"\n".
\"\n * Script features!~".
\"\n".
\"\n*o*  Navigation".
\"\n".
\"\n   |-|<Shift-Alt-Arrows> (normal mode/insert/visual) - Smooth navigation across the screen with long movements (invalid areas);".
\"\n   |-|<Ctrl-Alt-Arrows> (normal mode/insert/visual) - Navigation with arrows across the screen (invalid areas) using shorts movements;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Returns to the previous tab;".
\"\n   |-|<Ctrl-Down>/<Ctrl-Up> (normal mode/insert/visual) - The access tabs on left/right;".
\"\n".
\"\n*o*  Word selection".
\"\n".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert/visual) - Word selection to the right/left;".
\"\n   |-|<2-leftmouse> (normal mode/insert) - Double click the mouse on a word then press <z> letter. All words with the same content will be highlighted;".
\"\n".
\"\n*o*  Comment lines".
\"\n".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Comment lines using *tcomment.vim* ;".
\"\n".
\"\n * F\'S Shortcuts (CommandZ)!~".
\"\n".
\"\n  The |CommandZ| is a kind of \"super leader\" that allows an extensive keys combination to create keyboard shortcuts for features in Vim. Works pressing <F2>, <F3> or <F4> keys and then another key.".
\"\n".
\"\n*o*  Features".
\"\n ".
\"\n |-|Allows replication of the last command just by pressing the last |F| used. If in a given interval a key combination is not informed the last command is repeated;".
\"\n |-|If |F| is hold down the command is replicated several times;".
\"\n".
\"\n    <F2> and then...".
\"\n      Note: Preferably for editing commands;".
\"\n        <h> - Aligns to left (normal mode/insert/visual);".
\"\n        <k> - Aligns to right (normal mode/insert/visual);".
\"\n        <j> - Aligns to center (normal mode/insert/visual);".
\"\n        <Up> - Changes to uppercase (normal mode/insert/visual);".
\"\n        <Down> - Changes to lowercase (normal mode/insert/visual);".
\"\n        <c> - Copy all text in the current buffer (normal mode/insert/visual);".
\"\n        <a> - Select all text in the current buffer (normal mode/insert/visual);".
\"\n        <d> - Duplicates the current line/selection (normal mode/insert/visual);".
\"\n            Note: If in the visual mode can not be replicated;".
\"\n        <q> - Record a macro (normal mode/insert/visual);".
\"\n        <w> - Run a macro (normal mode/insert/visual);".
\"\n        <e> - Run a macro certain number of times or repeatedly until the last line (normal mode/insert/visual);".
\"\n        <End> - Selects the word under the cursor (normal mode/insert/visual);".
\"\n        <Del> - Selects an area (normal mode/insert);".
\"\n".
\"\n    <F3> and then...".
\"\n      Note: Preferably for commands that \"traditionally\" involve|Ctrl|in other editors;".
\"\n        <n> - Open a new tab (normal mode/insert/visual);".
\"\n        <c> - Close current tab (normal mode/insert/visual);".
\"\n        <o> - Close all other tabs (normal mode/insert/visual);".
\"\n        <v> - Opens the file|.vimrc|(normal mode/insert/visual);".
\"\n        <r> - Reloads the file|.vimrc|in all tabs (normal mode/insert/visual);".
\"\n       |</>|- Removes search highlights (normal mode/insert/visual);".
\"\n        <s> - Save to disk (normal mode/insert/visual);".
\"\n        <f> - Opens for search (normal mode/insert/visual);".
\"\n        <d> - Opens to configure the search (normal mode/insert/visual);".
\"\n        <j> - Opens to replace (normal mode/insert/visual);".
\"\n        <h> - Opens to configure the replace (normal mode/insert/visual);".
\"\n       |<[>|- Saves the current session (normal mode/insert/visual);".
\"\n       |<]>|- Reloads the last saved session (normal mode/insert/visual);".
\"\n        <p> - Copies to the clipboard the name or path and name of the current buffer/file (normal mode/insert/visual);".
\"\n        <t> - Allows always returning to a particular tab using <Alt-Down> (normal mode/insert/visual);".
\"\n        <End> - Select and search the word under the cursor (case sensitive) (normal mode/insert/visual);".
\"\n        <Del> - Reselect area (normal mode/insert/visual);".
\"\n        <y> - Save to disk and open in a new tab a copy of the current file (normal mode/insert/visual);".
\"\n".
\"\n    <F4> and then...".
\"\n      Note: Preferably to trigger the installed plugins and their functionalities;".
\"\n        <n> - Opens/closes the *NERDTree* (normal mode/insert/visual);".
\"\n".
\"\n * Integration with plugins~".
\"\n".
\"\n   *Undone...*".
\"\n".
\"\n * Tasks/Pendings/Bugs~".
\"\n".
\"\n   *Undone...*".
\"\n".
\"\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n"

" Note: To test the help use: "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapḿargin=0 | set formatoptions+=l | set syntax=help"! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D

