" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"LICENSE (Apache License "Version 2.0")
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"
"                                  Apache License
"                            Version 2.0, January 2004
"                         http://www.apache.org/licenses/
"
"    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
"
"    1. Definitions.
"
"       "License" shall mean the terms and conditions for use, reproduction,
"       and distribution as defined by Sections 1 through 9 of this document.
"
"       "Licensor" shall mean the copyright owner or entity authorized by
"       the copyright owner that is granting the License.
"
"       "Legal Entity" shall mean the union of the acting entity and all
"       other entities that control, are controlled by, or are under common
"       control with that entity. For the purposes of this definition,
"       "control" means (i) the power, direct or indirect, to cause the
"       direction or management of such entity, whether by contract or
"       otherwise, or (ii) ownership of fifty percent (50%) or more of the
"       outstanding shares, or (iii) beneficial ownership of such entity.
"
"       "You" (or "Your") shall mean an individual or Legal Entity
"       exercising permissions granted by this License.
"
"       "Source" form shall mean the preferred form for making modifications,
"       including but not limited to software source code, documentation
"       source, and configuration files.
"
"       "Object" form shall mean any form resulting from mechanical
"       transformation or translation of a Source form, including but
"       not limited to compiled object code, generated documentation,
"       and conversions to other media types.
"
"       "Work" shall mean the work of authorship, whether in Source or
"       Object form, made available under the License, as indicated by a
"       copyright notice that is included in or attached to the work
"       (an example is provided in the Appendix below).
"
"       "Derivative Works" shall mean any work, whether in Source or Object
"       form, that is based on (or derived from) the Work and for which the
"       editorial revisions, annotations, elaborations, or other modifications
"       represent, as a whole, an original work of authorship. For the purposes
"       of this License, Derivative Works shall not include works that remain
"       separable from, or merely link (or bind by name) to the interfaces of,
"       the Work and Derivative Works thereof.
"
"       "Contribution" shall mean any work of authorship, including
"       the original version of the Work and any modifications or additions
"       to that Work or Derivative Works thereof, that is intentionally
"       submitted to Licensor for inclusion in the Work by the copyright owner
"       or by an individual or Legal Entity authorized to submit on behalf of
"       the copyright owner. For the purposes of this definition, "submitted"
"       means any form of electronic, verbal, or written communication sent
"       to the Licensor or its representatives, including but not limited to
"       communication on electronic mailing lists, source code control systems,
"       and issue tracking systems that are managed by, or on behalf of, the
"       Licensor for the purpose of discussing and improving the Work, but
"       excluding communication that is conspicuously marked or otherwise
"       designated in writing by the copyright owner as "Not a Contribution."
"
"       "Contributor" shall mean Licensor and any individual or Legal Entity
"       on behalf of whom a Contribution has been received by Licensor and
"       subsequently incorporated within the Work.
"
"    2. Grant of Copyright License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       copyright license to reproduce, prepare Derivative Works of,
"       publicly display, publicly perform, sublicense, and distribute the
"       Work and such Derivative Works in Source or Object form.
"
"    3. Grant of Patent License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       (except as stated in this section) patent license to make, have made,
"       use, offer to sell, sell, import, and otherwise transfer the Work,
"       where such license applies only to those patent claims licensable
"       by such Contributor that are necessarily infringed by their
"       Contribution(s) alone or by combination of their Contribution(s)
"       with the Work to which such Contribution(s) was submitted. If You
"       institute patent litigation against any entity (including a
"       cross-claim or counterclaim in a lawsuit) alleging that the Work
"       or a Contribution incorporated within the Work constitutes direct
"       or contributory patent infringement, then any patent licenses
"       granted to You under this License for that Work shall terminate
"       as of the date such litigation is filed.
"
"    4. Redistribution. You may reproduce and distribute copies of the
"       Work or Derivative Works thereof in any medium, with or without
"       modifications, and in Source or Object form, provided that You
"       meet the following conditions:
"
"       (a) You must give any other recipients of the Work or
"           Derivative Works a copy of this License; and
"
"       (b) You must cause any modified files to carry prominent notices
"           stating that You changed the files; and
"
"       (c) You must retain, in the Source form of any Derivative Works
"           that You distribute, all copyright, patent, trademark, and
"           attribution notices from the Source form of the Work,
"           excluding those notices that do not pertain to any part of
"           the Derivative Works; and
"
"       (d) If the Work includes a "NOTICE" text file as part of its
"           distribution, then any Derivative Works that You distribute must
"           include a readable copy of the attribution notices contained
"           within such NOTICE file, excluding those notices that do not
"           pertain to any part of the Derivative Works, in at least one
"           of the following places: within a NOTICE text file distributed
"           as part of the Derivative Works; within the Source form or
"           documentation, if provided along with the Derivative Works; or,
"           within a display generated by the Derivative Works, if and
"           wherever such third-party notices normally appear. The contents
"           of the NOTICE file are for informational purposes only and
"           do not modify the License. You may add Your own attribution
"           notices within Derivative Works that You distribute, alongside
"           or as an addendum to the NOTICE text from the Work, provided
"           that such additional attribution notices cannot be construed
"           as modifying the License.
"
"       You may add Your own copyright statement to Your modifications and
"       may provide additional or different license terms and conditions
"       for use, reproduction, or distribution of Your modifications, or
"       for any such Derivative Works as a whole, provided Your use,
"       reproduction, and distribution of the Work otherwise complies with
"       the conditions stated in this License.
"
"    5. Submission of Contributions. Unless You explicitly state otherwise,
"       any Contribution intentionally submitted for inclusion in the Work
"       by You to the Licensor shall be under the terms and conditions of
"       this License, without any additional terms or conditions.
"       Notwithstanding the above, nothing herein shall supersede or modify
"       the terms of any separate license agreement you may have executed
"       with Licensor regarding such Contributions.
"
"    6. Trademarks. This License does not grant permission to use the trade
"       names, trademarks, service marks, or product names of the Licensor,
"       except as required for reasonable and customary use in describing the
"       origin of the Work and reproducing the content of the NOTICE file.
"
"    7. Disclaimer of Warranty. Unless required by applicable law or
"       agreed to in writing, Licensor provides the Work (and each
"       Contributor provides its Contributions) on an "AS IS" BASIS,
"       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
"       implied, including, without limitation, any warranties or conditions
"       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
"       PARTICULAR PURPOSE. You are solely responsible for determining the
"       appropriateness of using or redistributing the Work and assume any
"       risks associated with Your exercise of permissions under this License.
"
"    8. Limitation of Liability. In no event and under no legal theory,
"       whether in tort (including negligence), contract, or otherwise,
"       unless required by applicable law (such as deliberate and grossly
"       negligent acts) or agreed to in writing, shall any Contributor be
"       liable to You for damages, including any direct, indirect, special,
"       incidental, or consequential damages of any character arising as a
"       result of this License or out of the use or inability to use the
"       Work (including but not limited to damages for loss of goodwill,
"       work stoppage, computer failure or malfunction, or any and all
"       other commercial damages or losses), even if such Contributor
"       has been advised of the possibility of such damages.
"
"    9. Accepting Warranty or Additional Liability. While redistributing
"       the Work or Derivative Works thereof, You may choose to offer,
"       and charge a fee for, acceptance of support, warranty, indemnity,
"       or other liability obligations and/or rights consistent with this
"       License. However, in accepting such obligations, You may act only
"       on Your own behalf and on Your sole responsibility, not on behalf
"       of any other Contributor, and only if You agree to indemnify,
"       defend, and hold each Contributor harmless for any liability
"       incurred by, or claims asserted against, such Contributor by reason
"       of your accepting any such warranty or additional liability.
"
"    END OF TERMS AND CONDITIONS
"
"    APPENDIX: How to apply the Apache License to your work.
"
"       To apply the Apache License to your work, attach the following
"       boilerplate notice, with the fields enclosed by brackets "[]"
"       replaced with your own identifying information. (Don't include
"       the brackets!)  The text should be enclosed in the appropriate
"       comment syntax for the file format. We also recommend that a
"       file or class name and description of purpose be included on the
"       same "printed page" as the copyright notice for easier
"       identification within third-party archives.
"
"    Copyright 2014 Eduardo Lúcio Amorim Costa
"
"    Licensed under the Apache License, Version 2.0 (the "License");
"    you may not use this file except in compliance with the License.
"    You may obtain a copy of the License at
"
"        http://www.apache.org/licenses/LICENSE-2.0
"
"    Unless required by applicable law or agreed to in writing, software
"    distributed under the License is distributed on an "AS IS" BASIS,
"    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
"    See the License for the specific language governing permissions and
"    limitations under the License.

let g:grooVimVersion = "v2.0.8b"
" Eduardo Lúcio
" 2014

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"TASK LIST/BUGS LIST
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" ToDo: No copy file sugerir nome automaticamente! Questor

" ToDo: F3+c não pode funcionar para o NerdTree! Questor

" ToDo: Disponibilizar a busca "por palavra inteira apenas"! Questor

" ToDo: GroovyMove está com problemas (para arquivos *.py) no insert/visual (perde o virtual edit)! Questor

" ToDo: Criar um esquema de configuração de acordo com o tipo de arquivo e que
" fique no final deste .vimrc! Questor

" ToDo: For python using 4 tab spaces (testar)? Questor

" ToDo: Usar python scripts? Questor

" ToDo: Visual block -> GroovyMove problem! Questor

" ToDo: "Limpar" e "organizar" o código (testar)! By Questor

" ToDo: Atualizar o help (OK)! By Questor

" ToDo: Save a copy and open that (testar)! By Questor

" ToDo: Funcionalidade para reselecionar a última seleção do visual mode (testar)! By Questor

" ToDo: Ctrl+k,j,... (move-vim) no normal mode (testar)! By Questor

" ToDo: A recuperação da área de transferência está dando problema para o
" replace (testar)! By Questor

" ToDo: Replace quando o pathern tem várias linhas? By Questor

" ToDo: "F3+End" não funciona no insert mode! Deve ser case sensitive (testar)! By Questor

" ToDo: "Forçar" um fundo negro (cancelado)? By Questor

" ToDo: Cor do cursor na movimentação "GroovyMove" no insert mode (cancelado)! By Questor

" ToDo: Mensagem "Search hit botton!" na lista de pesquisa? By Questor

" ToDo: Sempre ficar no final da tab (linhas vazias, normal mode) (testar)! By Questor

" ToDo: Improve syntax and lexers (mainly python)! By Questor

" ToDo: A pesquisa com lista não está brilhando as ocorrências (testar)! By Questor

" ToDo: Ao desabilitar a pesquisa por lista, se houver lista aberta esta não
" fecha se for disparado novamente "F3 -> f" (testar)! By Questor

" ToDo: "set expandtab" X "set listchars=tab:▒░,trail:·" problem! By Questor

" ToDo: Criar configuração parametrizável para cada distribuição (extensível ao help)! By Questor

" ToDo: Colocar atalho de contexto no OS (sergundo botão do mouse e também abrir com duplo click)! By Questor

" ToDo: Replace a partir de determinada posição (o replace padrão é à partir
" do começo do arquivo)! -> Colocar como opcional (testar)! By Questor

" ToDo: Enter qdo última linha e 1 coluna cria nova linha abaixo (não consegui reproduzir) (Esse comportamento está de acordo
" com características do arquivo mas não consegui delimitar as causas)! By Questor

" ToDo: Show cursor position (blink a "scope")? By Questor

" ToDo: Melhorar a apresentação das abas das tabs? Barra de rolagem? By Questor

" ToDo: Permitir todas funcionalidades para "virtualedit=all"? By Questor

" ToDo: Voltar para a primeira de todas as posições após um replace? By Questor

" ToDo: Tratar problema de lentidão com linhas longas! By Questor

" ToDo: Criar verificação do sistema operacional para os comandos que
" dependem dele! By Questor

" ToDo: Criar comando que desabilita totalmente o GrooVim! By Questor

" ToDo: Rever os comandos dependentes de learderkey? By Questor

" ToDo: Mapear setas (apenas referência dos commandos) (colocar no HELP)! By Questor

" ToDo: Mark line and navigate (bookmarks?)(mark.vim?)! By Questor

" ToDo: Toogle area "" TEXT AREA {{{ }}}"! By Questor

" ToDo: Traduzir a documentação para inglês! By Questor

" ToDo: Testar para outras distribuições! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"MAIN
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"FILE SYNTAX ASSOCIATIONS AND SPECIFIC CONFIGURATION
"$$$$$$$$$$$$$

" Note: General tab conf! By Questor

" Note: Size of a hard tabstop! By Questor
set tabstop=2

" Note: Size of an "indent"! By Questor
set shiftwidth=2

" Note: A combination of spaces and tabs are used to simulate tab stops at a width
" other than the (hard) tabstop! By Questor
set softtabstop=2

" Note: General tab conf! By Questor
func! SpecificTabConf(tabWidth)

	" Note: Size of a hard tabstop! By Questor
	exec "set tabstop=" . a:tabWidth

	" Note: Size of an "indent"! By Questor
	exec "set shiftwidth=" . a:tabWidth

	" Note: A combination of spaces and tabs are used to simulate tab stops at a width
	" other than the (hard) tabstop! By Questor
	exec "set softtabstop=" . a:tabWidth

endfun

"  * .inc

autocmd! BufReadPost *.inc set syntax=html | set filetype=html

"  * .gds

autocmd! BufReadPost *.gds set syntax=vb | set filetype=vb

"  * .py

autocmd! BufReadPost *.py call SpecificTabConf(4)

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENABLE PLUGINS
"$$$$$$$$$$$$$

" Note: Enable all plugins! By Questor
let g:enable_all_plugins = 1

" Note: tcomment.vim! By Questor
let g:enable_tcomment_vim = 1

" Note: nerdtree.vim! By Questor
let g:enable_nerdtree_vim = 1

" Note: debugger.vim! By Questor
let g:enable_debugger_vim = 1

" Note: move.vim! By Questor
let g:enable_move_vim = 1

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"PERFORMANCE
"$$$$$$$$$$$$$

" Note: You got a fast terminal! By Questor
set ttyfast

" Note: Aumentar a velocidade do scroll! By Questor
set ttyscroll=3

" Note: Remover efeitos do cursor para aumentar o desempenho! By Questor
set nocursorcolumn
set nocursorline

" Note: Limitar o alcance da sintaxe em linhas muito longas! By Questor
set synmaxcol=1000

" Note: Don't redraw while executing macros (good performance config)!
" Causes scroll "flickering"! By Questor
" set lazyredraw

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"GENERAL BEHAVIOR
"$$$$$$$$$$$$$"

" Note: Use vim settings, rather then vi settings (much better!)! This must be 
" first, because it changes other options as a side effect! By Questor
set nocompatible

" Note: Habilita o "pathogen"! By Questor
" Note: Force reloading *after* pathogen loaded! Trying avoid override! By Questor
filetype plugin indent on
execute pathogen#infect()
execute pathogen#helptags()

" Note: Habilita o mouse! By Questor
set mouse=a

" Note: Evita problemas de compatibilidade quando se vai copiar para à aplicação
" externa! By Questor
if has('unnamedplus')
	set clipboard=unnamedplus
else
	set clipboard=unnamed
endif

" Note: Don't create swap files! By Questor
set noswapfile

" Note: Solve read only problem! Some files opens as read only! By Questor
set ma

" Note: Highlight your search matches! By Questor
" set hlsearch
" set nohlsearch

" Note: Permite uma coluna à mais no final da linha! By Questor
set virtualedit=onemore

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"SHORTCUTS (AND REMOVE VIM STUPID BEHAVIOR)
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Swap : and ; to make colon commands easier to type! By Questor
nnoremap  ;  :
nnoremap  :  ;
" Note: Importante para a execução de determinados comandos em algumas
" funcionalidades! By Questor
let g:cmdLineCaller = ";"

nnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"l\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"d\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"u\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"r\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")

" Note: A variável ":let g:onMoveScreen = 1<cr>" é setada em outra
" oportunidade para o visual mode! Questor
vnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"l\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"d\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"u\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"r\", 0, 0)<cr>" : "")

inoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"l\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"d\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"u\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"r\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")

nnoremap <silent> <PageDown> :call GrooVim_GroovyMove("n", "d", 1, 0)<cr>
nnoremap <silent> <PageUp> :call GrooVim_GroovyMove("n", "u", 1, 0)<cr>

vnoremap <silent> <PageDown> :<C-u>call GrooVim_GroovyMove("v", "d", 1, 0)<cr>
vnoremap <silent> <PageUp> :<C-u>call GrooVim_GroovyMove("v", "u", 1, 0)<cr>

inoremap <silent> <PageDown> <C-o>:call GrooVim_GroovyMove("i", "d", 1, 0)<cr>
inoremap <silent> <PageUp> <C-o>:call GrooVim_GroovyMove("i", "u", 1, 0)<cr>

nnoremap <silent> <C-A-Left> :call GrooVim_GroovyMove("n", "l", 0, 1)<cr>
nnoremap <silent> <C-A-Down> :call GrooVim_GroovyMove("n", "d", 0, 1)<cr>
nnoremap <silent> <C-A-Up> :call GrooVim_GroovyMove("n", "u", 0, 1)<cr>
nnoremap <silent> <C-A-Right> :call GrooVim_GroovyMove("n", "r", 0, 1)<cr>

vnoremap <silent> <C-A-Left> :<C-u>call GrooVim_GroovyMove("v", "l", 0, 1)<cr>
vnoremap <silent> <C-A-Down> :<C-u>call GrooVim_GroovyMove("v", "d", 0, 1)<cr>
vnoremap <silent> <C-A-Up> :<C-u>call GrooVim_GroovyMove("v", "u", 0, 1)<cr>
vnoremap <silent> <C-A-Right> :<C-u>call GrooVim_GroovyMove("v", "r", 0, 1)<cr>

inoremap <silent> <C-A-Left> <C-o>:call GrooVim_GroovyMove("i", "l", 0, 1)<cr>
inoremap <silent> <C-A-Down> <C-o>:call GrooVim_GroovyMove("i", "d", 0, 1)<cr>
inoremap <silent> <C-A-Up> <C-o>:call GrooVim_GroovyMove("i", "u", 0, 1)<cr>
inoremap <silent> <C-A-Right> <C-o>:call GrooVim_GroovyMove("i", "r", 1, 1)<cr>

" Note: Permite movimentação fluida da tela! By Questor
let g:onMoveScreen = 0
let g:GrooVim_GroovyMoveType = 0
let g:cursorHoldVisualExec = ""
let g:cursorHoldVisual = 0
let g:GrooVim_GroovyMoveEnabled = 1
func! GrooVim_GroovyMove(mod, direction, blockSmoothness, GrooVim_GroovyMoveType) range

	let g:GrooVim_GroovyMoveEnabled = 0

	if a:blockSmoothness == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0 && a:GrooVim_GroovyMoveType == 0
		call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
	endif

	if &virtualedit == "onemore"
		set virtualedit=all
	endif

	let l:disableSmoothness = 0
	let l:disableHorizontalSmoothness = 0
	let l:horizontalSmoothnessFactor = 2
	let l:verticalSmoothnessFactor = 10

	if a:GrooVim_GroovyMoveType == 0
		let l:horizontalMovementFactor = 20
		let l:verticalMovementFactor = 15
	elseif a:GrooVim_GroovyMoveType == 1
		let l:horizontalMovementFactor = 1
		let l:verticalMovementFactor = 1
	endif

	if a:mod == "n" || a:mod == "i"

		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

	elseif a:mod == "v"

		exec "norm gv"
		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

		" Note: Esse workaround serve para que o visual mode use o evento 
		" "CursorHold" o que só é possível no normal mode! By Questor
		let g:cursorHoldVisualExec = "call GrooVim_GroovyMoveAdjuster(\"" . a:direction . "\", " . a:blockSmoothness . ", " . l:disableSmoothness . ", " . l:verticalSmoothnessFactor . ")"
		let g:cursorHoldVisual = 1
		exec "norm \<Esc>"

	endif

	let g:onMoveScreen = 1

	" Note: "set virtualedit=onemore" se a área já for válida! By Questor
	if virtcol('.') <= virtcol('$')

		if &virtualedit == "all"
			set virtualedit=onemore
		endif

		if a:direction == "r" && a:mod != "v"
			call GrooVim_GroovyMoveAdjuster(a:direction, a:blockSmoothness, l:disableSmoothness, l:verticalSmoothnessFactor)
		endif

	endif

endfunc

func! GrooVim_GroovyMoveAdjuster(direction, blockSmoothness, disableSmoothness, verticalSmoothnessFactor) range

	let l:lineNow = getline(".")
	let l:lineSplited = split(l:lineNow, '\zs')

	if len(l:lineSplited) >= 1 && len(l:lineSplited) > (col(".") - 1)

		if l:lineSplited[col(".") - 1] == "	"

			if a:blockSmoothness == 0 && a:disableSmoothness == 0
				exec "sleep " . a:verticalSmoothnessFactor . "m"
			endif

			let l:cursorPosInsert = getpos(".")
			" ldur
			if a:direction == "l"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			elseif a:direction == "r"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2] + 1, 0])
			elseif a:direction == "d" || a:direction == "u"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			endif

			if a:blockSmoothness == 0
				redraw
			endif

			let g:cursorHoldVisual = 0
			let g:onMoveScreen = 1

		endif

	endif

endfunc

nnoremap <silent> <A-End> :call GrooVim_SelWord("n", "r", 1)<cr>
nnoremap <silent> <A-Home> :call GrooVim_SelWord("n", "l", 1)<cr>
inoremap <silent> <A-End> <C-o>:call GrooVim_SelWord("i", "r", 1)<cr>
inoremap <silent> <A-Home> <C-o>:call GrooVim_SelWord("i", "l", 1)<cr>
nnoremap <silent> <script> <A-Left> :call GrooVim_SelWord("n", "l", 0)<cr>
inoremap <silent> <script> <A-Left> <C-o>:call GrooVim_SelWord("i", "l", 0)<cr>
vnoremap <silent> <script> <A-Left> :<C-u>call GrooVim_SelWord("v", "l", 0)<cr>
nnoremap <silent> <script> <A-Right> :call GrooVim_SelWord("n", "r", 0)<cr>
inoremap <silent> <script> <A-Right> <C-o>:call GrooVim_SelWord("i", "r", 0)<cr>
vnoremap <silent> <script> <A-Right> :<C-u>call GrooVim_SelWord("v", "r", 0)<cr>

" Note: Permite a seleção de palavras de forma rápida (para cópia ou deleção)! By Questor
func! GrooVim_SelWord(mod, direction, fullMove) range

	let l:wordMove = ""
	let l:wordMoveInsert = ""

	if a:direction == "l"
		if a:fullMove == 0
			let l:wordMove = "b"
		elseif a:fullMove == 1
			let l:wordMove = "0"
		endif
		let l:wordMoveInsert = "\<Left>"
	elseif a:direction == "r"
		if a:fullMove == 0
			let l:wordMove = "e"
		elseif a:fullMove == 1
			let l:wordMove = "$\<Left>"
		endif
	endif

	if a:mod == "v"
		exec "norm gv" . l:wordMove
	elseif a:mod == "i"
		if virtcol('.') == (virtcol('$') - 1)
			if a:direction == "r"
				exec "norm \<Esc>\<Down>0v" . l:wordMove
			else
				exec "norm \<Esc>v" . l:wordMove
			endif
		else
			exec "norm \<Esc>" . l:wordMoveInsert . "v" . l:wordMove
		endif
	elseif a:mod == "n"
		exec "norm v" . l:wordMove
	endif

endfunc

" Note: Permite ir ao final de fato da linha no normal modesendo um desdobramento
" de "set virtualedit=onemore"! By Questor
nnoremap <silent> <End> $<Right>

nnoremap <silent> <A-DOWN> :call GrooVim_TabToReturn()<cr>
inoremap <silent> <A-DOWN> <C-O>:call GrooVim_TabToReturn()<cr>
vnoremap <silent> <A-DOWN> :<C-U>call GrooVim_TabToReturn()<cr>v

" Note: Retornar para última tab em uso! By Questor
let g:lastTab = 1
autocmd! TabLeave * let g:lastTab = tabpagenr()

func! GrooVim_TabToReturn()
	if g:GrooVim_TabToReturnNumber == 0
		exe "tabn " . g:lastTab
	else
		if g:GrooVim_TabToReturnNumber == tabpagenr()
			exe "tabn " . g:lastTab
		else
			exe "tabn " . g:GrooVim_TabToReturnNumber
			" Note: "redraw" garante a exibição da mensagem! By Questor
			redraw
			echo "Tab to return is ENabled to this tab!"
		endif
	endif
endfunc

" Note: Permite retornar para um determinada tab sempre! By Questor
let g:GrooVim_TabToReturnNumber = 0
func! GrooVim_TabToReturnSet()
	if g:GrooVim_TabToReturnNumber == 0
		let g:GrooVim_TabToReturnNumber = tabpagenr()
		call GrooVim_GrooVimBarMsg("Tab to return was ENabled to this tab!", 4)
	else
		let g:GrooVim_TabToReturnNumber = 0
		call GrooVim_GrooVimBarMsg("Tab to return was DISabled!", 4)
	endif
endfunc

if g:enable_tcomment_vim == 1 && g:enable_all_plugins == 1
	nnoremap <silent> <A-Up> :exec "norm gcc"<cr>
	inoremap <silent> <A-Up> <C-o>:exec "norm gcc"<cr>
	vnoremap <silent> <A-Up> :<C-u>call GrooVim_VisualComment()<cr>
	" Note: Permite comentar a linha de forma simples e rápida! By Questor
	func! GrooVim_VisualComment() range
		" Note: Permite verificar se a seleção envolve mais de uma linha
		" comparando a linha "do começo" e "do final" da seleção! By Questor
		if   getpos("'<")[1] == getpos("'>")[1]
			exec "norm gcc"
		else
			exec "norm gv"
			exec "norm gc"
		endif
	endfunc
endif

let g:messagesHolder = ""
func! GrooVim_GetMessages()
	let g:messagesHolder = ""
	redir => g:messagesHolder
		silent exec "messages"
	redir end
endfunc

func! GrooVim_ReturnLastMessage()
	call GrooVim_GetMessages()
	let l:messagesHolderSplitted = split(g:messagesHolder, "\n")
	if len(l:messagesHolderSplitted) >= 1
		return [l:messagesHolderSplitted[len(l:messagesHolderSplitted) - 1], len(l:messagesHolderSplitted)]
	else
		return ["", 0]
	endif
endfunc

let g:lastMessageWorkaroundShowed = ""
let g:lastMessageWorkaroundShowedIndex = 0
func! GrooVim_ShowLastMessageWorkaround()

	let l:GrooVim_ReturnLastMessageReturn = GrooVim_ReturnLastMessage()

	if l:GrooVim_ReturnLastMessageReturn[0] != ""
		if l:GrooVim_ReturnLastMessageReturn[0] != g:lastMessageWorkaroundShowed || g:lastMessageWorkaroundShowed == "" || g:lastMessageWorkaroundShowedIndex < l:GrooVim_ReturnLastMessageReturn[1]

			let l:messageBlock = 1
			if l:GrooVim_ReturnLastMessageReturn[0] == "Messages maintainer: Bram Moolenaar <Bram@vim.org>"
			elseif l:GrooVim_ReturnLastMessageReturn[0] =~ "replace with" && l:GrooVim_ReturnLastMessageReturn[0] =~ "(y/n/a/q/l/"
			else
				let l:messageBlock = 0
			endif

			if l:messageBlock == 0

				let l:messageType = "n"
				try

					let l:messageNowToSplit = l:GrooVim_ReturnLastMessageReturn[0]
					let l:messageNowSplitted = split(l:messageNowToSplit[0:6], ": ")

					if len(l:messageNowSplitted) > 0

						let l:messageNowTreated = substitute(l:messageNowSplitted[0], "E", "", "")

						if l:messageNowTreated != 0
							" Note: As aspas servem para fazer com que o resultado de "str2nr" seja "transformado" em string! By Questor
							if l:messageNowTreated == "" . str2nr(l:messageNowTreated) . ""
								if type(str2nr(l:messageNowTreated)) == type(0)
									if l:messageNowTreated > 0 && l:messageNowTreated < 10000
										let l:messageType = "e"
									endif
								endif
							endif
						endif

						
					endif

				catch
					
				endtry

				if l:messageType == "e"
					echohl Error | echo l:GrooVim_ReturnLastMessageReturn[0] | echohl None
				elseif l:messageType == "n"
					echo l:GrooVim_ReturnLastMessageReturn[0]
				endif
			endif

		endif
	endif

	let g:lastMessageWorkaroundShowed = l:GrooVim_ReturnLastMessageReturn[0]
	let g:lastMessageWorkaroundShowedIndex = l:GrooVim_ReturnLastMessageReturn[1]

endfunc

" Note: Check if caps lock is on! By Questor
let g:GrooVim_CheckCapsLockReturn = 0
let g:GrooVim_CheckCapsLockLastExec = 0
let g:GrooVim_CheckCapsLockMsg = 0
func! GrooVim_CheckCapsLock() range

	" Note: Evitar o retorno de caracteres malucos quando na
	" execução desse comando! By Questor

	if (strftime("%Y%m%d%H%M%S") - g:GrooVim_CheckCapsLockLastExec) > 1 || g:GrooVim_CheckCapsLockLastExec == ""

		let l:result = system("xset -q | grep \"Caps Lock:   on\"")

		" Note: In terminal vim, prevent ghost echoing while running a shell command via system()! By Questor
		redraw!

		" Note: Reexibe a última menssagem para corrigir o efeito
		" "colateral" da execução de "redraw!"! By Questor
		call GrooVim_ShowLastMessageWorkaround()


		if l:result != ""
			" Note: To debug! By Questor
			if g:GrooVim_CheckCapsLockReturn == 0
				" Note: This warning have a special condition and only
				" disappears if capslock is off! When caps lock is on
				" any other message will be shown! By Questor
				call GrooVim_GrooVimBarMsg("((( CAPS LOCK IS ON, OH NO!!! =| )))", 0)
				let g:GrooVim_CheckCapsLockMsg = 1
			endif
			let g:GrooVim_CheckCapsLockReturn = 1
		else
			let g:GrooVim_CheckCapsLockReturn = 0
		endif
	endif

	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

endfunc

" Note: A exclamação em "autocmd!" evita redefinição do evento ao recarregar o
" .vimrc! By Questor

" Note: Garante o estado de "virtualedit" antes de qualquer edição! By Questor
autocmd! InsertEnter * call GrooVim_InsertEnterPerforms()
func! GrooVim_InsertEnterPerforms()
	if g:onMoveScreen == 0
		if &virtualedit == "all"
			set virtualedit=onemore
		endif
	endif
endfunc

" Note: Reposiciona o cursor no local correto ao sair do insert mode! By Questor
autocmd! InsertLeave * call GrooVim_InsertLeavePerforms()
func! GrooVim_InsertLeavePerforms()
	exec "norm `^"
endfunc

" Note: Garante o estado de "virtualedit" antes de qualquer edição! By Questor
autocmd! InsertCharPre * call GrooVim_InsertCharPrePerforms()
func! GrooVim_InsertCharPrePerforms()
	if &virtualedit == "all"
		set virtualedit=onemore
	endif
endfunc

" Note: Check caps lock status! By Questor
autocmd! CursorHold * call GrooVim_CheckCapsLockTimer()
autocmd! CursorHoldI * call GrooVim_CheckCapsLockTimer()
let g:reloadVimrc = 0
func! GrooVim_CheckCapsLockTimer()
	if g:onCursorMoved == 0 && g:onMoveScreen == 0

		call GrooVim_CheckCapsLock()
		if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:onMoveScreen == 0
			if (strftime("%Y%m%d%H%M%S") - g:GrooVim_GrooVimBarMsgMoment) > g:GrooVim_GrooVimBarMsgDuration
				call GrooVim_GrooVimBarMsg("", "")
			endif
		endif

	else
		let g:onMoveScreen = 0
		let g:GrooVim_GroovyMoveEnabled = 1
	endif

	" Note: Esse workaround serve para que o visual mode use o evento "CursorHold"! By Questor
	if g:cursorHoldVisual == 1
		exec "norm gv"
		if g:cursorHoldVisualExec != ""
			exec g:cursorHoldVisualExec
			let g:cursorHoldVisualExec = ""
		endif
		let g:cursorHoldVisual = 0
		let g:onMoveScreen = 1
	endif

	checktime
endfunc
" Note: Execution delay (in milliseconds)! By Questor
set updatetime=0

" Note: Esses eventos servem para permitir a movimentação da tela de forma simples e intuitiva! By Questor
autocmd! CursorMoved * call GrooVim_VimStatus()
autocmd! CursorMovedI * call GrooVim_VimStatus()
let g:lastMode = ""
let g:onCursorMoved = 0
let g:modeNow = ""
func! GrooVim_VimStatus()

	let g:onCursorMoved = 1
	if g:onMoveScreen == 0

" 		Note: Verifica o status do caps lock sempre que o vim muda de 
" 		modo ou se estiver no modo visual! By Questor

		let g:modeNow = mode()

		if g:modeNow != g:lastMode || g:modeNow == "v"
			" Note: Evita termos que acionar duas vêzes o
			" "GrooVim_GroovyMove" quando mudamos de modo! By Questor
			let g:GrooVim_GroovyMoveEnabled = 1
			call GrooVim_CheckCapsLock()
			if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:GrooVim_CheckCapsLockMsg == 1
				call GrooVim_GrooVimBarMsg("", "")
				let g:GrooVim_CheckCapsLockMsg = 0
			endif
		endif

		" Note: When on visual-block mode allows select any area! By Questor
		if mode() != "\<C-v>"
			if &virtualedit == "all"
				set virtualedit=onemore
			endif
		endif

		let g:lastMode = g:modeNow

	endif
	let g:onCursorMoved = 0
endfunc

" Note: Serve para evitar o efeito colateral da verificação de acionamento Caps Lock! By Questor

nnoremap <silent> <ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <S-ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>
nnoremap <silent> <S-ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>

inoremap <silent> <ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <S-ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>
inoremap <silent> <S-ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>

vnoremap <silent> <ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <S-ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>
vnoremap <silent> <S-ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>

func! GrooVim_ScrollAdm(mod, direction) range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

	if a:mod == "v"
		exec "norm gv"
	endif

	if a:direction == "u"
		exec "norm \<Up>\<Up>\<Up>"
	elseif a:direction == "d"
		exec "norm \<Down>\<Down>\<Down>"
	endif

	let g:onMoveScreen = 1
endfunc

" Note: Serve para evitar o efeito colateral da verificação de acionamento Caps Lock! By Questor
nnoremap <silent> <LeftMouse> :let g:onMoveScreen = 1<cr><LeftMouse>

nnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
inoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
vnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>

" Note: Enter visual-block mode and allows select any area! By Questor
func! GrooVim_SetVisualBlock() range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
endfunc

" Note: Evita "acidentes" com a combinação "Ctrl+z"! "<Nop>" equivale a um
" comando "nulo"! By Questor
nnoremap <silent> <C-z> <Nop>
inoremap <silent> <C-z> <Nop>
vnoremap <silent> <C-z> <Nop>

" Note: Permite "undo"/"redo" no insert/normal mode de forma homogênea! By Questor
nnoremap <silent> <C-u> u

" Note: Permite undo de forma convencional no visual! By Questor
vnoremap <silent> <C-u> :<C-u>call GrooVim_VisualUndo()<cr>v
func! GrooVim_VisualUndo() range
	exec "norm u"
endfunc

" Note: Permite redo de forma convencional no visual! By Questor
vnoremap <silent> <C-r> :<C-u>call GrooVim_VisualRedo()<cr>v
func! GrooVim_VisualRedo() range
	exec "norm \<C-r>"
endfunc

" Note: Permite undo de forma convencional no insert! By Questor
inoremap <silent> <script> <C-u> <Esc><bar>:call GrooVim_InsertUndo()<cr>i
func! GrooVim_InsertUndo()
	exec "norm u"
endfunc

" Note: Permite redo de forma convencional no insert! By Questor
inoremap <silent> <script> <C-r> <Esc><bar>:call GrooVim_InsertRedo()<cr>i
func! GrooVim_InsertRedo()
	exec "norm \<C-r>"
endfunc

" Note: Space no modo normal! By Questor
noremap <silent> <script> <Space> :call GrooVim_SpaceOnNormalMode()<cr>

func! GrooVim_SpaceOnNormalMode()
	exec "norm i\<Space>"
endfunc

" Note: Movimentação mais ágil entre as janelas com Ctrl+w! By Questor
nnoremap <silent> <C-w> <C-w><C-w>
inoremap <silent> <C-w> <Esc><C-w><C-w>
vnoremap <silent> <C-w> <Esc><C-w><C-w>

" Note: Obtém o número de linhas da área de transferência atual! Questor
func! GrooVim_NumberOfLinesOnDefaultTransferArea()

	" Note: Get transfer area! By Questor
	let l:lastYank = @+
	let l:lastYankNumbOfLines = split(l:lastYank, "\n")
	" Note: Verifica quantas linhas tem! Questor
	return len(l:lastYankNumbOfLines)

endfunc

" Note: Permite o yank de uma linha sem o retorno de caracter! By Questor
nnoremap <silent> yy 0y$

nnoremap <silent> <script> p P`]<Right>
nnoremap <silent> <script> <C-v> P`]<Right>

" Note: Permite paste normal no insert mode (sem quebras de linha e sem
" precisar do "Shift") (Ctrl+v)! By Questor
inoremap <silent> <script> <C-v> <C-o>P<C-o>`]<Right>

" Note: Permite copiar para o insert mode de modo convencional (ciclo
" Ctrl-c/Ctrl-v) (não precisa do "Shift")! By Questor
vnoremap <silent> <C-x> di

" Note: Permite cortar para o insert mode de modo convencional (ciclo
" Ctrl-x/Ctrl-v) (não precisa do "Shift")! By Questor
vnoremap <silent> <C-c> yi

" Note: Delete and backspace without yank! By Questor
nnoremap d "_d
nnoremap x "_x
vnoremap x "_x

" Note: Paste without yank (visual mode)! By Questor
vnoremap <silent> <script> p "_dP`]<Right>
vnoremap <silent> <script> <C-v> "_dP`]<Right>

" Note: Movimentação "normal" com Ctrl+Right! By Questor
nmap <silent> <C-Right> e
imap <silent> <C-Right> <C-o>e<Right>
vmap <silent> <C-Right> e

" Note: Movimentação "normal" com Ctrl+Left! By Questor
nmap <silent> <C-Left> b
imap <silent> <C-Left> <C-o>b
vmap <silent> <C-Left> b

" Note: O parâmetro <script> impede que o mapeamento seja sobreescrito por algum plugin! By Questor

" Note: Permite que uso "multimodo" do enter (em qualquer tipo de arquivo)! By Questor
nnoremap <silent> <script> <Enter> :call GrooVim_NormalEnterOnNormalMode()<cr>
func! GrooVim_NormalEnterOnNormalMode()
	exec "norm i\<cr>\<Esc>"
endfunc

" Note: Normal backspace/delete para o visual mode! By Questor
vmap <silent> <script> <Backspace> "_x
vmap <silent> <script> <Del> "_d

" Note: Permite uso "multimodo" do backspace! By Questor
nmap <silent> <script> <Backspace> :call GrooVim_NormalBackspace()<cr>

func! GrooVim_NormalBackspace()

	let l:continue = 1

	if col(".") == 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\i")
		call feedkeys("\<Backspace>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if col(".") > 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\<Left>")
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note:  Move to the next tab! By Questor
nnoremap <silent> <C-Up> :tabnext<cr>
inoremap <silent> <C-Up> <C-O>:tabnext<cr>
vnoremap <silent> <C-Up> :<C-U>tabnext<cr>v

" Note:  Move to the previous tab! By Questor
nnoremap <silent> <C-Down> :tabprevious<cr>
inoremap <silent> <C-Down> <C-O>:tabprevious<cr>
vnoremap <silent> <C-Down> :<C-U>tabprevious<cr>v

" Note: Permite que uso "multimodo" do del! By Questor
func! GrooVim_NormalDel()

	let l:continue = 1

	" Note: Esse workaround é necessário quando a linha é vazia para que seja eliminada! By Questor
	if getline(".") == "" && l:continue == 1
		call feedkeys("_dd")
		" call feedkeys("0")
		let l:continue = 0
	endif

	if col(".") == col("$") && l:continue == 1
		call feedkeys("\i")
		call feedkeys("\<Right>")
		call feedkeys("\<Del>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if l:continue == 1
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note: "Multimode" tab! By Questor
nnoremap <silent> <Tab> :call GrooVim_NormalTab()<cr>
" Note: Permite tab no normal mode quando a linha está vazia! B Questor
func! GrooVim_NormalTab()
	if col(".") == 1 && getline(".") == ""
		exec "normal i\<Tab>"
	else
		exec "normal >>"
		if len(split(getline("."), '\zs')) == col(".")
			exec "normal \<Right>"
		endif
	endif
endfunc

inoremap <silent> <S-Tab> <C-o><<
nnoremap <silent> <S-Tab> <<
vnoremap <silent> <Tab> >><Esc>gv
vnoremap <silent> <S-Tab> <<<Esc>gv

" Note: Quando sai do modo insert para o modo visual! By Questor
inoremap <silent> <S-Down> <Esc>v:<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: Sair do modo visual! Questor
vnoremap <silent> <S-Down> <Esc>:call GrooVim_VirtualEditAdjust()<cr>

" Note: Permite sair dos modos usando um segundo "<C-S-Up>" ou "<C-S-Down>"! By Questor
inoremap <silent> <S-Up> <Esc>:call GrooVim_VirtualEditAdjust()<cr>
nnoremap <silent> <S-Down> :call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: O "case sensitive" do "<Esc>" tem influência aqui como tem para
" o "<Enter>"! By Questor
" Note: Permite ajustar o parâmetro "set virtualedit=onemore" ao sair do modo em
" que se está! By Questor
func! GrooVim_VirtualEditAdjust() range
	set virtualedit=onemore
endfunc

" Note: Entrar no insert mode de forma simples! By Questor
vnoremap <silent> <script> <S-Up> <Esc>i
nnoremap <silent> <script> <S-Up> i

" Note: Serve para que ao entrar no modo visual o vim ajuste o parâmetro
" "set virtualedit=onemore"! By Questor
nnoremap <silent> <script> v :<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v
func! GrooVim_AdjustOnEnterVisualMode() range
	set virtualedit=onemore
endfunc

" Note: Like tabdo but restore the current tab! By Questor
let g:tryCathOnTabDo = 0
func! TabDo(command)
	let currTab=tabpagenr()
	if g:tryCathOnTabDo == 0
		exec "tabdo " . a:command
	elseif g:tryCathOnTabDo == 1
		try
			exec "tabdo " . a:command
		catch
		endtry
	endif
	exec "tabn " . currTab
endfunc
com! -nargs=+ -complete=command Tabdo call TabDo(<q-args>)

" Note: Select and search with a double click and z key otherwise select the
" word under cursor! By Questor
nnoremap <silent> <script> <2-Leftmouse> :call GrooVim_SelectNSearch(0, "n")<cr>
inoremap <silent> <script> <2-Leftmouse> <Esc>:call GrooVim_SelectNSearch(0, "i")<cr>
vnoremap <silent> <script> <2-Leftmouse> :<C-u>call GrooVim_SelectNSearch(0, "v")<cr>

func! GrooVim_SelectNSearch(type, mode) range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Set "hlsearch" if is off! By Questor
		if !&hlsearch
			" Note: Highlight search results! By Questor
			set hlsearch
		endif

		set noignorecase
		let l:initialPos = getpos(".")
		if a:type == 0
			exec "sleep 250m"
			let l:enableSearch = getchar(0)
			if l:enableSearch == "122"
				let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
				call feedkeys("/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			else
				call feedkeys("viw")
			endif
		elseif a:type == 1
			let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
			call feedkeys("\<Esc>/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			if a:mode == "i"
				call feedkeys("\<Esc>i")
			else
				" Note: Esse workaround serve para evitar que o cursor mova para a próxima ocorrência quando teclamos <Up> or <Down>! By Questor
				call feedkeys("\<Esc>i\<Esc>")
			endif
		endif

	endif
endfunc

" Note: Select a range based on first and last positions! By Questor
let g:lastCursorPos = [0,0]
let g:GrooVim_SelectRangeInitialize = 1
func! GrooVim_SelectRange(mod) range

	let l:selDirection = "nothing"
	if g:GrooVim_SelectRangeInitialize == 0 && a:mod == "i"
		let l:cursorPosInsert = getpos(".")
		if g:lastCursorPos[1] < l:cursorPosInsert[1]
			let l:selDirection = "lessMoreLine"
		elseif g:lastCursorPos[1] > l:cursorPosInsert[1]
			let l:selDirection = "moreLessLine"
		elseif g:lastCursorPos[1] == l:cursorPosInsert[1]
			if g:lastCursorPos[2] < l:cursorPosInsert[2]
				let l:selDirection = "lessMoreCol"
			elseif g:lastCursorPos[2] > l:cursorPosInsert[2]
				let l:selDirection = "moreLessCol"
			endif
		endif
	endif

	if g:GrooVim_SelectRangeInitialize == 1
		let g:lastCursorPos = getpos(".")
		let g:GrooVim_SelectRangeInitialize = 0
		echomsg "Beginning of the range selected!"
	elseif g:GrooVim_SelectRangeInitialize == 0
		let l:cursorPos = getpos(".")
		call setpos('.', g:lastCursorPos)
		if (l:selDirection == "moreLessLine" || l:selDirection == "moreLessCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		exec "norm v"
		call setpos('.', l:cursorPos)
		if (l:selDirection == "lessMoreLine" || l:selDirection == "lessMoreCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		let g:GrooVim_SelectRangeInitialize = 1
		echomsg "Range selected!"
	endif

endfunc

" Note: Atualiza uma opção se ela já existir ou a insere se não. Também cria o
" arquivo de configuração se ele não existir! By Questor
let g:optsTemp = []
func! GrooVim_OptsUpdate(valueToSearch, valueToReplace, persistently)

	let l:CoolAndVimOptsArrayUpdated = []

	let l:thisOptionDoesNotExistInTheConfiguration = 1

	if a:persistently == 0

		" Note: To update temporary options in all new tabs when necessary! By Questor
		for l:value in g:optsTemp
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		let g:optsTemp = l:CoolAndVimOptsArrayUpdated

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(g:optsTemp, a:valueToReplace)
		endif

		exec a:valueToReplace

	else

		if filereadable(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
			let l:CoolAndVimOptsArrayOriginal = readfile(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
		endif

		let l:CoolAndVimOptsArrayUpdated = []
		for l:value in l:CoolAndVimOptsArrayOriginal
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
				exec a:valueToSearch . a:valueToReplace
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(l:CoolAndVimOptsArrayUpdated, l:value)
		endif

		call writefile(l:CoolAndVimOptsArrayUpdated, expand('~/.vim/plugin/CoolAndVimOpts.vim'))

	endif

endfunc

" Note: Configura a pesquisa e/ou o replace a depender dos parâmetros passados! By Questor
func! GrooVim_ConfigureSearchReplace(typeOfConfig) range

	let l:whileControl = 1

	if a:typeOfConfig == "search"
		echomsg "Configure Search (use empty for default or option now):"
	elseif a:typeOfConfig != "search"
		echomsg "Configure Search and Replace (use empty for default or option now):"
	endif

	let g:searchReplace_CaseSensitive = GrooVim_GetOptions("Case sensitive (replaced/search) [0[default]/1][now: \"" . g:searchReplace_CaseSensitive . "\" ]? ", [1,0], g:searchReplace_CaseSensitive)
	call GrooVim_OptsUpdate("let g:searchReplace_CaseSensitive =", "let g:searchReplace_CaseSensitive = " . g:searchReplace_CaseSensitive, 0)
	if g:searchReplace_CaseSensitive == 1
		echomsg " -> Case sensitive is enabled!"
		call GrooVim_OptsUpdate("set ignorecase", "set noignorecase", 0)
	else
		echomsg " -> Case sensitive is disabled!"
		call GrooVim_OptsUpdate("set noignorecase", "set ignorecase", 0)
	endif

	let g:searchReplace_InAllOpened = GrooVim_GetOptions("In all tabs (replace/search) [0[default]/1][now: \"" . g:searchReplace_InAllOpened . "\" ]? ", [1,0], g:searchReplace_InAllOpened)
	call GrooVim_OptsUpdate("let g:searchReplace_InAllOpened =", "let g:searchReplace_InAllOpened = " . g:searchReplace_InAllOpened, 0)
	if g:searchReplace_InAllOpened == 1
		echomsg " -> Replace/search in all tabs is enabled!"
	else
		echomsg " -> Replace/search in all tabs is disabled!"
	endif

	if a:typeOfConfig != "search"
		let g:configureGrooVim_EntertainmentReplace_Confirmation = GrooVim_GetOptions("Replace with confirmation [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_Confirmation . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_Confirmation)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_Confirmation =", "let g:configureGrooVim_EntertainmentReplace_Confirmation = " . g:configureGrooVim_EntertainmentReplace_Confirmation, 0)
		if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
			echomsg " -> Confirmation is enabled!"
		else
			echomsg " -> Confirmation is disabled!"
		endif
		let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = GrooVim_GetOptions("Ask the value to be replaced [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced =", "let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = " . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced, 0)
		if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
			echomsg " -> The value to be replaced will be asked!"
		else
			echomsg " -> The value to be replaced will NOT be asked!"
		endif
		let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = GrooVim_GetOptions("Replace begin from current position [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_FromCurrentPosition)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition =", "let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = " . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition, 0)
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			echomsg " -> Replace begin from current position is enabled!"
		else
			echomsg " -> Replace begin from current position is disabled!"
		endif
	elseif a:typeOfConfig == "search"
		let g:search_Direction = GrooVim_GetOptions("Search forward/backyard [f[default]/b][now: \"" . g:search_Direction . "\" ]? ", ["f","b"], g:search_Direction)
		call GrooVim_OptsUpdate("let g:search_Direction =", "let g:search_Direction = \"" . g:search_Direction . "\"", 0)
		" Note: Necessário para inverter o sentido da busca! By Questor
		if g:search_Direction == "b"
			let g:grooVimSearchFoward = 0
		elseif g:search_Direction == "f"
			let g:grooVimSearchFoward = 1
		endif
		if g:search_Direction == "f"
			echomsg " -> Search forward is enabled!"
		else
			echomsg " -> Search backyard is enabled!"
		endif
		let g:search_WithList = GrooVim_GetOptions("Search with list [0[default]/1][now: \"" . g:search_WithList . "\" ]? ", [1,0], g:search_WithList)
		call GrooVim_OptsUpdate("let g:search_WithList =", "let g:search_WithList = \"" . g:search_WithList . "\"", 0)
		if g:search_WithList == 1
			echomsg " -> Search with list is enabled!"
		else
			echomsg " -> Search with list is disabled!"
		endif
	endif

endfunc

" Note: Get and validate a givem option! By Questor
func! GrooVim_GetOptions(optionToGet, possibleOptions, defaultOption) range
	let l:stopWhile = 0
	let l:optionReturn = ""
	while l:stopWhile == 0
		let l:optionReturn = input(a:optionToGet)
		let l:stopWhile = GrooVim_ValidateOptions(l:optionReturn, a:possibleOptions, a:defaultOption)
		if ("" . l:optionReturn . "") == ""
			let l:optionReturn = a:defaultOption
		endif
	endwhile
	return l:optionReturn
endfunc

" Note: Check if a given option is valid! By Questor
func! GrooVim_ValidateOptions(optionNow, possibleOptions, defaultOption) range
	for l:value in a:possibleOptions
		" Note: "("" . l:value . "")" -> To force string compare! By
		" Questor
		if ("" . l:value . "") == a:optionNow || (a:optionNow == "" && ("" . a:defaultOption . "") != "")
			return 1
		endif
	endfor
	return 0
endfunc

" Note: Highlight matches when jumping to next! This rewires n and N to do
" the highlighing the match in red! By Questor
nnoremap <silent> <expr> n ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'n' : 'N') : (g:grooVimSearchFoward ? 'N' : 'n')) . ":call GrooVim_HLNext(\"f\", 0.4, \"1\", 1)<cr>"
nnoremap <silent> <expr> N ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'N' : 'n') : (g:grooVimSearchFoward ? 'n' : 'N')) . ":call GrooVim_HLNext(\"b\", 0.4, \"0\", 1)<cr>"

let g:tabChanged = 0
let g:block_GrooVim_HLNext = 0
highlight WhiteOnRed ctermbg=red ctermfg=white
highlight WhiteOnBlue ctermbg=blue ctermfg=white
func! GrooVim_HLNext(moveType, blinkTime, searchMoveInverter, moment)

	let g:GrooVim_XenPlayRunningWithSearch = 1

	if g:block_GrooVim_HLNext == 0

		if a:moment == 0

			let g:cursor_pos_last = getpos(".")

		elseif a:moment == 1

			" * System (v:searchforward) is forward!
			if v:searchforward == 1
				" n -> forward
				" N -> backward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			" * System (v:searchforward) is backward!
			elseif v:searchforward == 0
				" n -> backward
				" N -> forward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			endif

			let [bufnum, lnum, col, off] = getpos('.')
			let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
			let target_pat = '\c\%#'.@/

			" Note: Foward -> blink: red/Backyard -> blink: blue! By Questor
			if l:searchMoveDirection == 1
				let ring = matchadd('WhiteOnRed', target_pat, 101)
			elseif l:searchMoveDirection == 0
				let ring = matchadd('WhiteOnBlue', target_pat, 101)
			endif

			redraw
			exec 'sleep ' . float2nr(a:blinkTime * 200) . 'm'
			call matchdelete(ring)
			redraw

			let l:cursor_pos_now = getpos(".")

			let l:tabChanged = 0

			if g:searchReplace_InAllOpened == 1
				if l:searchMoveDirection == 1 && l:cursor_pos_now[1] < g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabnext
				elseif l:searchMoveDirection == 0 && l:cursor_pos_now[1] > g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabprev
				elseif l:cursor_pos_now[1] == g:cursor_pos_last[1] && l:cursor_pos_now[2] == g:cursor_pos_last[2]
					if l:searchMoveDirection == 1
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabnext
					elseif l:searchMoveDirection == 0
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabprev
					endif
				endif
			endif

			while g:tabChanged == 1

				" Note: Positioning in the correct window! By Questor

				call GrooVim_PutOnEditWindow()

				try
					if l:searchMoveDirection == 1
						exec "norm gg0n"
					elseif l:searchMoveDirection == 0
						exec "norm G$N"
					endif
					let g:block_GrooVim_HLNext = 0
					let g:tabChanged = 0
				catch
					if l:searchMoveDirection == 1
						tabnext
					elseif l:searchMoveDirection == 0
						tabprev
					endif
				endtry
			endwhile

		endif

	endif

endfunc


" Note: Define o tipo de pesquisa a ser executada a depender das opções do
" usuário! By Questor
let g:search_WithList = 0
func! GrooVim_SearchWithMyOptions(mod) range

	let l:callGrooVim_SearchGuy = 1

	" Note: Se a pesquisa com listas estiver ativada fecha as listas e permite
	" a execução da pesquisa apenas na próxima chamada! By Questor
	if g:GrooVim_SearchGuyEnabled == 1

		let g:matchedLinesGlobal = ""
		let g:matchedLinesGlobalNavArray = []
		let g:GrooVim_SearchGuyEnabled = 0
		let l:callGrooVim_SearchGuy = 0
		call TabDo("call GrooVim_SearchGuyPrepare()")

	endif

	if l:callGrooVim_SearchGuy == 1
		if g:search_WithList == 1
			call GrooVim_SearchGuy(a:mod)
		elseif g:search_WithList == 0
			call GrooVim_EasySearch(a:mod)
		endif
	endif

endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:search_Direction = "f"
let g:searchReplace_CaseSensitive = 0
let g:grooVimSearchFoward = 1
func! GrooVim_EasySearch(mod) range

	" Note: Set "hlsearch" if is off! By Questor
	if !&hlsearch
		" Note: Highlight search results! By Questor
		set hlsearch
	endif

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	" Note: Inicializar a pesquisa! By Questor
	let g:block_GrooVim_HLNext = 0

	let l:valueToSearch = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToSearch = @+
	else
		let l:valueToSearch = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	let l:valueToSearchTemp = ""

	let l:valueToSearchTemp = input("You want to use this value (use empty to yes)? \"" . GrooVim_SubstringToPrompt(l:valueToSearch) . "\": ")

	" Note: Define search pathern automatically! By Questor
	if l:valueToSearchTemp != ""
		let l:valueToSearch = l:valueToSearchTemp
	endif

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToSearch)
	let l:search_Operator = ""

	" Note: Select operation type! By Questor
	if g:search_Direction == "b" && g:grooVimSearchFowardBlock == 0
		let l:search_Operator = "?"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f" || g:grooVimSearchFowardBlock == 1
		let l:search_Operator = "/"
		let g:grooVimSearchFoward = 1
	endif

	" Note: Essa estrutura foi feita para que a pesquisa possa ser
	" executada "de imediato". Com o "feedkeys" acima isso não acontece,
	" ocasionando problemas de sincronia com funções que dependem que
	" função "GrooVim_EasySearch" rode primeiro! By Questor
	" Note: Funciona, mas não me permite "backward search" default! By Questor

	let @/ = l:pattern
	let l:initialPos = getpos(".")

	" Note: Essa operação está duplicada "feedkeys" e "exec" ocasionando
	" uma dupla execução da pesquisa, mas foi única forma de não ter
	" problemas na navegação com "n" e "N" e com a pesquisa com lista!
	" Se não for feito isso, o highlight é perdido após alguns movimentos
	" da seta! By Questor
	if g:search_WithList == 0
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
	else
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>")
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"d\"!", 4)

endfunc

" Note: Organiza as listas de ocorrência e navegação! By Questor
let g:matchedLines = ""
func! GrooVim_SearchGuyMatches(linePosition, lineValue, tab, bufferName, line, column) range
	if a:linePosition != ""
		let l:linePositionPrefix = "|" . a:linePosition . "|        "
		let g:matchedLines =  g:matchedLines . strpart(l:linePositionPrefix, 0, 8) . a:lineValue . "\n"
	else
		let g:matchedLines =  g:matchedLines . a:lineValue . "\n"
	endif
	if a:tab != "" && a:line != "" && a:column != ""
		call add(g:matchedLinesGlobalNavArray, a:tab . "," . a:bufferName . "," . a:line . "," . a:column)
	else
		call add(g:matchedLinesGlobalNavArray, "0")
	endif
endfunc

" Note: Executa a busca nas várias tabs criando as listas de ocorrências! By Questor
func! GrooVim_SearchGuyTraveler(mod) range

	let l:theresAMatch = 1

	try
		exec "norm gg0n"
	catch
		let l:theresAMatch = 0
	endtry

	if l:theresAMatch == 1

		let g:matchedLines = ""
		" let l:theresAMatch = 0
		let l:cur_pos_last = [0,0,0]

		if g:matchedLinesGlobal == ""
			call GrooVim_SearchGuyMatches("", "-------------------------------------------[ Search List ]-------------------------------------------", "", "", "", "")
		else
			call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------------------------------------", "", "", "", "")
		endif

		call GrooVim_SearchGuyMatches("", expand('%:p'), "", "", "", "")
		call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------", "", "", "", "")

		while (getpos(".")[1] > l:cur_pos_last[1] || (getpos(".")[1] == l:cur_pos_last[1] && getpos(".")[2] > l:cur_pos_last[2])) && l:theresAMatch == 1
			let l:cur_pos_last = getpos(".")
			call GrooVim_SearchGuyMatches(getpos(".")[1], getline("."), tabpagenr(), expand('%:t'), getpos(".")[1], getpos(".")[2])
			exec "norm n"
		endwhile

		let g:matchedLinesGlobal = g:matchedLinesGlobal . g:matchedLines

	endif

endfunc

" Note: Searches for current selection or word under cursor. Esse é o método
" principal de controle da funcionalidade! By Questor
let g:matchedLinesGlobal = ""
let g:matchedLinesGlobalNavArray = []
let g:GrooVim_SearchGuyEnabled = 0
let g:grooVimSearchFowardBlock = 0
func! GrooVim_SearchGuy(mod) range

	" Note: Avoid search backward! By Questor
	let g:grooVimSearchFowardBlock = 1

	let l:searchMoveInverterHolder = getpos(".")

	let l:initialPos = getpos(".")

	call GrooVim_EasySearch(a:mod)

	let g:matchedLinesGlobal = ""
	let g:block_GrooVim_HLNext = 1
	let g:matchedLinesGlobalNavArray = []
	let g:GrooVim_SearchGuyEnabled = 0

	if g:searchReplace_InAllOpened == 1
		call TabDo("call GrooVim_SearchGuyTraveler(\"" . a:mod . "\")")
	else
		call GrooVim_SearchGuyTraveler(a:mod)
	endif

	let g:block_GrooVim_HLNext = 0
	let g:GrooVim_SearchGuyEnabled = 1

	call setpos(".", l:initialPos)

	call GrooVim_SearchGuySync()

	" Note: Esse "workaround" serve para evitar um efeito
	" colateral que ocorre na mudança de tab que é a perda do
	" hilight. A presença de redraw serve para apagar a exibição
	" da mensagem gerada por "set hlsearch"! By Questor
	" call feedkeys("\<Esc>" . g:cmdLineCaller . "set hlsearch\<cr>\<Esc>" . g:cmdLineCaller . "redraw!\<cr>")

	let g:grooVimSearchFowardBlock = 0

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

	call GrooVim_GrooVimBarMsg("Use Del or double click to navigate!", 4)

endfunc

" Note: Serve para sincronizar em várias tabs determinados "estados"! É executado 
" sempre que uma tab é acessada! By Questor
autocmd! TabEnter * call GrooVim_TabParadise()
func! GrooVim_TabParadise()
	" Note: Se houver uma lista de pesquisa, abre essa a lista na tab atual se a
	" funcionalidade estiver ativada! By Questor
	if g:GrooVim_SearchGuyEnabled == 1 && g:searchReplace_InAllOpened == 1
		call GrooVim_SearchGuySync()
	endif
endfunc

if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
	" Note: Abre e fecha o "Nerd Tree atravez do componente "vim-nerdtree-tabs"! By Questor
	let g:NERDTreeTabsOpen = 0
	func! GrooVim_ToggleNERDTreeTabs()
		if g:NERDTreeTabsOpen == 1
			exec "NERDTreeTabsClose"
			let g:NERDTreeTabsOpen = 0
		else
			exec "NERDTreeTabsOpen"
			let g:NERDTreeTabsOpen = 1

			" Note: Foco no Nerdtree quando abrir! By Questor
			let l:exitWhile = 0
			let l:firstBufferOnThisTab = expand('%:t')
			while ! (expand('%:t') =~ "NERD_tree_") && l:exitWhile == 0
				exec "norm \<C-w>"
				if expand('%:t') == l:firstBufferOnThisTab
					let l:exitWhile = 1
				endif
			endwhile

		endif
	endfunc
endif

" Note: Ao entrar em uma tab abre a lista de ocorrências se o search guy estiver
" acionado! By Questor
func! GrooVim_SearchGuySync()
	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 0

		call GrooVim_PutOnEditWindow()

		" Note: O "set ma" e "set noma" abre e bloqueia edição do 
		" buffer! By Questor
		set ma
		exec "set splitbelow"
		silent exec "split GrooVim_SearchGuyResults" . tabpagenr()
		exec "put =g:matchedLinesGlobal"
		set cursorline
		exec "norm ggdd"
		set noma
	endif
endfunc

" Note: Permite navegação nos resultados usando "Del"! By Questor
func! GrooVim_SearchGuyNavigate() range

	" Note: A navegação da lista é sempre para a frente para facilitar! By Questor
	let g:grooVimSearchFoward = 1

	let l:listPosLinCol = getpos(".")
	let l:listPosLinToArray = (l:listPosLinCol[1] - 1)
	if l:listPosLinToArray >= 0 && g:matchedLinesGlobalNavArray[l:listPosLinToArray] != 0

		exec "tabn " . split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[0]

		while !(expand('%:t') =~ "GrooVim_SearchGuyResults")
			exec "norm \<C-w>"
		endwhile

		set ma
		exec "norm ggdG"
		exec "put =g:matchedLinesGlobal"
		exec "norm ggdd"
		call setpos(".", l:listPosLinCol)
		exec "norm 0i->"
		set noma

		while expand('%:t') != split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[1]
			exec "norm \<C-w>"
		endwhile
		call setpos(".", [0, split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[2], split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[3]])
		exec "norm \<Left>n"

	endif

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

endfunc

" Note: Prepara o "GrooVim_SearchGuy" para uma nova execução/fecha-o! By Questor
func! GrooVim_SearchGuyPrepare()

	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 1

		try
			" Note: Com essa abordagem eu consigo efetivamente "destruir" 
			" o buffer não retornando "falso" positivos no "bufexists" 
			" acima! By Questor
			exec "bwipeout! GrooVim_SearchGuyResults" . tabpagenr()
		catch
			
		endtry

	endif

endfunc

" Note: For debug purposes. To stop uses "0". Permite uma "parada" na linha em
" que é chamado e exibe uma menssagem! By Questor
func! GrooVim_PauseExecution(msg)
	echo "msg: \"" . a:msg . "\""
	while getchar() != 48
		exec "sleep 1000m"
	endwhile
endfunc

" Note: Permite que uso "multimodo" do enter! By Questor
vnoremap <buffer> <Enter>  "_x<bar>i<cr><Esc>

" Note: Seta o comportamento do Del a depender do contexto! By Questor
nnoremap <script> <Del> :call GrooVim_DelBehavior()<cr>
func! GrooVim_DelBehavior() range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Permite que uso "multimodo" do del! By Questor
		call GrooVim_NormalDel()
	endif
endfunc

" Note: Treat a string and return a substring to use in prompts! By Questor
func! GrooVim_SubstringToPrompt(stringToBeTreated)
	let l:lineSplited = split(a:stringToBeTreated, "\n")
	let l:transferAreaToShow = ""
	try
		" if len(l:lineSplited) > 1
			if strlen(l:lineSplited[0]) > 70
				let l:transferAreaToShow = l:lineSplited[0][0:70] . "..."
			else
				if len(l:lineSplited) > 1
					let l:transferAreaToShow = l:lineSplited[0] . "..."
				else
					let l:transferAreaToShow = l:lineSplited[0]
				endif
			endif
	catch

	endtry
	return l:transferAreaToShow
endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:configureGrooVim_EntertainmentReplace_Confirmation = 1
let g:searchReplace_InAllOpened = 0
let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = 1
let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = 0
func! GrooVim_EntertainmentReplace(mod) range

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	let l:valueToReplace = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToReplace = @+
	else
		let l:valueToReplace = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToReplaceTemp = GrooVim_EscapeSubstituteValueToSearch(input("Value that will be REPLACED (empty to use \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\"): "))
			if ("" . l:valueToReplaceTemp . "") != "" || ("" . l:valueToReplace . "") != ""
				let l:stopWhile = 1
				if l:valueToReplaceTemp != ""
					let l:valueToReplace = l:valueToReplaceTemp
				endif
			endif
		endwhile
	endif

	let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(input("Value that will REPLACE \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\" (empty to use transfer área value \"" . GrooVim_SubstringToPrompt(@+) . "\"): "))

	if l:valueThatWillReplace == ""
		" Note: "GrooVim_EscapeSubstituteValueToSearch()" não é necessário
		" quando o valor vem de "input()", pois este último já trata
		" isso! By Questor
		let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(@+)
	endif

	let l:valueThatWillReplace = l:valueThatWillReplace

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToReplace)

	let l:confirmOrNot = ""

	if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
		let l:confirmOrNot = "c"
	endif

	if a:mod == "v"
		exec "norm \<Left>"
	else
		exec "norm b\<Left>"
	endif

	if g:searchReplace_InAllOpened != 1
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			" Note: Replace begin from current position! By Questor
			exec ".,$s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		else
			exec "%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		endif
	else
		" Note: "let g:tryCathOnTabDo = 1" -> Caso não haja valor para replace em uma das tabs o processo
		" não levanta erro! By Questor
		let g:tryCathOnTabDo = 1
		call TabDo("%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot)
		let g:tryCathOnTabDo = 0
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"h\"!", 4)

endfunc

func! GrooVim_EscapeSubstituteValueToSearch(valueToTreat)
	" Note: Create search pattern! By Questor
	let l:pattern = escape(a:valueToTreat, '\\/.*$^~[]')
	let l:pattern = substitute(l:pattern, "\n$", "", "")
	return l:pattern
endfunc

" Note: Workaround para obter milisegundos! By Questor
func! GrooVim_GetMilliseconds()
	let l:format = "+%s%3N"
	let l:cmd = "/bin/date -u " . shellescape(format)
	" Note: É "let fakeHolder = getchar(0)" uma tentativa de evitar o retorno de caracteres malucos quando na
	" execução desse comando! By Questor
	let l:result = substitute(system(cmd), "[\]\|[[:cntrl:]]", "", "g")
	return l:result
endfunc

" Note: Permite um "super leader" que é acionado em qualquer modo!
" Com essa abordagem eu, também, consigo mapear uma quantidade muito
" maior de teclas! Note o uso das teclas z, a e t nos leader commands
" necessários para certos worarounds! By Questor

nnoremap <silent> <script> <F2> :call GrooVim_CommandZ("F2", "n")<cr>
inoremap <silent> <script> <F2> <C-o>:call GrooVim_CommandZ("F2", "i")<cr>
vnoremap <silent> <script> <F2> :<C-u>call GrooVim_CommandZ("F2", "v")<cr>

nnoremap <silent> <script> <F3> :call GrooVim_CommandZ("F3", "n")<cr>
inoremap <silent> <script> <F3> <C-o>:call GrooVim_CommandZ("F3", "i")<cr>
vnoremap <silent> <script> <F3> :<C-u>call GrooVim_CommandZ("F3", "v")<cr>

nnoremap <silent> <script> <F4> :call GrooVim_CommandZ("F4", "n")<cr>
inoremap <silent> <script> <F4> <C-o>:call GrooVim_CommandZ("F4", "i")<cr>
vnoremap <silent> <script> <F4> :<C-u>call GrooVim_CommandZ("F4", "v")<cr>

nnoremap <silent> <script> <F5> :call GrooVim_CommandZ("F5", "n")<cr>
inoremap <silent> <script> <F5> <C-o>:call GrooVim_CommandZ("F5", "i")<cr>
vnoremap <silent> <script> <F5> :<C-u>call GrooVim_CommandZ("F5", "v")<cr>

nnoremap <silent> <script> <F5> :norm q<cr>

" Tip: Try to "balance" the distribution of the keys to preserve your
" hands! By Questor

let g:GrooVim_CommandZMoment = 0
let g:GrooVim_CommandZChar = ""
let g:GrooVim_CommandZUnblock = 1
let g:GrooVim_CommandZFCaller = ""
func! GrooVim_CommandZ(GrooVim_CommandZFCallerNow, modType)

	let l:GrooVim_CommandZNowChar = ""
	" Note: Essa lógica permite a reexecução do último comando apenas
	" usando uma tecla F(1, 2, 3...). Se houver um mesmo F? em menos de um
	" segundo, o último comando é executado sem esperar que seja informada
	" uma nova tecla para compor o comando. Se for mais de um segundo aguarda
	" uma nova tecla e se não houver reexecuta o último comando! Sempre
	" que uma F? diferente da última for acionada o Vim ficará aguardando
	" uma techa para compor o comando e nada fará enquanto está não for
	" informada! By Questor

	" Note: O "strftime("%Y%m%d%H%M%S")" não retorna milisegundos e por
	" isso foi substituído! By Questor

	let l:GrooVim_CommandZMomentNow = GrooVim_GetMilliseconds()

	" Note: In terminal vim, prevent ghost echoing while running a shell command via system()! By Questor
	redraw!

	if (l:GrooVim_CommandZMomentNow - g:GrooVim_CommandZMoment) > 400 || g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow
		exec "sleep 400m"
		let l:GrooVim_CommandZNowChar = getchar(0)
		if l:GrooVim_CommandZNowChar != "" && l:GrooVim_CommandZNowChar != "\<f2>" && l:GrooVim_CommandZNowChar != "\<f3>" && l:GrooVim_CommandZNowChar != "\<f4>" && l:GrooVim_CommandZNowChar != "\<f5>"
			let g:GrooVim_CommandZChar = l:GrooVim_CommandZNowChar
		endif
		if g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow && l:GrooVim_CommandZNowChar == ""
			let g:GrooVim_CommandZChar = ""
		endif
	endif
	" Note: To debug! By Questor
	" echo g:GrooVim_CommandZChar
	let g:GrooVim_CommandZMoment = l:GrooVim_CommandZMomentNow
	if g:GrooVim_CommandZChar != "" && g:GrooVim_CommandZUnblock == 1
		" Note: Evita que seja reexecutado um comando enquanto outro
		" está em adamento! By Questor
		let g:GrooVim_CommandZUnblock = 0
		" Note: Edit commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F2"
			" Note: Used keys for F2: h k j up down c a d q w e end del! By Questor
			" Note: To debug! By Questor
			" Note: Alinha à esquerda (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				:left
			endif
			" Note: Alinha à direita (k)! By Questor
			if g:GrooVim_CommandZChar == "107"
				:right
			endif
			" Note: Alinha no centro (j)! By Questor
			if g:GrooVim_CommandZChar == "106"
				:center
			endif
			" Note: To uppercase (normal/insert) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType != "v"
				exec "norm gUiwe"
			endif
			" Note: To lowercase (normal/insert) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType != "v"
				exec "norm guiwe"
			endif
			" Note: To uppercase (visual) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType == "v"
				call GrooVim_ToUpperLower("Upper")
			endif
			" Note: To lowercase (visual) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType == "v"
				call GrooVim_ToUpperLower("Lower")
			endif
			" Note: Copia todo o texto (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				exec "%y+"
			endif
			" Note: Seleciona todo o texto (a)! By Questor
			if g:GrooVim_CommandZChar == "97"
				exec "norm ggVG$"
			endif
			" Note: Duplica a linha atual (normal) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "n"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplica a linha atual (insert) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "i"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplica a seleção atual (visual) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "v"
				call GrooVim_DuplicateVisualSelection()
				" Note: Esse comando não permite repetição
				" simples! By Questor
				let g:GrooVim_CommandZChar = ""
			endif
			" Note: Grava uma macro (q)! By Questor
			if g:GrooVim_CommandZChar == "113"
				call GrooVim_XenRec()
			endif
			" Note: Excuta uma macro (w)! By Questor
			if g:GrooVim_CommandZChar == "119"
				call GrooVim_XenPlay(0)
			endif
			" Note: Excuta uma macro de forma repetida (e)! By Questor
			if g:GrooVim_CommandZChar == "101"
				call GrooVim_XenPlay(1)
			endif
			" Note: Select inner word (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				exec "norm viw"
			endif
			" Note: Select a range (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				call GrooVim_SelectRange(a:modType)
			endif
		endif
		" Note: Control commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F3"
			" Note: Used keys for F3: n c o v r / s f d h j [ ]! By Questor
			" Note: Abre uma nova tab (n)! By Questor
			if g:GrooVim_CommandZChar == "110"
				tabnew
				" Note: Solve read only problem! By Questor
				set ma
			endif
			" Note: Fecha a tab atual (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				tabc
			endif
			" Note: Fecha todas as demais tabs (o)! By Questor
			if g:GrooVim_CommandZChar == "111"
				tabonly
			endif
			" Note: Abre o arquivo .vimrc (v)! By Questor
			if g:GrooVim_CommandZChar == "118" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\zv")
			endif
			if g:GrooVim_CommandZChar == "118" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\zvi")
			endif
			" Note: Recarrega o arquivo .vimrc (r)! By Questor
			if g:GrooVim_CommandZChar == "114" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\zvvi")
			endif
			if g:GrooVim_CommandZChar == "114" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\zvv")
			endif
			" Note: Remove marcadores de pesquisa (visual/normal)(/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\z/")
			endif
			" Note: Remove marcadores de pesquisa (insert)(/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\z/i")
			endif
			" Note: Salva o arquivo (s)! By Questor
			if g:GrooVim_CommandZChar == "115" && a:modType != "v"
				:w
			endif
			if g:GrooVim_CommandZChar == "115" && a:modType == "v"
				call GrooVim_VisualWrite()
			endif
			" Note: Abre para pesquisa no normal e insert mode (f)! By Questor
			if g:GrooVim_CommandZChar == "102" && a:modType != "v"
				call GrooVim_SearchWithMyOptions("n")
			endif
			if g:GrooVim_CommandZChar == "102" && a:modType == "v"
				call GrooVim_SearchWithMyOptions("v")
			endif
			" Note: Abre para configurar a busca (d)! By Questor
			if g:GrooVim_CommandZChar == "100"
				call GrooVim_ConfigureSearchReplace("search")
			endif
			" Note: Abre para configurar o replace (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				call GrooVim_ConfigureSearchReplace("replace")
			endif
			" Note: Abre para replace (j)! By Questor
			if g:GrooVim_CommandZChar == "106" && a:modType != "v"
				call GrooVim_EntertainmentReplace("n")
			endif
			if g:GrooVim_CommandZChar == "106" && a:modType == "v"
				call GrooVim_EntertainmentReplace("v")
			endif
			" Note: Save session ([)! By Questor
			if g:GrooVim_CommandZChar == "91"
				exec "mksession! ~/vim_session"
				echomsg "Session saved!"
			endif
			" Note: Reload session (])! By Questor
			if g:GrooVim_CommandZChar == "93"
				exec "source ~/vim_session"
			endif
			" Note: Get current filename or filename and path and put on transfer area (p)! By Questor
			if g:GrooVim_CommandZChar == "112"
				call GrooVim_GetFileNameAndPath()
			endif
			" Note: Permite retornar para um determinada tab sempre (t)! By Questor
			if g:GrooVim_CommandZChar == "116"
				call GrooVim_TabToReturnSet()
			endif
			" Note: Select and search the word under cursor (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				call GrooVim_SelectNSearch(1, a:modType)
			endif
			" Note: Reselect area (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				exec "norm gv"
			endif
			" Note: Salva no disco e abre em uma nova tab uma cópia do arquivo atual (y)! By Questor
			if g:GrooVim_CommandZChar == "121"
				call GrooVim_SaveACopy()
			endif
		endif
		" Note: Plugin commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F4"
			" Note: Used keys for F4: f d! By Questor
			" Note: Abre/fecha o nerdtree (n)! By Questor
			if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "110"
					" call ToggleNERDTree()
					call GrooVim_ToggleNERDTreeTabs()
				endif
			endif
			" Note: Abre/fecha o vim debug (d)! By Questor
			if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "100"
					call GrooVim_ToggleDbg()
				endif
			endif
		endif
		" Note: Other commands! By Questor
		" Note: Used keys for F5: ! By Questor
		if a:GrooVim_CommandZFCallerNow == "F5"
		endif
		let g:GrooVim_CommandZUnblock = 1
	endif
	let g:GrooVim_CommandZFCaller = a:GrooVim_CommandZFCallerNow

endfunc

nnoremap <silent> <script> <F9> :call GrooVim_ToogleGrooVimHelp()<cr>

" Note: Tentar garantir que abra na janela de edição! By Questor
func! GrooVim_PutOnEditWindow() range
	while expand('%:t') =~ "GrooVim_SearchGuyResults" || expand('%:t') =~ "NERD_tree_" || expand('%:t') =~ "GrooVimHelp"
		exec "norm \<C-w>"
	endwhile
endfunc

" Note: Exibe a ajuda do GrooVim. Esse texto está no próprio corpo do GrooVim! By Questor
func! GrooVim_ToogleGrooVimHelp() range

	if bufexists("GrooVimHelp") == 0

		call GrooVim_PutOnEditWindow()

		" Note: O "set ma" e "set noma" abre e bloqueia edição do
		" buffer! By Questor
		set ma
		silent exec "split GrooVimHelp"
		exec "put =g:GrooVimHelp"
		exec "norm ggdd"
		exec "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapmargin=0 | set formatoptions+=l | set syntax=help"
		set noma
	else
		" Note: Com essa abordagem eu consigo efetivamente "destruir" 
		" o buffer não retornando "falso" positivos no "bufexists" 
		" acima! By Questor
		exec "bwipeout! GrooVimHelp"
	endif

endfunc

" Note: Get current filename or filename and path and put on transfer area! By Questor
func! GrooVim_GetFileNameAndPath() range

	let l:filenameOrFilenameAndPath = ""

	let l:getFilenameOrFilenameAndPath = GrooVim_GetOptions("Get [0]filename or [1]filename and path [0[default]/1]? ", [1,0], 0)
	if l:getFilenameOrFilenameAndPath == 0
		let l:filenameOrFilenameAndPath = expand('%:t')
		echomsg " -> Filename \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	elseif l:getFilenameOrFilenameAndPath == 1
		let l:filenameOrFilenameAndPath = expand('%:p')
		echomsg " -> Filename and path \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	endif

	" Note: Set the clipboard register! By Questor
	let @+ = l:filenameOrFilenameAndPath

endfunc

" Note: Grava uma macro! By Questor
func! GrooVim_XenRec() range
	call GrooVim_GrooVimBarMsg("Use \"q\" to stop macro recording!", 5)
	exec "norm qa"
	echo "Starting a NEW recording!"
endfunc

" Note: Executa uma macro repetindo ou não! By Questor
let g:GrooVim_XenPlayRunningWithSearch = 0
func! GrooVim_XenPlay(repeatExecution) range

	if a:repeatExecution == 0
		exec "norm @a"
		" Note: Por razões desconhecidas o valor da variável "g:GrooVim_CommandZChar" se perde na execução do comando, não
		" permitindo repetição simples e por isso o workaround! By Questor
		let g:GrooVim_CommandZChar = "119"
	elseif a:repeatExecution == 1
		let g:block_GrooVim_HLNext = 1
		let g:GrooVim_XenPlayRunningWithSearch = 0
		let l:numberOfRepetitions = input("Number of repetitions (use \"x\" to excute to last/first line): ")
		" Note: Executa até a última/primeira linha! By Questor
		if l:numberOfRepetitions == "x"
			" Note: "set nowrapscan" serve para evitar voltar ao começo! By Questor
			set nowrapscan
			let l:stopWhile = 0
			let l:firstExecution = 1
			let l:executionDirection = ""
			while l:stopWhile == 0
				let l:posBefore = getpos(".")
				if (l:posBefore[1] >= getpos("$")[1] || l:posBefore[1] == 1) && l:firstExecution == 0 && g:GrooVim_XenPlayRunningWithSearch == 0
					let l:stopWhile = 1
				endif

				" Note: Se não houver mais ocorrências para uma pesquisa para a execução! By Questor
				try
					" Note: Testa se ainda existem ocorrências! By Questor
					if l:executionDirection != "" && g:GrooVim_XenPlayRunningWithSearch == 1
						if l:executionDirection == "d"
							exec "norm n"
						endif
						if l:executionDirection == "u"
							exec "norm N"
						endif
						call setpos(".", l:posBefore)
					endif
					exec "norm @a"

				catch
					let l:stopWhile = 1
				endtry

				let l:posAfter = getpos(".")

				if l:posBefore[1] == l:posAfter[1] && l:firstExecution == 1 && g:GrooVim_XenPlayRunningWithSearch == 0

					if l:posBefore[1] != getpos("$")[1] && l:posBefore[1] != 1
						call GrooVim_GrooVimBarMsg("This macro isn't compatible with the execution that you selected. The current line will be always the same!", 4)
					endif
					let l:stopWhile = 1

				endif

				if l:executionDirection != ""
					if l:executionDirection == "d"
						if l:posBefore[1] > l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
					if l:executionDirection == "u"
						if l:posBefore[1] < l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
				endif

				if l:executionDirection == ""
					if l:posBefore[1] < l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] < l:posAfter[2])
						let l:executionDirection = "d"
					endif
					if l:posBefore[1] > l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] > l:posAfter[2])
						let l:executionDirection = "u"
					endif
				endif

				if l:stopWhile == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: O "redraw!" é para garantir que
					" a menssagem seja exibida! By Questor
					redraw!
				endif

				" Note: See execution! By Questor
				redraw!

				let l:firstExecution = 0

			endwhile
			set wrapscan
		else

			" Note: Executa "n" vêzes! By Questor

			" Note: Check for valid numbers! By Questor
			let l:invalidNumber = 1
			while l:invalidNumber == 1

				let l:invalidNumber = 0

				if l:numberOfRepetitions != str2nr(l:numberOfRepetitions)
					let l:invalidNumber = 1
				endif

				if l:numberOfRepetitions <= 0
					let l:invalidNumber = 1
				endif

				if l:invalidNumber == 1
					let l:numberOfRepetitions = input("Number of repetitions (use a valid one!): ")
				endif

			endwhile

			for i in range(1, l:numberOfRepetitions)

				" Note: Se no houver mais ocorrências para uma pesquisa para a execução! By Questor
				try
					exec "norm @a"
				catch
					let l:stopWhile = 1
				endtry

				let g:onMoveScreen = 1
				if g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: O "redraw!" é para garantir que
					" a menssagem seja exibida! By Questor
					redraw!
				endif
				" Note: See execution! By Questor
				redraw!
			endfor

		endif

		" Note: Por razões desconhecidas o valor da variável "g:GrooVim_CommandZChar" se perde na execução do comando, não 
		" permitindo repetição simples e por isso o workaround! By Questor
		let g:GrooVim_CommandZChar = "101"

		let g:GrooVim_XenPlayRunningWithSearch = 0

	endif

	let g:block_GrooVim_HLNext = 0

endfunc

" Note: Permite duplicar uma área de seleção de forma simples! By Questor
func! GrooVim_DuplicateVisualSelection() range
	let l:saved_reg = @+
	exec "norm gvygv\<Esc>p"
	let @+ = l:saved_reg
endfunc

" Note: Edit/reload the vimrc file! By Questor
nnoremap <silent> <leader>zv :tabedit $MYVIMRC<cr>
nnoremap <silent> <leader>zvv :tabdo source $MYVIMRC<cr><bar>:tabfirst<cr>

" Note: Clears the search register! By Questor
nnoremap <silent> <leader>z/ :nohlsearch<cr>

if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
	" Note: Abre e fecha o "VIM Debug" à depender se ele esteja aberto ou fechado! By Questor
	let g:NERDTreeIsOpen = 0
	func! GrooVim_ToggleDbg()
		if exists("g:Dbg")
			unlet g:Dbg
			Dbg quit
		else
			try
				if exists("g:NERDTreeIsOpen")
					unlet g:NERDTreeIsOpen
					NERDTreeTabsClose
				endif
					Dbg .
				let g:Dbg = 1
			catch
				echo "No Errors found!"
			endtry
		endif
	endfunc
endif

" Note: Salva no disco e abre em uma nova tab uma cópia do arquivo atual! By Questor
func! GrooVim_SaveACopy() range

		let l:valueToPath = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToPath = input("PATH to save your file copy (type \"0\" to use transfer area \"" . GrooVim_SubstringToPrompt(@+) . "\", \"1\" to use empty, \"2\" to use current file path or enter one): ")
			if l:valueToPath == "0"
				if !empty(matchstr(@+, "\/$"))
					let l:stopWhile = 1
					let l:valueToPath = @+
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					" Note: O "redraw!" é para garantir que a menssagem seja exibida! By Questor
					redraw!
				endif
			elseif l:valueToPath == "1"
				let l:stopWhile = 1
				let l:valueToPath = ""
			elseif l:valueToPath == "2"
				let l:stopWhile = 1
				let l:valueToPath = expand("%:h") . "/"
			elseif ("" . l:valueToPath . "") != ""
				if !empty(matchstr(l:valueToPath, "\/$"))
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					redraw!
				endif
			endif
		endwhile

		let l:definePathWarning = ""
		let l:valueToName = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			if l:valueToPath == ""
				let l:definePathWarning = " (DEFINE A PATH TOO!)"
			endif
			let l:valueToName = input("NAME of the file copy to be saved" . l:definePathWarning . ": ")
			if ("" . l:valueToName . "") != ""
				if ("" . l:valueToName . "") != expand('%:t') || l:valueToPath != expand("%:h") . "/"
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Same name and path as the current file!", 1)
					redraw!
				endif
			endif
		endwhile

		try
			exec "w " . l:valueToPath . l:valueToName
			exec "tabnew " . l:valueToPath . l:valueToName
			call GrooVim_GrooVimBarMsg("A file copy was created!", 1)
			redraw!
		catch
			call GrooVim_GrooVimBarMsg("The file copy can't be saved! Reason: \"" . v:exception . "\"", 1)
			redraw!
		endtry

endfunc

" Note: Permite salvar estando no modo visual! By Questor
func! GrooVim_VisualWrite() range
	" Note: Witre! By Questor
	exec "w"
	" Note: Reselect area! By Questor
	exec "norm gv"
endfunc

" Note: Upper ou lower para a palavra ou seleção atual! By Questor
func! GrooVim_ToUpperLower(modType) range
	" Note: Reselect area! By Questor
	exec "norm gv"

	if a:modType == "Upper"
		exec "norm gU"
	endif

	if a:modType == "Lower"
		exec "norm gu"
	endif

	" Note: Repositioning on final! By Questor
	exec "norm gv\<Esc>"
endfunc

" Note: Sudo to write! By Questor
"cnoremap w!! w !sudo tee % >/dev/null

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"APPEARANCE
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Exibe o número de cada linha! By Questor
set number

" Note: Always show current position! By Questor
set ruler

" Note: Height of the command bar. By Questor
set cmdheight=2

" For regular expressions turn magic on
set magic

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set mat=2

" No annoying sound on errors
set noerrorbells
set novisualbell

" ToDo: O que vem a ser isso? By Questor
" set t_vb=

" ToDo: Line break? By Questor
set tm=500

" Note: Allow the cursor to go in to "invalid" places! By Questor
" set virtualedit=all

" Note: Always turn on syntax highlighting for diffs! By Questor
" select by the file-suffix directly...
augroup PatchDiffHighlight
	autocmd! BufEnter  *.patch,*.rej,*.diff   syntax enable
augroup end

" Note: Exibe avisos na barra de rolagem! By Questor
let g:GrooVim_GrooVimBarMsgValue = ""
let g:GrooVim_GrooVimBarMsgMoment = ""
let g:GrooVim_GrooVimBarMsgEnabled = 0
let g:GrooVim_GrooVimBarMsgDuration = 0
func! GrooVim_GrooVimBarMsg(msgValue, msgDuration)

	if g:GrooVim_CheckCapsLockReturn == 0
		if a:msgValue != ""
			let g:GrooVim_GrooVimBarMsgValue = " Hey: " . a:msgValue
			let g:GrooVim_GrooVimBarMsgMoment = strftime("%Y%m%d%H%M%S")
			let g:GrooVim_GrooVimBarMsgEnabled = 1
			let g:GrooVim_GrooVimBarMsgDuration = a:msgDuration
		else
			let g:GrooVim_GrooVimBarMsgValue = ""
			let g:GrooVim_GrooVimBarMsgEnabled = 0
		endif
		call GrooVim_GrooVimBar()
	endif

endfun

" Note: Exibe uma barra de informações! By Questor
set laststatus=2
func! GrooVim_GrooVimBar()

	let l:barContents = '%f [%{(&fenc==""?&enc:&fenc).((exists("+bomb") && &bomb)?",B":"")}%M%R%H%W] %y [%l/%L,%v] [%p%%]'
	return l:barContents . " Powered by [GrooVim =D " . g:grooVimVersion . "]!" . g:GrooVim_GrooVimBarMsgValue

endfun
set stl=%!GrooVim_GrooVimBar()
" Note: Exibe uma menssagem na execução inicial! By Questor
call GrooVim_GrooVimBarMsg("To see GrooVim help use F9!", 10)

" Note: Make the 81st column stand out (just the 80st column of wide lines...)! By Questor
highlight GrooVim_ColorColumn ctermbg=blue
augroup GrooVim_ColorColumn
	autocmd! VimEnter,WinEnter * call matchadd('GrooVim_ColorColumn', '\%81v', 100)
augroup end

" Note: Make tabs, trailing whitespace and non-breaking spaces visible! By Questor
set list
" Note: Type I! By Questor
"exec "set listchars=tab:\uBB\uBB,trail:\uB7,nbsp:~"
" Note: Type II! By Questor
exec "set listchars=tab:▒░,trail:\uB7,nbsp:~"

" Note: switch syntax highlighting on, when the terminal has colors! By Questor
if &t_Co > 2 || has("gui_running")
	syntax on
endif

" Note: Switch from block-cursor to vertical-line-cursor when going into/out of insert mode! By Questor
" let &t_SI = "\<Esc>]50;CursorShape=1\x7"
" let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" Note: " Cursor -> Orange in insert mode and red in command mode!
" if you want to use rgb color formatting: konsoleprofile
" CustomCursorColor=#255255255! By Questor
let g:cursorColorI = "orange"
let g:cursorColorNV = "red"
let g:cursorColorBlock = 0

func! SetCursorColor()
	let &t_SI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorI . ";BlinkingCursorEnabled=1\x7"
	let &t_EI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorNV . ";BlinkingCursorEnabled=0\x7"
endfun

if &term =~ "xterm\\|rxvt" && $COLORTERM != "gnome-terminal"
	autocmd VimEnter * silent !konsoleprofile UseCustomCursorColor=1
	call SetCursorColor()
	silent !konsoleprofile CustomCursorColor=red
	autocmd VimLeave * silent !konsoleprofile CustomCursorColor=default;BlinkingCursorEnabled=0
endif

" " Note: Exibe a linha do cursor (causes slowdown)! By Questor
" if exists('+cursorline')
" 	set cursorline cursorcolumn
" endif
"
" " Note: Exibe a coluna do cursor (causes slowdown)! By Questor
" hi CursorLine cterm=NONE,underline guibg=#F4F4F4
" hi! link CursorColumn CursorLine

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"USABILITY
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always show what mode we're currently editing in! By Questor
set showmode

" Note: Don't wrap lines! By Questor
set nowrap

" Note: Allow backspacing over everything in insert mode! By Questor
set backspace=indent,eol,start

" Note: remember more commands and search history! By Questor
set history=1000

" Note: use many/muchos levels of undo! By Questor
set undolevels=1000

" Note: Ignore case when searching! By Questor
set ignorecase

" Note: When searching try to be smart about cases! By Questor 
" set smartcase

" Note: Makes search act like search in modern browsers ("acende" as
" ocorrências já na digitação)! By Questor
set incsearch

" Note: Search/replace "globally" (on a line) by default! By Questor
set gdefault

" Note: Return to last edit position when opening files (You want this!)! By Questor
autocmd! BufReadPost *
	\ if line("'\"") > 0 && line("'\"") <= line("$") |
	\   exe "normal! g`\"" |
	\ endif
set viminfo^=%

" Note: Bind <F1> to show the keyword under cursor general help can still be entered manually, with :h! By Questor
if has("autocmd")
	augroup vim_files
		autocmd! filetype vim noremap <buffer> <F1> <Esc>:help <C-r><C-w><cr>
		autocmd! filetype vim noremap! <buffer> <F1> <Esc>:help <C-r><C-w><cr>
	augroup end
endif

" Note: Turn persistent undo on means that you can undo even when you close a buffer/VIM! By Questor
" ToDo: Colocar a criação desse diretório no roteiro! By Questor
try
	set undodir=~/.vim/Temp/Undodir
	set undofile
catch
endtry

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"INDENTATION AND SYNTAX
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always set autoindenting on! By Questor
" ToDo: (Rever)! By Questor"
" set autoindent

" Note: Copy the previous indentation on autoindenting! By Questor
" ToDo: (Rever)! By Questor
" set copyindent

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"PLUGINS CONFIGURATION
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"* NERDTree

" Note: Store the bookmarks file! By Questor
let NERDTreeBookmarksFile = expand("$HOME/.vim/NERDTreeBookmarks")

" Note: Show the bookmarks table on startup! By Questor
let NERDTreeShowBookmarks = 1

" Note: Show hidden files, too! By Questor
let NERDTreeShowFiles = 1

" Note: Quit on opening files from the tree! By Questor
" let NERDTreeQuitOnOpen = 1

" Note: Highlight the selected entry in the tree! By Questor
let NERDTreeHighlightCursorline = 1

" Note: Use a single click to fold/unfold directories and a double click to open files! By Questor
let NERDTreeMouseMode=2

" Note: NERDTree always open on the right side! By Questor
let NERDTreeWinPos = "right"

"* move-vim

" Note: Mapping to move-vim! By Questor
if g:enable_move_vim == 1 && g:enable_all_plugins == 1
	let g:move_key_modifier = "C"
	inoremap <silent> <C-k> <C-o>:call GrooVim_Move_Vim_OnInsert("up")<cr>
	inoremap <silent> <C-j> <C-o>:call GrooVim_Move_Vim_OnInsert("down")<cr>
	" Note: Esse workaround serve para que o move-vim possa ser acionado no insert mode! By Questor
	func! GrooVim_Move_Vim_OnInsert(direc)
		if a:direc == "up"
			exec "norm \<C-k>"
		elseif a:direc == "down"
			exec "norm \<C-j>"
		endif
	endfun
endif

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENCODING
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,big5,gb2312,latin1

fun! ViewUTF8()
	set encoding=utf-8
	set termencoding=big5
endfun

fun! UTF8()
	set encoding=utf-8
	set termencoding=big5
	set fileencoding=utf-8
	set fileencodings=ucs-bom,big5,utf-8,latin1
endfun

fun! Big5()
	set encoding=big5
	set fileencoding=big5
endfun

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"HELP
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Para facilitar esse texto sempre deve ser o último! By Questor

let g:GrooVimHelp = "*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n|GrooVim|=D|2.0.7b|-|Vi|IMproved\'n\'GrooVIed!|".
\"\n Last change: 2014 June 12".
\"\n Eduardo L\u00facio Amorim Costa~".
\"\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n".
\"\n                   {+}".
\"\n                  {+++}".
\"\n                 {+++++}".
\"\n                {+++++++}".
\"\n               {+++++++++}".
\"\n             {+++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n{+++++++++++++++++++++++++++++++++++++++}".
\"\n  {++++++++++++++GrooVim++++++++++++++}".
\"\n    {+++++++++++++++++++++++++++++++}".
\"\n      {+++++++++++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n           {+++++++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n        {+++++++++++++++++++++++}".
\"\n       {++++++++}       {++++++++}".
\"\n      {+++++}               {+++++}".
\"\n     {++}                       {++}".
\"\n".
\"\n|BETA|VERSION!|".
\"\n".
\"\n * What is GrooVim?~".
\"\n".
\"\n The|GrooVim|is an extensive script (it\'s a|.vimrc|) that modifies the behavior of Vim to facilitate your work and increase your productivity aim the following objectives:".
\"\n*o*  Allow use with just a few instructions by a public accustomed to editors/IDEs default;".
\"\n*o*  Facilitate and accelerate widely the use, being also a integrated \"UI\";".
\"\n*o*  Preserving always that possible the default behavior of Vim;".
\"\n*o*  Enhancing Vim project as a general purpose IDE;".
\"\n*o*  Approach Vim of \"standard\" text editors in what is convenient and positive and modify Vim in its negative aspects;".
\"\n*o*  Promote Vim as a better and faster alternative to market text editors and IDEs as well as a general-purpose editor;".
\"\n*o*  Enhancing Vim project as a free alternative (this script is Apache License - Version 2.0), independent and community-supported initiative;".
\"\n*o*  Encourage the use of shell Vim;".
\"\n*o*  Being a \"all in one\" package, ie, depend only on the contents of the file|.vimrc|to work (no plugin scenario);".
\"\n*o*  Being a script for all types of terminals;".
\"\n".
\"\n * Before you start with the GrooVim!~".
\"\n".
\"\n--------".
\"\n *IMPORTANT_I!* If you do not know how Vim works, please open a terminal, run|vimtutor|and do the exercises (takes 25 to 30 minutes). Then continue reading this document! IT IS VERY IMPORTANT TO KNOW THE DEFAULT VIM IN ITS BASIC, SO YOU CAN USE IT BETTER AND CONTRIBUTE WITH NEW FEATURES!".
\"\n *IMPORTANT_II!* The Vim is a powerful general purpose text editor/IDE. Keep in mind that the GrooVim was made possible through its great API (script) and wide versatility!".
\"\n *IMPORTANT_III!* Certain terminal emulators limits the possibility of Vim and GrooVim. Therefore, we recommend that for your \"all day\" Vim use a terminal that allows more possibilities and features!".
\"\n--------".
\"\n".
\"\n*o*  The GrooVim was designed to work with a wide range of keyboard shortcuts. Eventually, such shortcuts may present conflicts with shortcuts from your OS. This is normal and if conflicts occur we recommend that you modify the shortcuts of your OS, because the terminal environment does not allow a large number of combinations to form shortcuts;".
\"\n*o*  To further facilitate your life and increase productivity we recommend you make a mapping in your terminal to navigate between tabs using <Shift-Left>/<Shift-Right>. These two keyboard shortcuts (<Shift-Left>/<Shift-Right>) are not mapped in GrooVim to that you use in the way mentioned;".
\"\n   |-|Note: KDE desktop environment already works in that way with its terminal;".
\"\n*o*  The GrooVim was designed to work with tabs;".
\"\n*o*  The GrooVim was designed to work without constant use of \'virtualedit\' (\"virtualedit set=all\") to facilitate cursor navigation \"despising invalid areas\" (or without character) when convenient;".
\"\n*o*  The GrooVim was designed to work with the best plugins;".
\"\n   |-|We recommend install ALL the following plugins:".
\"\n      |-|*NERDTree*".
\"\n         |[https://github.com/scrooloose/nerdtree]|".
\"\n      |-|*tcomment*".
\"\n         |[https://github.com/tomtom/tcomment_vim]|".
\"\n      |-|*move*".
\"\n         |[https://github.com/matze/vim-move]|".
\"\n*o*  When using plugins *Pathogen* plugin needs to be intalled|[https://github.com/tpope/vim-pathogen];".
\"\n*o*  By default GrooVim not have any enabled plugin (see|let|g:enable_all_plugins|=|0|). You can also enable the plugins individually;".
\"\n".
\"\n * The GrooVim solves the following \"problems\"!!~".
\"\n".
\"\n*o*  <Ctrl-Left>/<Ctrl-Right> (normal mode/insert/visual) - Navigate by words in a conventional and practical way;".
\"\n*o*  <Tab> (normal mode/visual)- Indent in a conventional and practical way;".
\"\n*o*  <Enter> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Backspace> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Del> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  <Space> (normal mode/visual) - Use in a conventional and practical way;".
\"\n*o*  In the alternation between modes the cursor stays correctly positioned;".
\"\n*o*  Use default clipboard in a correct and conventional way (copy, cut and paste);".
\"\n*o* |Replace|, <x> (remove) and <d> (delete) preserving the clipboard;".
\"\n*o*  <PageDown>/<PageUp> - With navigation across the screen (invalid areas);".
\"\n*o*  <MouseScrollDown>/<MouseScrollUp> - With navigation across the screen (invalid areas);".
\"\n*o*  <MouseClick> (normal mode) - Across the screen (invalid areas);".
\"\n*o*  Just a <Ctrl-w> switches between windows;".
\"\n*o*  Etc...".
\"\n".
\"\n * Editor features!~".
\"\n".
\"\n*o*  Switching between modes:".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Enter or exit the insert mode;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Enter or exit the visual mode;".
\"\n".
\"\n*o*  Sele\u00e7\u00e3o de texto:".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert) - Word selection to the right/left;".
\"\n   |-|<Alt-End>/<Alt-Home> (normal mode/insert) - Select text on the line until the end/beginning from the current point;".
\"\n".
\"\n*o*  Conventional text editors commands:".
\"\n   |-|<Ctrl-c> (visual mode) - Copy to clipboard;".
\"\n   |-|<Ctrl-v> (normal mode/insert/visual) - Paste from clipboard;".
\"\n   |-|<Ctrl-x> (visual mode) - Cut to the clipboard;".
\"\n   |-|<Ctrl-u> (normal mode/insert/visual) - Undo;".
\"\n   |-|<Ctrl-r> (normal mode/insert/visual) - Redo;".
\"\n".
\"\n*o*  Plugins:".
\"\n   |-|move-vim;|".
\"\n        <Ctrl-j>/<Ctrl-k> (normal mode/insert/visual) - Move line or selection up/down;".
\"\n".
\"\n * Relevant changes in the default Vim behavior!~".
\"\n".
\"\n   |-|Use |Ctrl+b| to enable visual block mode;".
\"\n   |-|When changes from |visual|mode| to |insert|mode|the cursor do not move;".
\"\n   |-|Use default OS clipboard;".
\"\n   |-|The \"insert\" and \"paste\" from the same cursor position;".
\"\n".
\"\n * Script features!~".
\"\n".
\"\n*o*  Navigation".
\"\n".
\"\n   |-|<Shift-Alt-Arrows> (normal mode/insert/visual) - Smooth navigation across the screen with long movements (invalid areas);".
\"\n   |-|<Ctrl-Alt-Arrows> (normal mode/insert/visual) - Navigation with arrows across the screen (invalid areas) using shorts movements;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Returns to the previous tab;".
\"\n   |-|<Ctrl-Down>/<Ctrl-Up> (normal mode/insert/visual) - The access tabs on left/right;".
\"\n".
\"\n*o*  Word selection".
\"\n".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert/visual) - Word selection to the right/left;".
\"\n   |-|<2-leftmouse> (normal mode/insert) - Double click the mouse on a word then press <z> letter. All words with the same content will be highlighted;".
\"\n".
\"\n*o*  Comment lines".
\"\n".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Comment lines using *tcomment.vim* ;".
\"\n".
\"\n * F\'S Shortcuts (CommandZ)!~".
\"\n".
\"\n  The |CommandZ| is a kind of \"super leader\" that allows an extensive keys combination to create keyboard shortcuts for features in Vim. Works pressing <F2>, <F3> or <F4> keys and then another key.".
\"\n".
\"\n*o*  Features".
\"\n ".
\"\n |-|Allows replication of the last command just by pressing the last |F| used. If in a given interval a key combination is not informed the last command is repeated;".
\"\n |-|If |F| is hold down the command is replicated several times;".
\"\n".
\"\n    <F2> and then...".
\"\n      Note: Preferably for editing commands;".
\"\n        <h> - Aligns to left (normal mode/insert/visual);".
\"\n        <k> - Aligns to right (normal mode/insert/visual);".
\"\n        <j> - Aligns to center (normal mode/insert/visual);".
\"\n        <Up> - Changes to uppercase (normal mode/insert/visual);".
\"\n        <Down> - Changes to lowercase (normal mode/insert/visual);".
\"\n        <c> - Copy all text in the current buffer (normal mode/insert/visual);".
\"\n        <a> - Select all text in the current buffer (normal mode/insert/visual);".
\"\n        <d> - Duplicates the current line/selection (normal mode/insert/visual);".
\"\n            Note: If in the visual mode can not be replicated;".
\"\n        <q> - Record a macro (normal mode/insert/visual);".
\"\n        <w> - Run a macro (normal mode/insert/visual);".
\"\n        <e> - Run a macro certain number of times or repeatedly until the last line (normal mode/insert/visual);".
\"\n        <End> - Selects the word under the cursor (normal mode/insert/visual);".
\"\n        <Del> - Selects an area (normal mode/insert);".
\"\n".
\"\n    <F3> and then...".
\"\n      Note: Preferably for commands that \"traditionally\" involve|Ctrl|in other editors;".
\"\n        <n> - Open a new tab (normal mode/insert/visual);".
\"\n        <c> - Close current tab (normal mode/insert/visual);".
\"\n        <o> - Close all other tabs (normal mode/insert/visual);".
\"\n        <v> - Opens the file|.vimrc|(normal mode/insert/visual);".
\"\n        <r> - Reloads the file|.vimrc|in all tabs (normal mode/insert/visual);".
\"\n       |</>|- Removes search highlights (normal mode/insert/visual);".
\"\n        <s> - Save to disk (normal mode/insert/visual);".
\"\n        <f> - Opens for search (normal mode/insert/visual);".
\"\n        <d> - Opens to configure the search (normal mode/insert/visual);".
\"\n        <j> - Opens to replace (normal mode/insert/visual);".
\"\n        <h> - Opens to configure the replace (normal mode/insert/visual);".
\"\n       |<[>|- Saves the current session (normal mode/insert/visual);".
\"\n       |<]>|- Reloads the last saved session (normal mode/insert/visual);".
\"\n        <p> - Copies to the clipboard the name or path and name of the current buffer/file (normal mode/insert/visual);".
\"\n        <t> - Allows always returning to a particular tab using <Alt-Down> (normal mode/insert/visual);".
\"\n        <End> - Select and search the word under the cursor (case sensitive) (normal mode/insert/visual);".
\"\n        <Del> - Reselect area (normal mode/insert/visual);".
\"\n        <y> - Save to disk and open in a new tab a copy of the current file (normal mode/insert/visual);".
\"\n".
\"\n    <F4> and then...".
\"\n      Note: Preferably to trigger the installed plugins and their functionalities;".
\"\n        <n> - Opens/closes the *NERDTree* (normal mode/insert/visual);".
\"\n".
\"\n * Integration with plugins~".
\"\n".
\"\n   *Undone...*".
\"\n".
\"\n * Tasks/Pendings/Bugs~".
\"\n".
\"\n   *Undone...*".
\"\n".
\"\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n"

" Note: Para testar o help use: "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapḿargin=0 | set formatoptions+=l | set syntax=help"! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D

