" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" GrooVim =D - Vi IMproved'n'GrooVIed!
" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"LICENSE (Apache License "Version 2.0")
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"
"                                  Apache License
"                            Version 2.0, January 2004
"                         http://www.apache.org/licenses/
"
"    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
"
"    1. Definitions.
"
"       "License" shall mean the terms and conditions for use, reproduction,
"       and distribution as defined by Sections 1 through 9 of this document.
"
"       "Licensor" shall mean the copyright owner or entity authorized by
"       the copyright owner that is granting the License.
"
"       "Legal Entity" shall mean the union of the acting entity and all
"       other entities that control, are controlled by, or are under common
"       control with that entity. For the purposes of this definition,
"       "control" means (i) the power, direct or indirect, to cause the
"       direction or management of such entity, whether by contract or
"       otherwise, or (ii) ownership of fifty percent (50%) or more of the
"       outstanding shares, or (iii) beneficial ownership of such entity.
"
"       "You" (or "Your") shall mean an individual or Legal Entity
"       exercising permissions granted by this License.
"
"       "Source" form shall mean the preferred form for making modifications,
"       including but not limited to software source code, documentation
"       source, and configuration files.
"
"       "Object" form shall mean any form resulting from mechanical
"       transformation or translation of a Source form, including but
"       not limited to compiled object code, generated documentation,
"       and conversions to other media types.
"
"       "Work" shall mean the work of authorship, whether in Source or
"       Object form, made available under the License, as indicated by a
"       copyright notice that is included in or attached to the work
"       (an example is provided in the Appendix below).
"
"       "Derivative Works" shall mean any work, whether in Source or Object
"       form, that is based on (or derived from) the Work and for which the
"       editorial revisions, annotations, elaborations, or other modifications
"       represent, as a whole, an original work of authorship. For the purposes
"       of this License, Derivative Works shall not include works that remain
"       separable from, or merely link (or bind by name) to the interfaces of,
"       the Work and Derivative Works thereof.
"
"       "Contribution" shall mean any work of authorship, including
"       the original version of the Work and any modifications or additions
"       to that Work or Derivative Works thereof, that is intentionally
"       submitted to Licensor for inclusion in the Work by the copyright owner
"       or by an individual or Legal Entity authorized to submit on behalf of
"       the copyright owner. For the purposes of this definition, "submitted"
"       means any form of electronic, verbal, or written communication sent
"       to the Licensor or its representatives, including but not limited to
"       communication on electronic mailing lists, source code control systems,
"       and issue tracking systems that are managed by, or on behalf of, the
"       Licensor for the purpose of discussing and improving the Work, but
"       excluding communication that is conspicuously marked or otherwise
"       designated in writing by the copyright owner as "Not a Contribution."
"
"       "Contributor" shall mean Licensor and any individual or Legal Entity
"       on behalf of whom a Contribution has been received by Licensor and
"       subsequently incorporated within the Work.
"
"    2. Grant of Copyright License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       copyright license to reproduce, prepare Derivative Works of,
"       publicly display, publicly perform, sublicense, and distribute the
"       Work and such Derivative Works in Source or Object form.
"
"    3. Grant of Patent License. Subject to the terms and conditions of
"       this License, each Contributor hereby grants to You a perpetual,
"       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
"       (except as stated in this section) patent license to make, have made,
"       use, offer to sell, sell, import, and otherwise transfer the Work,
"       where such license applies only to those patent claims licensable
"       by such Contributor that are necessarily infringed by their
"       Contribution(s) alone or by combination of their Contribution(s)
"       with the Work to which such Contribution(s) was submitted. If You
"       institute patent litigation against any entity (including a
"       cross-claim or counterclaim in a lawsuit) alleging that the Work
"       or a Contribution incorporated within the Work constitutes direct
"       or contributory patent infringement, then any patent licenses
"       granted to You under this License for that Work shall terminate
"       as of the date such litigation is filed.
"
"    4. Redistribution. You may reproduce and distribute copies of the
"       Work or Derivative Works thereof in any medium, with or without
"       modifications, and in Source or Object form, provided that You
"       meet the following conditions:
"
"       (a) You must give any other recipients of the Work or
"           Derivative Works a copy of this License; and
"
"       (b) You must cause any modified files to carry prominent notices
"           stating that You changed the files; and
"
"       (c) You must retain, in the Source form of any Derivative Works
"           that You distribute, all copyright, patent, trademark, and
"           attribution notices from the Source form of the Work,
"           excluding those notices that do not pertain to any part of
"           the Derivative Works; and
"
"       (d) If the Work includes a "NOTICE" text file as part of its
"           distribution, then any Derivative Works that You distribute must
"           include a readable copy of the attribution notices contained
"           within such NOTICE file, excluding those notices that do not
"           pertain to any part of the Derivative Works, in at least one
"           of the following places: within a NOTICE text file distributed
"           as part of the Derivative Works; within the Source form or
"           documentation, if provided along with the Derivative Works; or,
"           within a display generated by the Derivative Works, if and
"           wherever such third-party notices normally appear. The contents
"           of the NOTICE file are for informational purposes only and
"           do not modify the License. You may add Your own attribution
"           notices within Derivative Works that You distribute, alongside
"           or as an addendum to the NOTICE text from the Work, provided
"           that such additional attribution notices cannot be construed
"           as modifying the License.
"
"       You may add Your own copyright statement to Your modifications and
"       may provide additional or different license terms and conditions
"       for use, reproduction, or distribution of Your modifications, or
"       for any such Derivative Works as a whole, provided Your use,
"       reproduction, and distribution of the Work otherwise complies with
"       the conditions stated in this License.
"
"    5. Submission of Contributions. Unless You explicitly state otherwise,
"       any Contribution intentionally submitted for inclusion in the Work
"       by You to the Licensor shall be under the terms and conditions of
"       this License, without any additional terms or conditions.
"       Notwithstanding the above, nothing herein shall supersede or modify
"       the terms of any separate license agreement you may have executed
"       with Licensor regarding such Contributions.
"
"    6. Trademarks. This License does not grant permission to use the trade
"       names, trademarks, service marks, or product names of the Licensor,
"       except as required for reasonable and customary use in describing the
"       origin of the Work and reproducing the content of the NOTICE file.
"
"    7. Disclaimer of Warranty. Unless required by applicable law or
"       agreed to in writing, Licensor provides the Work (and each
"       Contributor provides its Contributions) on an "AS IS" BASIS,
"       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
"       implied, including, without limitation, any warranties or conditions
"       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
"       PARTICULAR PURPOSE. You are solely responsible for determining the
"       appropriateness of using or redistributing the Work and assume any
"       risks associated with Your exercise of permissions under this License.
"
"    8. Limitation of Liability. In no event and under no legal theory,
"       whether in tort (including negligence), contract, or otherwise,
"       unless required by applicable law (such as deliberate and grossly
"       negligent acts) or agreed to in writing, shall any Contributor be
"       liable to You for damages, including any direct, indirect, special,
"       incidental, or consequential damages of any character arising as a
"       result of this License or out of the use or inability to use the
"       Work (including but not limited to damages for loss of goodwill,
"       work stoppage, computer failure or malfunction, or any and all
"       other commercial damages or losses), even if such Contributor
"       has been advised of the possibility of such damages.
"
"    9. Accepting Warranty or Additional Liability. While redistributing
"       the Work or Derivative Works thereof, You may choose to offer,
"       and charge a fee for, acceptance of support, warranty, indemnity,
"       or other liability obligations and/or rights consistent with this
"       License. However, in accepting such obligations, You may act only
"       on Your own behalf and on Your sole responsibility, not on behalf
"       of any other Contributor, and only if You agree to indemnify,
"       defend, and hold each Contributor harmless for any liability
"       incurred by, or claims asserted against, such Contributor by reason
"       of your accepting any such warranty or additional liability.
"
"    END OF TERMS AND CONDITIONS
"
"    APPENDIX: How to apply the Apache License to your work.
"
"       To apply the Apache License to your work, attach the following
"       boilerplate notice, with the fields enclosed by brackets "[]"
"       replaced with your own identifying information. (Don't include
"       the brackets!)  The text should be enclosed in the appropriate
"       comment syntax for the file format. We also recommend that a
"       file or class name and description of purpose be included on the
"       same "printed page" as the copyright notice for easier
"       identification within third-party archives.
"
"    Copyright 2014 Eduardo Lúcio Amorim Costa
"
"    Licensed under the Apache License, Version 2.0 (the "License");
"    you may not use this file except in compliance with the License.
"    You may obtain a copy of the License at
"
"        http://www.apache.org/licenses/LICENSE-2.0
"
"    Unless required by applicable law or agreed to in writing, software
"    distributed under the License is distributed on an "AS IS" BASIS,
"    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
"    See the License for the specific language governing permissions and
"    limitations under the License.

let g:grooVimVersion = "v2.0.8b"
" Eduardo Lúcio
" 2014

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"TASK LIST/BUGS LIST
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" ToDo: Disponibilizar a busca "por palavra inteira apenas"! Questor

" ToDo: GroovyMove está com problemas (para arquivos *.py) no insert/visual (perde o virtual edit)! Questor

" ToDo: Criar um esquema de configuração de acordo com o tipo de arquivo e que
" fique no final deste .vimrc! Questor

" ToDo: For python using 4 tab spaces (testar)? Questor

" ToDo: Usar python scripts? Questor

" ToDo: Visual block -> GroovyMove problem! Questor

" ToDo: "Limpar" e "organizar" o código (testar)! By Questor

" ToDo: Atualizar o help (OK)! By Questor

" ToDo: Save a copy and open that (testar)! By Questor

" ToDo: Funcionalidade para reselecionar a última seleção do visual mode (testar)! By Questor

" ToDo: Ctrl+k,j,... (move-vim) no normal mode (testar)! By Questor

" ToDo: A recuperação da área de transferência está dando problema para o
" replace (testar)! By Questor

" ToDo: Replace quando o pathern tem várias linhas? By Questor

" ToDo: "F3+End" não funciona no insert mode! Deve ser case sensitive (testar)! By Questor

" ToDo: "Forçar" um fundo negro (cancelado)? By Questor

" ToDo: Cor do cursor na movimentação "GroovyMove" no insert mode (cancelado)! By Questor

" ToDo: Mensagem "Search hit botton!" na lista de pesquisa? By Questor

" ToDo: Sempre ficar no final da tab (linhas vazias, normal mode) (testar)! By Questor

" ToDo: Improve syntax and lexers (mainly python)! By Questor

" ToDo: A pesquisa com lista não está brilhando as ocorrências (testar)! By Questor

" ToDo: Ao desabilitar a pesquisa por lista, se houver lista aberta esta não
" fecha se for disparado novamente "F3 -> f" (testar)! By Questor

" ToDo: "set expandtab" X "set listchars=tab:▒░,trail:·" problem! By Questor

" ToDo: Criar configuração parametrizável para cada distribuição (extensível ao help)! By Questor

" ToDo: Colocar atalho de contexto no OS (sergundo botão do mouse e também abrir com duplo click)! By Questor

" ToDo: Replace a partir de determinada posição (o replace padrão é à partir
" do começo do arquivo)! -> Colocar como opcional (testar)! By Questor

" ToDo: Enter qdo última linha e 1 coluna cria nova linha abaixo (não consegui reproduzir) (Esse comportamento está de acordo
" com características do arquivo mas não consegui delimitar as causas)! By Questor

" ToDo: Show cursor position (blink a "scope")? By Questor

" ToDo: Melhorar a apresentação das abas das tabs? Barra de rolagem? By Questor

" ToDo: Permitir todas funcionalidades para "virtualedit=all"? By Questor

" ToDo: Voltar para a primeira de todas as posições após um replace? By Questor

" ToDo: Tratar problema de lentidão com linhas longas! By Questor

" ToDo: Criar verificação do sistema operacional para os comandos que
" dependem dele! By Questor

" ToDo: Criar comando que desabilita totalmente o GrooVim! By Questor

" ToDo: Rever os comandos dependentes de learderkey? By Questor

" ToDo: Mapear setas (apenas referência dos commandos) (colocar no HELP)! By Questor

" ToDo: Mark line and navigate (bookmarks?)(mark.vim?)! By Questor

" ToDo: Toogle area "" TEXT AREA {{{ }}}"! By Questor

" ToDo: Traduzir a documentação para inglês! By Questor

" ToDo: Testar para outras distribuições! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"MAIN
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"FILE SYNTAX ASSOCIATIONS AND SPECIFIC CONFIGURATION
"$$$$$$$$$$$$$

" Note: General tab conf! By Questor

" Note: Size of a hard tabstop! By Questor
set tabstop=2

" Note: Size of an "indent"! By Questor
set shiftwidth=2

" Note: A combination of spaces and tabs are used to simulate tab stops at a width
" other than the (hard) tabstop! By Questor
set softtabstop=2

" Note: General tab conf! By Questor
func! SpecificTabConf(tabWidth)

	" Note: Size of a hard tabstop! By Questor
	exec "set tabstop=" . a:tabWidth

	" Note: Size of an "indent"! By Questor
	exec "set shiftwidth=" . a:tabWidth

	" Note: A combination of spaces and tabs are used to simulate tab stops at a width
	" other than the (hard) tabstop! By Questor
	exec "set softtabstop=" . a:tabWidth

endfun

"  * .inc

autocmd! BufReadPost *.inc set syntax=html | set filetype=html

"  * .gds

autocmd! BufReadPost *.gds set syntax=vb | set filetype=vb

"  * .py

autocmd! BufReadPost *.py call SpecificTabConf(4)

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENABLE PLUGINS
"$$$$$$$$$$$$$

" Note: Enable all plugins! By Questor
let g:enable_all_plugins = 1

" Note: tcomment.vim! By Questor
let g:enable_tcomment_vim = 1

" Note: nerdtree.vim! By Questor
let g:enable_nerdtree_vim = 1

" Note: debugger.vim! By Questor
let g:enable_debugger_vim = 1

" Note: move.vim! By Questor
let g:enable_move_vim = 1

"$$$$$$$$$$$$$$$$$$$$$$$$$$

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"PERFORMANCE
"$$$$$$$$$$$$$

" Note: You got a fast terminal! By Questor
set ttyfast

" Note: Aumentar a velocidade do scroll! By Questor
set ttyscroll=3

" Note: Remover efeitos do cursor para aumentar o desempenho! By Questor
set nocursorcolumn
set nocursorline

" Note: Limitar o alcance da sintaxe em linhas muito longas! By Questor
set synmaxcol=1000

" Note: Don't redraw while executing macros (good performance config)!
" Causes scroll "flickering"! By Questor
" set lazyredraw

"$$$$$$$$$$$$$$$$$$$$$$$$$$
"GENERAL BEHAVIOR
"$$$$$$$$$$$$$"

" Note: Use vim settings, rather then vi settings (much better!)! This must be 
" first, because it changes other options as a side effect! By Questor
set nocompatible

" Note: Habilita o "pathogen"! By Questor
" Note: Force reloading *after* pathogen loaded! Trying avoid override! By Questor
filetype plugin indent on
execute pathogen#infect()
execute pathogen#helptags()

" Note: Habilita o mouse! By Questor
set mouse=a

" Note: Evita problemas de compatibilidade quando se vai copiar para à aplicação
" externa! By Questor
if has('unnamedplus')
	set clipboard=unnamedplus
else
	set clipboard=unnamed
endif

" Note: Don't create swap files! By Questor
set noswapfile

" Note: Solve read only problem! Some files opens as read only! By Questor
set ma

" Note: Highlight your search matches! By Questor
" set hlsearch
" set nohlsearch

" Note: Permite uma coluna à mais no final da linha! By Questor
set virtualedit=onemore

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"SHORTCUTS (AND REMOVE VIM STUPID BEHAVIOR)
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Swap : and ; to make colon commands easier to type! By Questor
nnoremap  ;  :
nnoremap  :  ;
" Note: Importante para a execução de determinados comandos em algumas
" funcionalidades! By Questor
let g:cmdLineCaller = ";"

nnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"l\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"d\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"u\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")
nnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":call GrooVim_GroovyMove(\"n\", \"r\", 0, 0)<cr>" : ":let g:onMoveScreen = 1<cr>")

" Note: A variável ":let g:onMoveScreen = 1<cr>" é setada em outra
" oportunidade para o visual mode! Questor
vnoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"l\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"d\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"u\", 0, 0)<cr>" : "")
vnoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? ":<C-u>call GrooVim_GroovyMove(\"v\", \"r\", 0, 0)<cr>" : "")

inoremap <silent> <expr> <A-S-Left> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"l\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Down> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"d\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Up> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"u\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")
inoremap <silent> <expr> <A-S-Right> (g:GrooVim_GroovyMoveEnabled ? "<C-o>:call GrooVim_GroovyMove(\"i\", \"r\", 0, 0)<cr>" : "<C-o>:let g:onMoveScreen = 1<cr>")

nnoremap <silent> <PageDown> :call GrooVim_GroovyMove("n", "d", 1, 0)<cr>
nnoremap <silent> <PageUp> :call GrooVim_GroovyMove("n", "u", 1, 0)<cr>

vnoremap <silent> <PageDown> :<C-u>call GrooVim_GroovyMove("v", "d", 1, 0)<cr>
vnoremap <silent> <PageUp> :<C-u>call GrooVim_GroovyMove("v", "u", 1, 0)<cr>

inoremap <silent> <PageDown> <C-o>:call GrooVim_GroovyMove("i", "d", 1, 0)<cr>
inoremap <silent> <PageUp> <C-o>:call GrooVim_GroovyMove("i", "u", 1, 0)<cr>

nnoremap <silent> <C-A-Left> :call GrooVim_GroovyMove("n", "l", 0, 1)<cr>
nnoremap <silent> <C-A-Down> :call GrooVim_GroovyMove("n", "d", 0, 1)<cr>
nnoremap <silent> <C-A-Up> :call GrooVim_GroovyMove("n", "u", 0, 1)<cr>
nnoremap <silent> <C-A-Right> :call GrooVim_GroovyMove("n", "r", 0, 1)<cr>

vnoremap <silent> <C-A-Left> :<C-u>call GrooVim_GroovyMove("v", "l", 0, 1)<cr>
vnoremap <silent> <C-A-Down> :<C-u>call GrooVim_GroovyMove("v", "d", 0, 1)<cr>
vnoremap <silent> <C-A-Up> :<C-u>call GrooVim_GroovyMove("v", "u", 0, 1)<cr>
vnoremap <silent> <C-A-Right> :<C-u>call GrooVim_GroovyMove("v", "r", 0, 1)<cr>

inoremap <silent> <C-A-Left> <C-o>:call GrooVim_GroovyMove("i", "l", 0, 1)<cr>
inoremap <silent> <C-A-Down> <C-o>:call GrooVim_GroovyMove("i", "d", 0, 1)<cr>
inoremap <silent> <C-A-Up> <C-o>:call GrooVim_GroovyMove("i", "u", 0, 1)<cr>
inoremap <silent> <C-A-Right> <C-o>:call GrooVim_GroovyMove("i", "r", 1, 1)<cr>

" Note: Permite movimentação fluida da tela! By Questor
let g:onMoveScreen = 0
let g:GrooVim_GroovyMoveType = 0
let g:cursorHoldVisualExec = ""
let g:cursorHoldVisual = 0
let g:GrooVim_GroovyMoveEnabled = 1
func! GrooVim_GroovyMove(mod, direction, blockSmoothness, GrooVim_GroovyMoveType) range

	let g:GrooVim_GroovyMoveEnabled = 0

	if a:blockSmoothness == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0 && a:GrooVim_GroovyMoveType == 0
		call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
	endif

	if &virtualedit == "onemore"
		set virtualedit=all
	endif

	let l:disableSmoothness = 0
	let l:disableHorizontalSmoothness = 0
	let l:horizontalSmoothnessFactor = 2
	let l:verticalSmoothnessFactor = 10

	if a:GrooVim_GroovyMoveType == 0
		let l:horizontalMovementFactor = 20
		let l:verticalMovementFactor = 15
	elseif a:GrooVim_GroovyMoveType == 1
		let l:horizontalMovementFactor = 1
		let l:verticalMovementFactor = 1
	endif

	if a:mod == "n" || a:mod == "i"

		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

	elseif a:mod == "v"

		exec "norm gv"
		if a:direction == "l"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Left>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "d"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Down>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "u"
			for i in range(1, l:verticalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0
					exec "sleep " . l:verticalSmoothnessFactor . "m"
				endif
				exec "norm \<Up>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		elseif a:direction == "r"
			for i in range(1, l:horizontalMovementFactor)
				if a:blockSmoothness == 0 && l:disableSmoothness == 0 && l:disableHorizontalSmoothness == 0
					exec "sleep " . l:horizontalSmoothnessFactor . "m"
				endif
				exec "norm \<Right>"
				if a:blockSmoothness == 0
					redraw
				endif
			endfor
		endif

		" Note: Esse workaround serve para que o visual mode use o evento 
		" "CursorHold" o que só é possível no normal mode! By Questor
		let g:cursorHoldVisualExec = "call GrooVim_GroovyMoveAdjuster(\"" . a:direction . "\", " . a:blockSmoothness . ", " . l:disableSmoothness . ", " . l:verticalSmoothnessFactor . ")"
		let g:cursorHoldVisual = 1
		exec "norm \<Esc>"

	endif

	let g:onMoveScreen = 1

	" Note: "set virtualedit=onemore" se a área já for válida! By Questor
	if virtcol('.') <= virtcol('$')

		if &virtualedit == "all"
			set virtualedit=onemore
		endif

		if a:direction == "r" && a:mod != "v"
			call GrooVim_GroovyMoveAdjuster(a:direction, a:blockSmoothness, l:disableSmoothness, l:verticalSmoothnessFactor)
		endif

	endif

endfunc

func! GrooVim_GroovyMoveAdjuster(direction, blockSmoothness, disableSmoothness, verticalSmoothnessFactor) range

	let l:lineNow = getline(".")
	let l:lineSplited = split(l:lineNow, '\zs')

	if len(l:lineSplited) >= 1 && len(l:lineSplited) > (col(".") - 1)

		if l:lineSplited[col(".") - 1] == "	"

			if a:blockSmoothness == 0 && a:disableSmoothness == 0
				exec "sleep " . a:verticalSmoothnessFactor . "m"
			endif

			let l:cursorPosInsert = getpos(".")
			" ldur
			if a:direction == "l"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			elseif a:direction == "r"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2] + 1, 0])
			elseif a:direction == "d" || a:direction == "u"
				call setpos('.', [l:cursorPosInsert[0], l:cursorPosInsert[1], l:cursorPosInsert[2], 0])
			endif

			if a:blockSmoothness == 0
				redraw
			endif

			let g:cursorHoldVisual = 0
			let g:onMoveScreen = 1

		endif

	endif

endfunc

nnoremap <silent> <A-End> :call GrooVim_SelWord("n", "r", 1)<cr>
nnoremap <silent> <A-Home> :call GrooVim_SelWord("n", "l", 1)<cr>
inoremap <silent> <A-End> <C-o>:call GrooVim_SelWord("i", "r", 1)<cr>
inoremap <silent> <A-Home> <C-o>:call GrooVim_SelWord("i", "l", 1)<cr>
nnoremap <silent> <script> <A-Left> :call GrooVim_SelWord("n", "l", 0)<cr>
inoremap <silent> <script> <A-Left> <C-o>:call GrooVim_SelWord("i", "l", 0)<cr>
vnoremap <silent> <script> <A-Left> :<C-u>call GrooVim_SelWord("v", "l", 0)<cr>
nnoremap <silent> <script> <A-Right> :call GrooVim_SelWord("n", "r", 0)<cr>
inoremap <silent> <script> <A-Right> <C-o>:call GrooVim_SelWord("i", "r", 0)<cr>
vnoremap <silent> <script> <A-Right> :<C-u>call GrooVim_SelWord("v", "r", 0)<cr>

" Note: Permite a seleção de palavras de forma rápida (para cópia ou deleção)! By Questor
func! GrooVim_SelWord(mod, direction, fullMove) range

	let l:wordMove = ""
	let l:wordMoveInsert = ""

	if a:direction == "l"
		if a:fullMove == 0
			let l:wordMove = "b"
		elseif a:fullMove == 1
			let l:wordMove = "0"
		endif
		let l:wordMoveInsert = "\<Left>"
	elseif a:direction == "r"
		if a:fullMove == 0
			let l:wordMove = "e"
		elseif a:fullMove == 1
			let l:wordMove = "$\<Left>"
		endif
	endif

	if a:mod == "v"
		exec "norm gv" . l:wordMove
	elseif a:mod == "i"
		if virtcol('.') == (virtcol('$') - 1)
			if a:direction == "r"
				exec "norm \<Esc>\<Down>0v" . l:wordMove
			else
				exec "norm \<Esc>v" . l:wordMove
			endif
		else
			exec "norm \<Esc>" . l:wordMoveInsert . "v" . l:wordMove
		endif
	elseif a:mod == "n"
		exec "norm v" . l:wordMove
	endif

endfunc

" Note: Permite ir ao final de fato da linha no normal modesendo um desdobramento
" de "set virtualedit=onemore"! By Questor
nnoremap <silent> <End> $<Right>

nnoremap <silent> <A-DOWN> :call GrooVim_TabToReturn()<cr>
inoremap <silent> <A-DOWN> <C-O>:call GrooVim_TabToReturn()<cr>
vnoremap <silent> <A-DOWN> :<C-U>call GrooVim_TabToReturn()<cr>v

" Note: Retornar para última tab em uso! By Questor
let g:lastTab = 1
autocmd! TabLeave * let g:lastTab = tabpagenr()

func! GrooVim_TabToReturn()
	if g:GrooVim_TabToReturnNumber == 0
		exe "tabn " . g:lastTab
	else
		if g:GrooVim_TabToReturnNumber == tabpagenr()
			exe "tabn " . g:lastTab
		else
			exe "tabn " . g:GrooVim_TabToReturnNumber
			" Note: "redraw" garante a exibição da mensagem! By Questor
			redraw
			echo "Tab to return is ENabled to this tab!"
		endif
	endif
endfunc

" Note: Permite retornar para um determinada tab sempre! By Questor
let g:GrooVim_TabToReturnNumber = 0
func! GrooVim_TabToReturnSet()
	if g:GrooVim_TabToReturnNumber == 0
		let g:GrooVim_TabToReturnNumber = tabpagenr()
		call GrooVim_GrooVimBarMsg("Tab to return was ENabled to this tab!", 4)
	else
		let g:GrooVim_TabToReturnNumber = 0
		call GrooVim_GrooVimBarMsg("Tab to return was DISabled!", 4)
	endif
endfunc

if g:enable_tcomment_vim == 1 && g:enable_all_plugins == 1
	nnoremap <silent> <A-Up> :exec "norm gcc"<cr>
	inoremap <silent> <A-Up> <C-o>:exec "norm gcc"<cr>
	vnoremap <silent> <A-Up> :<C-u>call GrooVim_VisualComment()<cr>
	" Note: Permite comentar a linha de forma simples e rápida! By Questor
	func! GrooVim_VisualComment() range
		" Note: Permite verificar se a seleção envolve mais de uma linha
		" comparando a linha "do começo" e "do final" da seleção! By Questor
		if   getpos("'<")[1] == getpos("'>")[1]
			exec "norm gcc"
		else
			exec "norm gv"
			exec "norm gc"
		endif
	endfunc
endif

let g:messagesHolder = ""
func! GrooVim_GetMessages()
	let g:messagesHolder = ""
	redir => g:messagesHolder
		silent exec "messages"
	redir end
endfunc

func! GrooVim_ReturnLastMessage()
	call GrooVim_GetMessages()
	let l:messagesHolderSplitted = split(g:messagesHolder, "\n")
	if len(l:messagesHolderSplitted) >= 1
		return [l:messagesHolderSplitted[len(l:messagesHolderSplitted) - 1], len(l:messagesHolderSplitted)]
	else
		return ["", 0]
	endif
endfunc

let g:lastMessageWorkaroundShowed = ""
let g:lastMessageWorkaroundShowedIndex = 0
func! GrooVim_ShowLastMessageWorkaround()

	let l:GrooVim_ReturnLastMessageReturn = GrooVim_ReturnLastMessage()

	if l:GrooVim_ReturnLastMessageReturn[0] != ""
		if l:GrooVim_ReturnLastMessageReturn[0] != g:lastMessageWorkaroundShowed || g:lastMessageWorkaroundShowed == "" || g:lastMessageWorkaroundShowedIndex < l:GrooVim_ReturnLastMessageReturn[1]

			let l:messageBlock = 1
			if l:GrooVim_ReturnLastMessageReturn[0] == "Messages maintainer: Bram Moolenaar <Bram@vim.org>"
			elseif l:GrooVim_ReturnLastMessageReturn[0] =~ "replace with" && l:GrooVim_ReturnLastMessageReturn[0] =~ "(y/n/a/q/l/"
			else
				let l:messageBlock = 0
			endif

			if l:messageBlock == 0

				let l:messageType = "n"
				try

					let l:messageNowToSplit = l:GrooVim_ReturnLastMessageReturn[0]
					let l:messageNowSplitted = split(l:messageNowToSplit[0:6], ": ")

					if len(l:messageNowSplitted) > 0

						let l:messageNowTreated = substitute(l:messageNowSplitted[0], "E", "", "")

						if l:messageNowTreated != 0
							" Note: As aspas servem para fazer com que o resultado de "str2nr" seja "transformado" em string! By Questor
							if l:messageNowTreated == "" . str2nr(l:messageNowTreated) . ""
								if type(str2nr(l:messageNowTreated)) == type(0)
									if l:messageNowTreated > 0 && l:messageNowTreated < 10000
										let l:messageType = "e"
									endif
								endif
							endif
						endif

						
					endif

				catch
					
				endtry

				if l:messageType == "e"
					echohl Error | echo l:GrooVim_ReturnLastMessageReturn[0] | echohl None
				elseif l:messageType == "n"
					echo l:GrooVim_ReturnLastMessageReturn[0]
				endif
			endif

		endif
	endif

	let g:lastMessageWorkaroundShowed = l:GrooVim_ReturnLastMessageReturn[0]
	let g:lastMessageWorkaroundShowedIndex = l:GrooVim_ReturnLastMessageReturn[1]

endfunc

" Note: Check if caps lock is on! By Questor
let g:GrooVim_CheckCapsLockReturn = 0
let g:GrooVim_CheckCapsLockLastExec = 0
let g:GrooVim_CheckCapsLockMsg = 0
func! GrooVim_CheckCapsLock() range

	" Note: Evitar o retorno de caracteres malucos quando na
	" execução desse comando! By Questor

	if (strftime("%Y%m%d%H%M%S") - g:GrooVim_CheckCapsLockLastExec) > 1 || g:GrooVim_CheckCapsLockLastExec == ""

		let l:result = system("xset -q | grep \"Caps Lock:   on\"")

		" Note: In terminal vim, prevent ghost echoing while running a shell command via system()! By Questor
		redraw!

		" Note: Reexibe a última menssagem para corrigir o efeito
		" "colateral" da execução de "redraw!"! By Questor
		call GrooVim_ShowLastMessageWorkaround()


		if l:result != ""
			" Note: To debug! By Questor
			if g:GrooVim_CheckCapsLockReturn == 0
				" Note: This warning have a special condition and only
				" disappears if capslock is off! When caps lock is on
				" any other message will be shown! By Questor
				call GrooVim_GrooVimBarMsg("((( CAPS LOCK IS ON, OH NO!!! =| )))", 0)
				let g:GrooVim_CheckCapsLockMsg = 1
			endif
			let g:GrooVim_CheckCapsLockReturn = 1
		else
			let g:GrooVim_CheckCapsLockReturn = 0
		endif
	endif

	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

endfunc

" Note: A exclamação em "autocmd!" evita redefinição do evento ao recarregar o
" .vimrc! By Questor

" Note: Garante o estado de "virtualedit" antes de qualquer edição! By Questor
autocmd! InsertEnter * call GrooVim_InsertEnterPerforms()
func! GrooVim_InsertEnterPerforms()
	if g:onMoveScreen == 0
		if &virtualedit == "all"
			set virtualedit=onemore
		endif
	endif
endfunc

" Note: Reposiciona o cursor no local correto ao sair do insert mode! By Questor
autocmd! InsertLeave * call GrooVim_InsertLeavePerforms()
func! GrooVim_InsertLeavePerforms()
	exec "norm `^"
endfunc

" Note: Garante o estado de "virtualedit" antes de qualquer edição! By Questor
autocmd! InsertCharPre * call GrooVim_InsertCharPrePerforms()
func! GrooVim_InsertCharPrePerforms()
	if &virtualedit == "all"
		set virtualedit=onemore
	endif
endfunc

" Note: Check caps lock status! By Questor
autocmd! CursorHold * call GrooVim_CheckCapsLockTimer()
autocmd! CursorHoldI * call GrooVim_CheckCapsLockTimer()
let g:reloadVimrc = 0
func! GrooVim_CheckCapsLockTimer()
	if g:onCursorMoved == 0 && g:onMoveScreen == 0

		call GrooVim_CheckCapsLock()
		if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:onMoveScreen == 0
			if (strftime("%Y%m%d%H%M%S") - g:GrooVim_GrooVimBarMsgMoment) > g:GrooVim_GrooVimBarMsgDuration
				call GrooVim_GrooVimBarMsg("", "")
			endif
		endif

	else
		let g:onMoveScreen = 0
		let g:GrooVim_GroovyMoveEnabled = 1
	endif

	" Note: Esse workaround serve para que o visual mode use o evento "CursorHold"! By Questor
	if g:cursorHoldVisual == 1
		exec "norm gv"
		if g:cursorHoldVisualExec != ""
			exec g:cursorHoldVisualExec
			let g:cursorHoldVisualExec = ""
		endif
		let g:cursorHoldVisual = 0
		let g:onMoveScreen = 1
	endif

	checktime
endfunc
" Note: Execution delay (in milliseconds)! By Questor
set updatetime=0

" Note: Esses eventos servem para permitir a movimentação da tela de forma simples e intuitiva! By Questor
autocmd! CursorMoved * call GrooVim_VimStatus()
autocmd! CursorMovedI * call GrooVim_VimStatus()
let g:lastMode = ""
let g:onCursorMoved = 0
let g:modeNow = ""
func! GrooVim_VimStatus()

	let g:onCursorMoved = 1
	if g:onMoveScreen == 0

" 		Note: Verifica o status do caps lock sempre que o vim muda de 
" 		modo ou se estiver no modo visual! By Questor

		let g:modeNow = mode()

		if g:modeNow != g:lastMode || g:modeNow == "v"
			" Note: Evita termos que acionar duas vêzes o
			" "GrooVim_GroovyMove" quando mudamos de modo! By Questor
			let g:GrooVim_GroovyMoveEnabled = 1
			call GrooVim_CheckCapsLock()
			if g:GrooVim_GrooVimBarMsgEnabled == 1 && g:GrooVim_CheckCapsLockReturn == 0 && g:GrooVim_CheckCapsLockMsg == 1
				call GrooVim_GrooVimBarMsg("", "")
				let g:GrooVim_CheckCapsLockMsg = 0
			endif
		endif

		" Note: When on visual-block mode allows select any area! By Questor
		if mode() != "\<C-v>"
			if &virtualedit == "all"
				set virtualedit=onemore
			endif
		endif

		let g:lastMode = g:modeNow

	endif
	let g:onCursorMoved = 0
endfunc

" Note: Serve para evitar o efeito colateral da verificação de acionamento Caps Lock! By Questor

nnoremap <silent> <ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <S-ScrollWheelUp> :call GrooVim_ScrollAdm("n", "u")<cr>
nnoremap <silent> <ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>
nnoremap <silent> <S-ScrollWheelDown> :call GrooVim_ScrollAdm("n", "d")<cr>

inoremap <silent> <ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <S-ScrollWheelUp> <C-o>:call GrooVim_ScrollAdm("i", "u")<cr>
inoremap <silent> <ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>
inoremap <silent> <S-ScrollWheelDown> <C-o>:call GrooVim_ScrollAdm("i", "d")<cr>

vnoremap <silent> <ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <S-ScrollWheelUp> :<C-u>call GrooVim_ScrollAdm("v", "u")<cr>
vnoremap <silent> <ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>
vnoremap <silent> <S-ScrollWheelDown> :<C-u>call GrooVim_ScrollAdm("v", "d")<cr>

func! GrooVim_ScrollAdm(mod, direction) range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
	let g:GrooVim_CheckCapsLockLastExec = strftime("%Y%m%d%H%M%S")

	if a:mod == "v"
		exec "norm gv"
	endif

	if a:direction == "u"
		exec "norm \<Up>\<Up>\<Up>"
	elseif a:direction == "d"
		exec "norm \<Down>\<Down>\<Down>"
	endif

	let g:onMoveScreen = 1
endfunc

" Note: Serve para evitar o efeito colateral da verificação de acionamento Caps Lock! By Questor
nnoremap <silent> <LeftMouse> :let g:onMoveScreen = 1<cr><LeftMouse>

nnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
inoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>
vnoremap <silent> <C-b> <Esc>:call GrooVim_SetVisualBlock()<cr><C-v>

" Note: Enter visual-block mode and allows select any area! By Questor
func! GrooVim_SetVisualBlock() range
	if &virtualedit == "onemore"
		set virtualedit=all
	endif
endfunc

" Note: Evita "acidentes" com a combinação "Ctrl+z"! "<Nop>" equivale a um
" comando "nulo"! By Questor
nnoremap <silent> <C-z> <Nop>
inoremap <silent> <C-z> <Nop>
vnoremap <silent> <C-z> <Nop>

" Note: Permite "undo"/"redo" no insert/normal mode de forma homogênea! By Questor
nnoremap <silent> <C-u> u

" Note: Permite undo de forma convencional no visual! By Questor
vnoremap <silent> <C-u> :<C-u>call GrooVim_VisualUndo()<cr>v
func! GrooVim_VisualUndo() range
	exec "norm u"
endfunc

" Note: Permite redo de forma convencional no visual! By Questor
vnoremap <silent> <C-r> :<C-u>call GrooVim_VisualRedo()<cr>v
func! GrooVim_VisualRedo() range
	exec "norm \<C-r>"
endfunc

" Note: Permite undo de forma convencional no insert! By Questor
inoremap <silent> <script> <C-u> <Esc><bar>:call GrooVim_InsertUndo()<cr>i
func! GrooVim_InsertUndo()
	exec "norm u"
endfunc

" Note: Permite redo de forma convencional no insert! By Questor
inoremap <silent> <script> <C-r> <Esc><bar>:call GrooVim_InsertRedo()<cr>i
func! GrooVim_InsertRedo()
	exec "norm \<C-r>"
endfunc

" Note: Space no modo normal! By Questor
noremap <silent> <script> <Space> :call GrooVim_SpaceOnNormalMode()<cr>

func! GrooVim_SpaceOnNormalMode()
	exec "norm i\<Space>"
endfunc

" Note: Movimentação mais ágil entre as janelas com Ctrl+w! By Questor
nnoremap <silent> <C-w> <C-w><C-w>
inoremap <silent> <C-w> <Esc><C-w><C-w>
vnoremap <silent> <C-w> <Esc><C-w><C-w>

" Note: Obtém o número de linhas da área de transferência atual! Questor
func! GrooVim_NumberOfLinesOnDefaultTransferArea()

	" Note: Get transfer area! By Questor
	let l:lastYank = @+
	let l:lastYankNumbOfLines = split(l:lastYank, "\n")
	" Note: Verifica quantas linhas tem! Questor
	return len(l:lastYankNumbOfLines)

endfunc

" Note: Permite o yank de uma linha sem o retorno de caracter! By Questor
nnoremap <silent> yy 0y$

nnoremap <silent> <script> p P`]<Right>
nnoremap <silent> <script> <C-v> P`]<Right>

" Note: Permite paste normal no insert mode (sem quebras de linha e sem
" precisar do "Shift") (Ctrl+v)! By Questor
inoremap <silent> <script> <C-v> <C-o>P<C-o>`]<Right>

" Note: Permite copiar para o insert mode de modo convencional (ciclo
" Ctrl-c/Ctrl-v) (não precisa do "Shift")! By Questor
vnoremap <silent> <C-x> di

" Note: Permite cortar para o insert mode de modo convencional (ciclo
" Ctrl-x/Ctrl-v) (não precisa do "Shift")! By Questor
vnoremap <silent> <C-c> yi

" Note: Delete and backspace without yank! By Questor
nnoremap d "_d
nnoremap x "_x
vnoremap x "_x

" Note: Paste without yank (visual mode)! By Questor
vnoremap <silent> <script> p "_dP`]<Right>
vnoremap <silent> <script> <C-v> "_dP`]<Right>

" Note: Movimentação "normal" com Ctrl+Right! By Questor
nmap <silent> <C-Right> e
imap <silent> <C-Right> <C-o>e<Right>
vmap <silent> <C-Right> e

" Note: Movimentação "normal" com Ctrl+Left! By Questor
nmap <silent> <C-Left> b
imap <silent> <C-Left> <C-o>b
vmap <silent> <C-Left> b

" Note: O parâmetro <script> impede que o mapeamento seja sobreescrito por algum plugin! By Questor

" Note: Permite que uso "multimodo" do enter (em qualquer tipo de arquivo)! By Questor
nnoremap <silent> <script> <Enter> :call GrooVim_NormalEnterOnNormalMode()<cr>
func! GrooVim_NormalEnterOnNormalMode()
	exec "norm i\<cr>\<Esc>"
endfunc

" Note: Normal backspace/delete para o visual mode! By Questor
vmap <silent> <script> <Backspace> "_x
vmap <silent> <script> <Del> "_d

" Note: Permite uso "multimodo" do backspace! By Questor
nmap <silent> <script> <Backspace> :call GrooVim_NormalBackspace()<cr>

func! GrooVim_NormalBackspace()

	let l:continue = 1

	if col(".") == 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\i")
		call feedkeys("\<Backspace>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if col(".") > 1 && l:continue == 1
		" call GrooVim_PauseExecution("A")
		call feedkeys("\<Left>")
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note:  Move to the next tab! By Questor
nnoremap <silent> <C-Up> :tabnext<cr>
inoremap <silent> <C-Up> <C-O>:tabnext<cr>
vnoremap <silent> <C-Up> :<C-U>tabnext<cr>v

" Note:  Move to the previous tab! By Questor
nnoremap <silent> <C-Down> :tabprevious<cr>
inoremap <silent> <C-Down> <C-O>:tabprevious<cr>
vnoremap <silent> <C-Down> :<C-U>tabprevious<cr>v

" Note: Permite que uso "multimodo" do del! By Questor
func! GrooVim_NormalDel()

	let l:continue = 1

	" Note: Esse workaround é necessário quando a linha é vazia para que seja eliminada! By Questor
	if getline(".") == "" && l:continue == 1
		call feedkeys("_dd")
		" call feedkeys("0")
		let l:continue = 0
	endif

	if col(".") == col("$") && l:continue == 1
		call feedkeys("\i")
		call feedkeys("\<Right>")
		call feedkeys("\<Del>")
		call feedkeys("\<Esc>")
		let l:continue = 0
	endif

	if l:continue == 1
		call feedkeys("\"_x")
		let l:continue = 0
	endif

endfunc

" Note: "Multimode" tab! By Questor
nnoremap <silent> <Tab> :call GrooVim_NormalTab()<cr>
" Note: Permite tab no normal mode quando a linha está vazia! B Questor
func! GrooVim_NormalTab()
	if col(".") == 1 && getline(".") == ""
		exec "normal i\<Tab>"
	else
		exec "normal >>"
		if len(split(getline("."), '\zs')) == col(".")
			exec "normal \<Right>"
		endif
	endif
endfunc

inoremap <silent> <S-Tab> <C-o><<
nnoremap <silent> <S-Tab> <<
vnoremap <silent> <Tab> >><Esc>gv
vnoremap <silent> <S-Tab> <<<Esc>gv

" Note: Quando sai do modo insert para o modo visual! By Questor
inoremap <silent> <S-Down> <Esc>v:<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: Sair do modo visual! Questor
vnoremap <silent> <S-Down> <Esc>:call GrooVim_VirtualEditAdjust()<cr>

" Note: Permite sair dos modos usando um segundo "<C-S-Up>" ou "<C-S-Down>"! By Questor
inoremap <silent> <S-Up> <Esc>:call GrooVim_VirtualEditAdjust()<cr>
nnoremap <silent> <S-Down> :call GrooVim_AdjustOnEnterVisualMode()<cr>v

" Note: O "case sensitive" do "<Esc>" tem influência aqui como tem para
" o "<Enter>"! By Questor
" Note: Permite ajustar o parâmetro "set virtualedit=onemore" ao sair do modo em
" que se está! By Questor
func! GrooVim_VirtualEditAdjust() range
	set virtualedit=onemore
endfunc

" Note: Entrar no insert mode de forma simples! By Questor
vnoremap <silent> <script> <S-Up> <Esc>i
nnoremap <silent> <script> <S-Up> i

" Note: Serve para que ao entrar no modo visual o vim ajuste o parâmetro
" "set virtualedit=onemore"! By Questor
nnoremap <silent> <script> v :<C-u>call GrooVim_AdjustOnEnterVisualMode()<cr>v
func! GrooVim_AdjustOnEnterVisualMode() range
	set virtualedit=onemore
endfunc

" Note: Like tabdo but restore the current tab! By Questor
let g:tryCathOnTabDo = 0
func! TabDo(command)
	let currTab=tabpagenr()
	if g:tryCathOnTabDo == 0
		exec "tabdo " . a:command
	elseif g:tryCathOnTabDo == 1
		try
			exec "tabdo " . a:command
		catch
		endtry
	endif
	exec "tabn " . currTab
endfunc
com! -nargs=+ -complete=command Tabdo call TabDo(<q-args>)

" Note: Select and search with a double click and z key otherwise select the
" word under cursor! By Questor
nnoremap <silent> <script> <2-Leftmouse> :call GrooVim_SelectNSearch(0, "n")<cr>
inoremap <silent> <script> <2-Leftmouse> <Esc>:call GrooVim_SelectNSearch(0, "i")<cr>
vnoremap <silent> <script> <2-Leftmouse> :<C-u>call GrooVim_SelectNSearch(0, "v")<cr>

func! GrooVim_SelectNSearch(type, mode) range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Set "hlsearch" if is off! By Questor
		if !&hlsearch
			" Note: Highlight search results! By Questor
			set hlsearch
		endif

		set noignorecase
		let l:initialPos = getpos(".")
		if a:type == 0
			exec "sleep 250m"
			let l:enableSearch = getchar(0)
			if l:enableSearch == "122"
				let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
				call feedkeys("/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			else
				call feedkeys("viw")
			endif
		elseif a:type == 1
			let l:pathern = GrooVim_EscapeSubstituteValueToSearch(expand("<cword>"))
			call feedkeys("\<Esc>/" . l:pathern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
			if a:mode == "i"
				call feedkeys("\<Esc>i")
			else
				" Note: Esse workaround serve para evitar que o cursor mova para a próxima ocorrência quando teclamos <Up> or <Down>! By Questor
				call feedkeys("\<Esc>i\<Esc>")
			endif
		endif

	endif
endfunc

" Note: Select a range based on first and last positions! By Questor
let g:lastCursorPos = [0,0]
let g:GrooVim_SelectRangeInitialize = 1
func! GrooVim_SelectRange(mod) range

	let l:selDirection = "nothing"
	if g:GrooVim_SelectRangeInitialize == 0 && a:mod == "i"
		let l:cursorPosInsert = getpos(".")
		if g:lastCursorPos[1] < l:cursorPosInsert[1]
			let l:selDirection = "lessMoreLine"
		elseif g:lastCursorPos[1] > l:cursorPosInsert[1]
			let l:selDirection = "moreLessLine"
		elseif g:lastCursorPos[1] == l:cursorPosInsert[1]
			if g:lastCursorPos[2] < l:cursorPosInsert[2]
				let l:selDirection = "lessMoreCol"
			elseif g:lastCursorPos[2] > l:cursorPosInsert[2]
				let l:selDirection = "moreLessCol"
			endif
		endif
	endif

	if g:GrooVim_SelectRangeInitialize == 1
		let g:lastCursorPos = getpos(".")
		let g:GrooVim_SelectRangeInitialize = 0
		echomsg "Beginning of the range selected!"
	elseif g:GrooVim_SelectRangeInitialize == 0
		let l:cursorPos = getpos(".")
		call setpos('.', g:lastCursorPos)
		if (l:selDirection == "moreLessLine" || l:selDirection == "moreLessCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		exec "norm v"
		call setpos('.', l:cursorPos)
		if (l:selDirection == "lessMoreLine" || l:selDirection == "lessMoreCol") && a:mod == "i"
			exec "norm \<Left>"
		endif
		let g:GrooVim_SelectRangeInitialize = 1
		echomsg "Range selected!"
	endif

endfunc

" Note: Atualiza uma opção se ela já existir ou a insere se não. Também cria o
" arquivo de configuração se ele não existir! By Questor
let g:optsTemp = []
func! GrooVim_OptsUpdate(valueToSearch, valueToReplace, persistently)

	let l:CoolAndVimOptsArrayUpdated = []

	let l:thisOptionDoesNotExistInTheConfiguration = 1

	if a:persistently == 0

		" Note: To update temporary options in all new tabs when necessary! By Questor
		for l:value in g:optsTemp
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		let g:optsTemp = l:CoolAndVimOptsArrayUpdated

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(g:optsTemp, a:valueToReplace)
		endif

		exec a:valueToReplace

	else

		if filereadable(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
			let l:CoolAndVimOptsArrayOriginal = readfile(expand('~/.vim/plugin/CoolAndVimOpts.vim'))
		endif

		let l:CoolAndVimOptsArrayUpdated = []
		for l:value in l:CoolAndVimOptsArrayOriginal
			if l:value =~ a:valueToSearch
				call add(l:CoolAndVimOptsArrayUpdated, a:valueToReplace)
				let l:thisOptionDoesNotExistInTheConfiguration = 0
				exec a:valueToSearch . a:valueToReplace
			else
				call add(l:CoolAndVimOptsArrayUpdated, l:value)
			endif
		endfor

		if l:thisOptionDoesNotExistInTheConfiguration == 1
			call add(l:CoolAndVimOptsArrayUpdated, l:value)
		endif

		call writefile(l:CoolAndVimOptsArrayUpdated, expand('~/.vim/plugin/CoolAndVimOpts.vim'))

	endif

endfunc

" Note: Configura a pesquisa e/ou o replace a depender dos parâmetros passados! By Questor
func! GrooVim_ConfigureSearchReplace(typeOfConfig) range

	let l:whileControl = 1

	if a:typeOfConfig == "search"
		echomsg "Configure Search (use empty for default or option now):"
	elseif a:typeOfConfig != "search"
		echomsg "Configure Search and Replace (use empty for default or option now):"
	endif

	let g:searchReplace_CaseSensitive = GrooVim_GetOptions("Case sensitive (replaced/search) [0[default]/1][now: \"" . g:searchReplace_CaseSensitive . "\" ]? ", [1,0], g:searchReplace_CaseSensitive)
	call GrooVim_OptsUpdate("let g:searchReplace_CaseSensitive =", "let g:searchReplace_CaseSensitive = " . g:searchReplace_CaseSensitive, 0)
	if g:searchReplace_CaseSensitive == 1
		echomsg " -> Case sensitive is enabled!"
		call GrooVim_OptsUpdate("set ignorecase", "set noignorecase", 0)
	else
		echomsg " -> Case sensitive is disabled!"
		call GrooVim_OptsUpdate("set noignorecase", "set ignorecase", 0)
	endif

	let g:searchReplace_InAllOpened = GrooVim_GetOptions("In all tabs (replace/search) [0[default]/1][now: \"" . g:searchReplace_InAllOpened . "\" ]? ", [1,0], g:searchReplace_InAllOpened)
	call GrooVim_OptsUpdate("let g:searchReplace_InAllOpened =", "let g:searchReplace_InAllOpened = " . g:searchReplace_InAllOpened, 0)
	if g:searchReplace_InAllOpened == 1
		echomsg " -> Replace/search in all tabs is enabled!"
	else
		echomsg " -> Replace/search in all tabs is disabled!"
	endif

	if a:typeOfConfig != "search"
		let g:configureGrooVim_EntertainmentReplace_Confirmation = GrooVim_GetOptions("Replace with confirmation [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_Confirmation . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_Confirmation)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_Confirmation =", "let g:configureGrooVim_EntertainmentReplace_Confirmation = " . g:configureGrooVim_EntertainmentReplace_Confirmation, 0)
		if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
			echomsg " -> Confirmation is enabled!"
		else
			echomsg " -> Confirmation is disabled!"
		endif
		let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = GrooVim_GetOptions("Ask the value to be replaced [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced =", "let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = " . g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced, 0)
		if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
			echomsg " -> The value to be replaced will be asked!"
		else
			echomsg " -> The value to be replaced will NOT be asked!"
		endif
		let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = GrooVim_GetOptions("Replace begin from current position [0/1[default]][now: \"" . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition . "\" ]? ", [1,0], g:configureGrooVim_EntertainmentReplace_FromCurrentPosition)
		call GrooVim_OptsUpdate("let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition =", "let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = " . g:configureGrooVim_EntertainmentReplace_FromCurrentPosition, 0)
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			echomsg " -> Replace begin from current position is enabled!"
		else
			echomsg " -> Replace begin from current position is disabled!"
		endif
	elseif a:typeOfConfig == "search"
		let g:search_Direction = GrooVim_GetOptions("Search forward/backyard [f[default]/b][now: \"" . g:search_Direction . "\" ]? ", ["f","b"], g:search_Direction)
		call GrooVim_OptsUpdate("let g:search_Direction =", "let g:search_Direction = \"" . g:search_Direction . "\"", 0)
		" Note: Necessário para inverter o sentido da busca! By Questor
		if g:search_Direction == "b"
			let g:grooVimSearchFoward = 0
		elseif g:search_Direction == "f"
			let g:grooVimSearchFoward = 1
		endif
		if g:search_Direction == "f"
			echomsg " -> Search forward is enabled!"
		else
			echomsg " -> Search backyard is enabled!"
		endif
		let g:search_WithList = GrooVim_GetOptions("Search with list [0[default]/1][now: \"" . g:search_WithList . "\" ]? ", [1,0], g:search_WithList)
		call GrooVim_OptsUpdate("let g:search_WithList =", "let g:search_WithList = \"" . g:search_WithList . "\"", 0)
		if g:search_WithList == 1
			echomsg " -> Search with list is enabled!"
		else
			echomsg " -> Search with list is disabled!"
		endif
	endif

endfunc

" Note: Get and validate a givem option! By Questor
func! GrooVim_GetOptions(optionToGet, possibleOptions, defaultOption) range
	let l:stopWhile = 0
	let l:optionReturn = ""
	while l:stopWhile == 0
		let l:optionReturn = input(a:optionToGet)
		let l:stopWhile = GrooVim_ValidateOptions(l:optionReturn, a:possibleOptions, a:defaultOption)
		if ("" . l:optionReturn . "") == ""
			let l:optionReturn = a:defaultOption
		endif
	endwhile
	return l:optionReturn
endfunc

" Note: Check if a given option is valid! By Questor
func! GrooVim_ValidateOptions(optionNow, possibleOptions, defaultOption) range
	for l:value in a:possibleOptions
		" Note: "("" . l:value . "")" -> To force string compare! By
		" Questor
		if ("" . l:value . "") == a:optionNow || (a:optionNow == "" && ("" . a:defaultOption . "") != "")
			return 1
		endif
	endfor
	return 0
endfunc

" Note: Highlight matches when jumping to next! This rewires n and N to do
" the highlighing the match in red! By Questor
nnoremap <silent> <expr> n ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'n' : 'N') : (g:grooVimSearchFoward ? 'N' : 'n')) . ":call GrooVim_HLNext(\"f\", 0.4, \"1\", 1)<cr>"
nnoremap <silent> <expr> N ":call GrooVim_HLNext(\"\", \"\", \"\", 0)<cr>" . (v:searchforward ? (g:grooVimSearchFoward ? 'N' : 'n') : (g:grooVimSearchFoward ? 'n' : 'N')) . ":call GrooVim_HLNext(\"b\", 0.4, \"0\", 1)<cr>"

let g:tabChanged = 0
let g:block_GrooVim_HLNext = 0
highlight WhiteOnRed ctermbg=red ctermfg=white
highlight WhiteOnBlue ctermbg=blue ctermfg=white
func! GrooVim_HLNext(moveType, blinkTime, searchMoveInverter, moment)

	let g:GrooVim_XenPlayRunningWithSearch = 1

	if g:block_GrooVim_HLNext == 0

		if a:moment == 0

			let g:cursor_pos_last = getpos(".")

		elseif a:moment == 1

			" * System (v:searchforward) is forward!
			if v:searchforward == 1
				" n -> forward
				" N -> backward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			" * System (v:searchforward) is backward!
			elseif v:searchforward == 0
				" n -> backward
				" N -> forward
				" * I want (g:grooVimSearchFoward) forward!
				if g:grooVimSearchFoward == 1
					" n -> N
					" N -> n
					" let l:searchMoveDirection = 1
					if a:moveType == "f"
						let l:searchMoveDirection = 1
					elseif a:moveType == "b"
						let l:searchMoveDirection = 0
					endif
				" * I want (g:grooVimSearchFoward) backward!
				elseif g:grooVimSearchFoward == 0
					" n -> n
					" N -> N
					" let l:searchMoveDirection = 0
					if a:moveType == "f"
						let l:searchMoveDirection = 0
					elseif a:moveType == "b"
						let l:searchMoveDirection = 1
					endif
				endif
			endif

			let [bufnum, lnum, col, off] = getpos('.')
			let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
			let target_pat = '\c\%#'.@/

			" Note: Foward -> blink: red/Backyard -> blink: blue! By Questor
			if l:searchMoveDirection == 1
				let ring = matchadd('WhiteOnRed', target_pat, 101)
			elseif l:searchMoveDirection == 0
				let ring = matchadd('WhiteOnBlue', target_pat, 101)
			endif

			redraw
			exec 'sleep ' . float2nr(a:blinkTime * 200) . 'm'
			call matchdelete(ring)
			redraw

			let l:cursor_pos_now = getpos(".")

			let l:tabChanged = 0

			if g:searchReplace_InAllOpened == 1
				if l:searchMoveDirection == 1 && l:cursor_pos_now[1] < g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabnext
				elseif l:searchMoveDirection == 0 && l:cursor_pos_now[1] > g:cursor_pos_last[1]
					let g:block_GrooVim_HLNext = 1
					let g:tabChanged = 1
					tabprev
				elseif l:cursor_pos_now[1] == g:cursor_pos_last[1] && l:cursor_pos_now[2] == g:cursor_pos_last[2]
					if l:searchMoveDirection == 1
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabnext
					elseif l:searchMoveDirection == 0
							let g:block_GrooVim_HLNext = 1
							let g:tabChanged = 1
							tabprev
					endif
				endif
			endif

			while g:tabChanged == 1

				" Note: Positioning in the correct window! By Questor

				call GrooVim_PutOnEditWindow()

				try
					if l:searchMoveDirection == 1
						exec "norm gg0n"
					elseif l:searchMoveDirection == 0
						exec "norm G$N"
					endif
					let g:block_GrooVim_HLNext = 0
					let g:tabChanged = 0
				catch
					if l:searchMoveDirection == 1
						tabnext
					elseif l:searchMoveDirection == 0
						tabprev
					endif
				endtry
			endwhile

		endif

	endif

endfunc


" Note: Define o tipo de pesquisa a ser executada a depender das opções do
" usuário! By Questor
let g:search_WithList = 0
func! GrooVim_SearchWithMyOptions(mod) range

	let l:callGrooVim_SearchGuy = 1

	" Note: Se a pesquisa com listas estiver ativada fecha as listas e permite
	" a execução da pesquisa apenas na próxima chamada! By Questor
	if g:GrooVim_SearchGuyEnabled == 1

		let g:matchedLinesGlobal = ""
		let g:matchedLinesGlobalNavArray = []
		let g:GrooVim_SearchGuyEnabled = 0
		let l:callGrooVim_SearchGuy = 0
		call TabDo("call GrooVim_SearchGuyPrepare()")

	endif

	if l:callGrooVim_SearchGuy == 1
		if g:search_WithList == 1
			call GrooVim_SearchGuy(a:mod)
		elseif g:search_WithList == 0
			call GrooVim_EasySearch(a:mod)
		endif
	endif

endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:search_Direction = "f"
let g:searchReplace_CaseSensitive = 0
let g:grooVimSearchFoward = 1
func! GrooVim_EasySearch(mod) range

	" Note: Set "hlsearch" if is off! By Questor
	if !&hlsearch
		" Note: Highlight search results! By Questor
		set hlsearch
	endif

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	" Note: Inicializar a pesquisa! By Questor
	let g:block_GrooVim_HLNext = 0

	let l:valueToSearch = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToSearch = @+
	else
		let l:valueToSearch = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	let l:valueToSearchTemp = ""

	let l:valueToSearchTemp = input("You want to use this value (use empty to yes)? \"" . GrooVim_SubstringToPrompt(l:valueToSearch) . "\": ")

	" Note: Define search pathern automatically! By Questor
	if l:valueToSearchTemp != ""
		let l:valueToSearch = l:valueToSearchTemp
	endif

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToSearch)
	let l:search_Operator = ""

	" Note: Select operation type! By Questor
	if g:search_Direction == "b" && g:grooVimSearchFowardBlock == 0
		let l:search_Operator = "?"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f" || g:grooVimSearchFowardBlock == 1
		let l:search_Operator = "/"
		let g:grooVimSearchFoward = 1
	endif

	" Note: Essa estrutura foi feita para que a pesquisa possa ser
	" executada "de imediato". Com o "feedkeys" acima isso não acontece,
	" ocasionando problemas de sincronia com funções que dependem que
	" função "GrooVim_EasySearch" rode primeiro! By Questor
	" Note: Funciona, mas não me permite "backward search" default! By Questor

	let @/ = l:pattern
	let l:initialPos = getpos(".")

	" Note: Essa operação está duplicada "feedkeys" e "exec" ocasionando
	" uma dupla execução da pesquisa, mas foi única forma de não ter
	" problemas na navegação com "n" e "N" e com a pesquisa com lista!
	" Se não for feito isso, o highlight é perdido após alguns movimentos
	" da seta! By Questor
	if g:search_WithList == 0
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>\<Esc>" . g:cmdLineCaller . "call setpos(\".\", [" . l:initialPos[0] . ", " . l:initialPos[1] . ", " . l:initialPos[2] . ", " . l:initialPos[3] . "])|redraw!\<cr>")
	else
		call feedkeys("\<Esc>" . l:search_Operator . l:pattern . "\<cr>")
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"d\"!", 4)

endfunc

" Note: Organiza as listas de ocorrência e navegação! By Questor
let g:matchedLines = ""
func! GrooVim_SearchGuyMatches(linePosition, lineValue, tab, bufferName, line, column) range
	if a:linePosition != ""
		let l:linePositionPrefix = "|" . a:linePosition . "|        "
		let g:matchedLines =  g:matchedLines . strpart(l:linePositionPrefix, 0, 8) . a:lineValue . "\n"
	else
		let g:matchedLines =  g:matchedLines . a:lineValue . "\n"
	endif
	if a:tab != "" && a:line != "" && a:column != ""
		call add(g:matchedLinesGlobalNavArray, a:tab . "," . a:bufferName . "," . a:line . "," . a:column)
	else
		call add(g:matchedLinesGlobalNavArray, "0")
	endif
endfunc

" Note: Executa a busca nas várias tabs criando as listas de ocorrências! By Questor
func! GrooVim_SearchGuyTraveler(mod) range

	let l:theresAMatch = 1

	try
		exec "norm gg0n"
	catch
		let l:theresAMatch = 0
	endtry

	if l:theresAMatch == 1

		let g:matchedLines = ""
		" let l:theresAMatch = 0
		let l:cur_pos_last = [0,0,0]

		if g:matchedLinesGlobal == ""
			call GrooVim_SearchGuyMatches("", "-------------------------------------------[ Search List ]-------------------------------------------", "", "", "", "")
		else
			call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------------------------------------", "", "", "", "")
		endif

		call GrooVim_SearchGuyMatches("", expand('%:p'), "", "", "", "")
		call GrooVim_SearchGuyMatches("", "-----------------------------------------------------------------------", "", "", "", "")

		while (getpos(".")[1] > l:cur_pos_last[1] || (getpos(".")[1] == l:cur_pos_last[1] && getpos(".")[2] > l:cur_pos_last[2])) && l:theresAMatch == 1
			let l:cur_pos_last = getpos(".")
			call GrooVim_SearchGuyMatches(getpos(".")[1], getline("."), tabpagenr(), expand('%:t'), getpos(".")[1], getpos(".")[2])
			exec "norm n"
		endwhile

		let g:matchedLinesGlobal = g:matchedLinesGlobal . g:matchedLines

	endif

endfunc

" Note: Searches for current selection or word under cursor. Esse é o método
" principal de controle da funcionalidade! By Questor
let g:matchedLinesGlobal = ""
let g:matchedLinesGlobalNavArray = []
let g:GrooVim_SearchGuyEnabled = 0
let g:grooVimSearchFowardBlock = 0
func! GrooVim_SearchGuy(mod) range

	" Note: Avoid search backward! By Questor
	let g:grooVimSearchFowardBlock = 1

	let l:searchMoveInverterHolder = getpos(".")

	let l:initialPos = getpos(".")

	call GrooVim_EasySearch(a:mod)

	let g:matchedLinesGlobal = ""
	let g:block_GrooVim_HLNext = 1
	let g:matchedLinesGlobalNavArray = []
	let g:GrooVim_SearchGuyEnabled = 0

	if g:searchReplace_InAllOpened == 1
		call TabDo("call GrooVim_SearchGuyTraveler(\"" . a:mod . "\")")
	else
		call GrooVim_SearchGuyTraveler(a:mod)
	endif

	let g:block_GrooVim_HLNext = 0
	let g:GrooVim_SearchGuyEnabled = 1

	call setpos(".", l:initialPos)

	call GrooVim_SearchGuySync()

	" Note: Esse "workaround" serve para evitar um efeito
	" colateral que ocorre na mudança de tab que é a perda do
	" hilight. A presença de redraw serve para apagar a exibição
	" da mensagem gerada por "set hlsearch"! By Questor
	" call feedkeys("\<Esc>" . g:cmdLineCaller . "set hlsearch\<cr>\<Esc>" . g:cmdLineCaller . "redraw!\<cr>")

	let g:grooVimSearchFowardBlock = 0

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

	call GrooVim_GrooVimBarMsg("Use Del or double click to navigate!", 4)

endfunc

" Note: Serve para sincronizar em várias tabs determinados "estados"! É executado 
" sempre que uma tab é acessada! By Questor
autocmd! TabEnter * call GrooVim_TabParadise()
func! GrooVim_TabParadise()
	" Note: Se houver uma lista de pesquisa, abre essa a lista na tab atual se a
	" funcionalidade estiver ativada! By Questor
	if g:GrooVim_SearchGuyEnabled == 1 && g:searchReplace_InAllOpened == 1
		call GrooVim_SearchGuySync()
	endif
endfunc

if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
	" Note: Abre e fecha o "Nerd Tree atravez do componente "vim-nerdtree-tabs"! By Questor
	let g:NERDTreeTabsOpen = 0
	func! GrooVim_ToggleNERDTreeTabs()
		if g:NERDTreeTabsOpen == 1
			exec "NERDTreeTabsClose"
			let g:NERDTreeTabsOpen = 0
		else
			exec "NERDTreeTabsOpen"
			let g:NERDTreeTabsOpen = 1

			" Note: Foco no Nerdtree quando abrir! By Questor
			let l:exitWhile = 0
			let l:firstBufferOnThisTab = expand('%:t')
			while ! (expand('%:t') =~ "NERD_tree_") && l:exitWhile == 0
				exec "norm \<C-w>"
				if expand('%:t') == l:firstBufferOnThisTab
					let l:exitWhile = 1
				endif
			endwhile

		endif
	endfunc
endif

" Note: Ao entrar em uma tab abre a lista de ocorrências se o search guy estiver
" acionado! By Questor
func! GrooVim_SearchGuySync()
	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 0

		call GrooVim_PutOnEditWindow()

		" Note: O "set ma" e "set noma" abre e bloqueia edição do 
		" buffer! By Questor
		set ma
		exec "set splitbelow"
		silent exec "split GrooVim_SearchGuyResults" . tabpagenr()
		exec "put =g:matchedLinesGlobal"
		set cursorline
		exec "norm ggdd"
		set noma
	endif
endfunc

" Note: Permite navegação nos resultados usando "Del"! By Questor
func! GrooVim_SearchGuyNavigate() range

	" Note: A navegação da lista é sempre para a frente para facilitar! By Questor
	let g:grooVimSearchFoward = 1

	let l:listPosLinCol = getpos(".")
	let l:listPosLinToArray = (l:listPosLinCol[1] - 1)
	if l:listPosLinToArray >= 0 && g:matchedLinesGlobalNavArray[l:listPosLinToArray] != 0

		exec "tabn " . split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[0]

		while !(expand('%:t') =~ "GrooVim_SearchGuyResults")
			exec "norm \<C-w>"
		endwhile

		set ma
		exec "norm ggdG"
		exec "put =g:matchedLinesGlobal"
		exec "norm ggdd"
		call setpos(".", l:listPosLinCol)
		exec "norm 0i->"
		set noma

		while expand('%:t') != split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[1]
			exec "norm \<C-w>"
		endwhile
		call setpos(".", [0, split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[2], split(g:matchedLinesGlobalNavArray[l:listPosLinToArray], ",")[3]])
		exec "norm \<Left>n"

	endif

	if g:search_Direction == "b"
		let g:grooVimSearchFoward = 0
	elseif g:search_Direction == "f"
		let g:grooVimSearchFoward = 1
	endif

endfunc

" Note: Prepara o "GrooVim_SearchGuy" para uma nova execução/fecha-o! By Questor
func! GrooVim_SearchGuyPrepare()

	if bufexists("GrooVim_SearchGuyResults" . tabpagenr()) == 1

		try
			" Note: Com essa abordagem eu consigo efetivamente "destruir" 
			" o buffer não retornando "falso" positivos no "bufexists" 
			" acima! By Questor
			exec "bwipeout! GrooVim_SearchGuyResults" . tabpagenr()
		catch
			
		endtry

	endif

endfunc

" Note: For debug purposes. To stop uses "0". Permite uma "parada" na linha em
" que é chamado e exibe uma menssagem! By Questor
func! GrooVim_PauseExecution(msg)
	echo "msg: \"" . a:msg . "\""
	while getchar() != 48
		exec "sleep 1000m"
	endwhile
endfunc

" Note: Permite que uso "multimodo" do enter! By Questor
vnoremap <buffer> <Enter>  "_x<bar>i<cr><Esc>

" Note: Seta o comportamento do Del a depender do contexto! By Questor
nnoremap <script> <Del> :call GrooVim_DelBehavior()<cr>
func! GrooVim_DelBehavior() range
	if expand('%:t') =~ "GrooVim_SearchGuyResults"
		call GrooVim_SearchGuyNavigate()
	else
		" Note: Permite que uso "multimodo" do del! By Questor
		call GrooVim_NormalDel()
	endif
endfunc

" Note: Treat a string and return a substring to use in prompts! By Questor
func! GrooVim_SubstringToPrompt(stringToBeTreated)
	let l:lineSplited = split(a:stringToBeTreated, "\n")
	let l:transferAreaToShow = ""
	try
		" if len(l:lineSplited) > 1
			if strlen(l:lineSplited[0]) > 70
				let l:transferAreaToShow = l:lineSplited[0][0:70] . "..."
			else
				if len(l:lineSplited) > 1
					let l:transferAreaToShow = l:lineSplited[0] . "..."
				else
					let l:transferAreaToShow = l:lineSplited[0]
				endif
			endif
	catch

	endtry
	return l:transferAreaToShow
endfunc

" Note: Searches for current selection or word under cursor! By Questor
let g:configureGrooVim_EntertainmentReplace_Confirmation = 1
let g:searchReplace_InAllOpened = 0
let g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced = 1
let g:configureGrooVim_EntertainmentReplace_FromCurrentPosition = 0
func! GrooVim_EntertainmentReplace(mod) range

	" Note: Set "ignorecase" if is off! By Questor
	if !&ignorecase && g:searchReplace_CaseSensitive == 0
		" Note: Case sensitive search! By Questor
		set ignorecase
	endif

	let l:valueToReplace = ""

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let l:saved_reg = @+
		" Note: Reselect visual area and yank! By Questor
		exec "norm gvy"
		let l:valueToReplace = @+
	else
		let l:valueToReplace = expand("<cword>")
	endif

	if a:mod == "v"
		" Note: Preserve transfer area! By Questor
		let @+ = l:saved_reg
	endif

	if g:configureGrooVim_EntertainmentReplace_AskTheValueToBeReplaced == 1
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToReplaceTemp = GrooVim_EscapeSubstituteValueToSearch(input("Value that will be REPLACED (empty to use \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\"): "))
			if ("" . l:valueToReplaceTemp . "") != "" || ("" . l:valueToReplace . "") != ""
				let l:stopWhile = 1
				if l:valueToReplaceTemp != ""
					let l:valueToReplace = l:valueToReplaceTemp
				endif
			endif
		endwhile
	endif

	let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(input("Value that will REPLACE \"" . GrooVim_SubstringToPrompt(l:valueToReplace) . "\" (empty to use transfer área value \"" . GrooVim_SubstringToPrompt(@+) . "\"): "))

	if l:valueThatWillReplace == ""
		" Note: "GrooVim_EscapeSubstituteValueToSearch()" não é necessário
		" quando o valor vem de "input()", pois este último já trata
		" isso! By Questor
		let l:valueThatWillReplace = GrooVim_EscapeSubstituteValueToSearch(@+)
	endif

	let l:valueThatWillReplace = l:valueThatWillReplace

	let l:pattern = GrooVim_EscapeSubstituteValueToSearch(l:valueToReplace)

	let l:confirmOrNot = ""

	if g:configureGrooVim_EntertainmentReplace_Confirmation == 1
		let l:confirmOrNot = "c"
	endif

	if a:mod == "v"
		exec "norm \<Left>"
	else
		exec "norm b\<Left>"
	endif

	if g:searchReplace_InAllOpened != 1
		if g:configureGrooVim_EntertainmentReplace_FromCurrentPosition == 1
			" Note: Replace begin from current position! By Questor
			exec ".,$s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		else
			exec "%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot
		endif
	else
		" Note: "let g:tryCathOnTabDo = 1" -> Caso não haja valor para replace em uma das tabs o processo
		" não levanta erro! By Questor
		let g:tryCathOnTabDo = 1
		call TabDo("%s#" . l:pattern . "#" . l:valueThatWillReplace . "#" . l:confirmOrNot)
		let g:tryCathOnTabDo = 0
	endif

	call GrooVim_GrooVimBarMsg("You could set me using \"F3\" and then \"h\"!", 4)

endfunc

func! GrooVim_EscapeSubstituteValueToSearch(valueToTreat)
	" Note: Create search pattern! By Questor
	let l:pattern = escape(a:valueToTreat, '\\/.*$^~[]')
	let l:pattern = substitute(l:pattern, "\n$", "", "")
	return l:pattern
endfunc

" Note: Workaround para obter milisegundos! By Questor
func! GrooVim_GetMilliseconds()
	let l:format = "+%s%3N"
	let l:cmd = "/bin/date -u " . shellescape(format)
	" Note: É "let fakeHolder = getchar(0)" uma tentativa de evitar o retorno de caracteres malucos quando na
	" execução desse comando! By Questor
	let l:result = substitute(system(cmd), "[\]\|[[:cntrl:]]", "", "g")
	return l:result
endfunc

" Note: Permite um "super leader" que é acionado em qualquer modo!
" Com essa abordagem eu, também, consigo mapear uma quantidade muito
" maior de teclas! Note o uso das teclas z, a e t nos leader commands
" necessários para certos worarounds! By Questor

nnoremap <silent> <script> <F2> :call GrooVim_CommandZ("F2", "n")<cr>
inoremap <silent> <script> <F2> <C-o>:call GrooVim_CommandZ("F2", "i")<cr>
vnoremap <silent> <script> <F2> :<C-u>call GrooVim_CommandZ("F2", "v")<cr>

nnoremap <silent> <script> <F3> :call GrooVim_CommandZ("F3", "n")<cr>
inoremap <silent> <script> <F3> <C-o>:call GrooVim_CommandZ("F3", "i")<cr>
vnoremap <silent> <script> <F3> :<C-u>call GrooVim_CommandZ("F3", "v")<cr>

nnoremap <silent> <script> <F4> :call GrooVim_CommandZ("F4", "n")<cr>
inoremap <silent> <script> <F4> <C-o>:call GrooVim_CommandZ("F4", "i")<cr>
vnoremap <silent> <script> <F4> :<C-u>call GrooVim_CommandZ("F4", "v")<cr>

nnoremap <silent> <script> <F5> :call GrooVim_CommandZ("F5", "n")<cr>
inoremap <silent> <script> <F5> <C-o>:call GrooVim_CommandZ("F5", "i")<cr>
vnoremap <silent> <script> <F5> :<C-u>call GrooVim_CommandZ("F5", "v")<cr>

nnoremap <silent> <script> <F5> :norm q<cr>

" Tip: Try to "balance" the distribution of the keys to preserve your
" hands! By Questor

let g:GrooVim_CommandZMoment = 0
let g:GrooVim_CommandZChar = ""
let g:GrooVim_CommandZUnblock = 1
let g:GrooVim_CommandZFCaller = ""
func! GrooVim_CommandZ(GrooVim_CommandZFCallerNow, modType)

	let l:GrooVim_CommandZNowChar = ""
	" Note: Essa lógica permite a reexecução do último comando apenas
	" usando uma tecla F(1, 2, 3...). Se houver um mesmo F? em menos de um
	" segundo, o último comando é executado sem esperar que seja informada
	" uma nova tecla para compor o comando. Se for mais de um segundo aguarda
	" uma nova tecla e se não houver reexecuta o último comando! Sempre
	" que uma F? diferente da última for acionada o Vim ficará aguardando
	" uma techa para compor o comando e nada fará enquanto está não for
	" informada! By Questor

	" Note: O "strftime("%Y%m%d%H%M%S")" não retorna milisegundos e por
	" isso foi substituído! By Questor

	let l:GrooVim_CommandZMomentNow = GrooVim_GetMilliseconds()

	" Note: In terminal vim, prevent ghost echoing while running a shell command via system()! By Questor
	redraw!

	if (l:GrooVim_CommandZMomentNow - g:GrooVim_CommandZMoment) > 400 || g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow
		exec "sleep 400m"
		let l:GrooVim_CommandZNowChar = getchar(0)
		if l:GrooVim_CommandZNowChar != "" && l:GrooVim_CommandZNowChar != "\<f2>" && l:GrooVim_CommandZNowChar != "\<f3>" && l:GrooVim_CommandZNowChar != "\<f4>" && l:GrooVim_CommandZNowChar != "\<f5>"
			let g:GrooVim_CommandZChar = l:GrooVim_CommandZNowChar
		endif
		if g:GrooVim_CommandZFCaller != a:GrooVim_CommandZFCallerNow && l:GrooVim_CommandZNowChar == ""
			let g:GrooVim_CommandZChar = ""
		endif
	endif
	" Note: To debug! By Questor
	" echo g:GrooVim_CommandZChar
	let g:GrooVim_CommandZMoment = l:GrooVim_CommandZMomentNow
	if g:GrooVim_CommandZChar != "" && g:GrooVim_CommandZUnblock == 1
		" Note: Evita que seja reexecutado um comando enquanto outro
		" está em adamento! By Questor
		let g:GrooVim_CommandZUnblock = 0
		" Note: Edit commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F2"
			" Note: Used keys for F2: h k j up down c a d q w e end del! By Questor
			" Note: To debug! By Questor
			" Note: Alinha à esquerda (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				:left
			endif
			" Note: Alinha à direita (k)! By Questor
			if g:GrooVim_CommandZChar == "107"
				:right
			endif
			" Note: Alinha no centro (j)! By Questor
			if g:GrooVim_CommandZChar == "106"
				:center
			endif
			" Note: To uppercase (normal/insert) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType != "v"
				exec "norm gUiwe"
			endif
			" Note: To lowercase (normal/insert) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType != "v"
				exec "norm guiwe"
			endif
			" Note: To uppercase (visual) (up)! By Questor
			if g:GrooVim_CommandZChar == "\<Up>" && a:modType == "v"
				call GrooVim_ToUpperLower("Upper")
			endif
			" Note: To lowercase (visual) (down)! By Questor
			if g:GrooVim_CommandZChar == "\<Down>" && a:modType == "v"
				call GrooVim_ToUpperLower("Lower")
			endif
			" Note: Copia todo o texto (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				exec "%y+"
			endif
			" Note: Seleciona todo o texto (a)! By Questor
			if g:GrooVim_CommandZChar == "97"
				exec "norm ggVG$"
			endif
			" Note: Duplica a linha atual (normal) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "n"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplica a linha atual (insert) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "i"
				let l:saved_reg = @+
				exec "norm yyo\<Esc>p"
				let @+ = l:saved_reg
			endif
			" Note: Duplica a seleção atual (visual) (d)! By Questor
			if g:GrooVim_CommandZChar == "100" && a:modType == "v"
				call GrooVim_DuplicateVisualSelection()
				" Note: Esse comando não permite repetição
				" simples! By Questor
				let g:GrooVim_CommandZChar = ""
			endif
			" Note: Grava uma macro (q)! By Questor
			if g:GrooVim_CommandZChar == "113"
				call GrooVim_XenRec()
			endif
			" Note: Excuta uma macro (w)! By Questor
			if g:GrooVim_CommandZChar == "119"
				call GrooVim_XenPlay(0)
			endif
			" Note: Excuta uma macro de forma repetida (e)! By Questor
			if g:GrooVim_CommandZChar == "101"
				call GrooVim_XenPlay(1)
			endif
			" Note: Select inner word (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				exec "norm viw"
			endif
			" Note: Select a range (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				call GrooVim_SelectRange(a:modType)
			endif
		endif
		" Note: Control commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F3"
			" Note: Used keys for F3: n c o v r / s f d h j [ ]! By Questor
			" Note: Abre uma nova tab (n)! By Questor
			if g:GrooVim_CommandZChar == "110"
				tabnew
				" Note: Solve read only problem! By Questor
				set ma
			endif
			" Note: Fecha a tab atual (c)! By Questor
			if g:GrooVim_CommandZChar == "99"
				tabc
			endif
			" Note: Fecha todas as demais tabs (o)! By Questor
			if g:GrooVim_CommandZChar == "111"
				tabonly
			endif
			" Note: Abre o arquivo .vimrc (v)! By Questor
			if g:GrooVim_CommandZChar == "118" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\zv")
			endif
			if g:GrooVim_CommandZChar == "118" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\zvi")
			endif
			" Note: Recarrega o arquivo .vimrc (r)! By Questor
			if g:GrooVim_CommandZChar == "114" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\zvvi")
			endif
			if g:GrooVim_CommandZChar == "114" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\zvv")
			endif
			" Note: Remove marcadores de pesquisa (visual/normal)(/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType != "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\\z/")
			endif
			" Note: Remove marcadores de pesquisa (insert)(/)! By Questor
			if g:GrooVim_CommandZChar == "47" && a:modType == "i"
				" Note: Workaround para evitar
				" imcompatibilidade! By Questor
				call feedkeys("\<Esc>\\z/i")
			endif
			" Note: Salva o arquivo (s)! By Questor
			if g:GrooVim_CommandZChar == "115" && a:modType != "v"
				:w
			endif
			if g:GrooVim_CommandZChar == "115" && a:modType == "v"
				call GrooVim_VisualWrite()
			endif
			" Note: Abre para pesquisa no normal e insert mode (f)! By Questor
			if g:GrooVim_CommandZChar == "102" && a:modType != "v"
				call GrooVim_SearchWithMyOptions("n")
			endif
			if g:GrooVim_CommandZChar == "102" && a:modType == "v"
				call GrooVim_SearchWithMyOptions("v")
			endif
			" Note: Abre para configurar a busca (d)! By Questor
			if g:GrooVim_CommandZChar == "100"
				call GrooVim_ConfigureSearchReplace("search")
			endif
			" Note: Abre para configurar o replace (h)! By Questor
			if g:GrooVim_CommandZChar == "104"
				call GrooVim_ConfigureSearchReplace("replace")
			endif
			" Note: Abre para replace (j)! By Questor
			if g:GrooVim_CommandZChar == "106" && a:modType != "v"
				call GrooVim_EntertainmentReplace("n")
			endif
			if g:GrooVim_CommandZChar == "106" && a:modType == "v"
				call GrooVim_EntertainmentReplace("v")
			endif
			" Note: Save session ([)! By Questor
			if g:GrooVim_CommandZChar == "91"
				exec "mksession! ~/vim_session"
				echomsg "Session saved!"
			endif
			" Note: Reload session (])! By Questor
			if g:GrooVim_CommandZChar == "93"
				exec "source ~/vim_session"
			endif
			" Note: Get current filename or filename and path and put on transfer area (p)! By Questor
			if g:GrooVim_CommandZChar == "112"
				call GrooVim_GetFileNameAndPath()
			endif
			" Note: Permite retornar para um determinada tab sempre (t)! By Questor
			if g:GrooVim_CommandZChar == "116"
				call GrooVim_TabToReturnSet()
			endif
			" Note: Select and search the word under cursor (End)! By Questor
			if g:GrooVim_CommandZChar == "\<End>"
				call GrooVim_SelectNSearch(1, a:modType)
			endif
			" Note: Reselect area (Del)! By Questor
			if g:GrooVim_CommandZChar == "\<Del>" && a:modType != "v"
				exec "norm gv"
			endif
			" Note: Salva no disco e abre em uma nova tab uma cópia do arquivo atual (y)! By Questor
			if g:GrooVim_CommandZChar == "121"
				call GrooVim_SaveACopy()
			endif
		endif
		" Note: Plugin commands! By Questor
		if a:GrooVim_CommandZFCallerNow == "F4"
			" Note: Used keys for F4: f d! By Questor
			" Note: Abre/fecha o nerdtree (n)! By Questor
			if g:enable_nerdtree_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "110"
					" call ToggleNERDTree()
					call GrooVim_ToggleNERDTreeTabs()
				endif
			endif
			" Note: Abre/fecha o vim debug (d)! By Questor
			if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
				if g:GrooVim_CommandZChar == "100"
					call GrooVim_ToggleDbg()
				endif
			endif
		endif
		" Note: Other commands! By Questor
		" Note: Used keys for F5: ! By Questor
		if a:GrooVim_CommandZFCallerNow == "F5"
		endif
		let g:GrooVim_CommandZUnblock = 1
	endif
	let g:GrooVim_CommandZFCaller = a:GrooVim_CommandZFCallerNow

endfunc

nnoremap <silent> <script> <F9> :call GrooVim_ToogleGrooVimHelp()<cr>

" Note: Tentar garantir que abra na janela de edição! By Questor
func! GrooVim_PutOnEditWindow() range
	while expand('%:t') =~ "GrooVim_SearchGuyResults" || expand('%:t') =~ "NERD_tree_" || expand('%:t') =~ "GrooVimHelp"
		exec "norm \<C-w>"
	endwhile
endfunc

" Note: Exibe a ajuda do GrooVim. Esse texto está no próprio corpo do GrooVim! By Questor
func! GrooVim_ToogleGrooVimHelp() range

	if bufexists("GrooVimHelp") == 0

		call GrooVim_PutOnEditWindow()

		" Note: O "set ma" e "set noma" abre e bloqueia edição do
		" buffer! By Questor
		set ma
		silent exec "split GrooVimHelp"
		exec "put =g:GrooVimHelp"
		exec "norm ggdd"
		exec "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapmargin=0 | set formatoptions+=l | set syntax=help"
		set noma
	else
		" Note: Com essa abordagem eu consigo efetivamente "destruir" 
		" o buffer não retornando "falso" positivos no "bufexists" 
		" acima! By Questor
		exec "bwipeout! GrooVimHelp"
	endif

endfunc

" Note: Get current filename or filename and path and put on transfer area! By Questor
func! GrooVim_GetFileNameAndPath() range

	let l:filenameOrFilenameAndPath = ""

	let l:getFilenameOrFilenameAndPath = GrooVim_GetOptions("Get [0]filename or [1]filename and path [0[default]/1]? ", [1,0], 0)
	if l:getFilenameOrFilenameAndPath == 0
		let l:filenameOrFilenameAndPath = expand('%:t')
		echomsg " -> Filename \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	elseif l:getFilenameOrFilenameAndPath == 1
		let l:filenameOrFilenameAndPath = expand('%:p')
		echomsg " -> Filename and path \"" . l:filenameOrFilenameAndPath . "\" on transfer area!"
	endif

	" Note: Set the clipboard register! By Questor
	let @+ = l:filenameOrFilenameAndPath

endfunc

" Note: Grava uma macro! By Questor
func! GrooVim_XenRec() range
	call GrooVim_GrooVimBarMsg("Use \"q\" to stop macro recording!", 5)
	exec "norm qa"
	echo "Starting a NEW recording!"
endfunc

" Note: Executa uma macro repetindo ou não! By Questor
let g:GrooVim_XenPlayRunningWithSearch = 0
func! GrooVim_XenPlay(repeatExecution) range

	if a:repeatExecution == 0
		exec "norm @a"
		" Note: Por razões desconhecidas o valor da variável "g:GrooVim_CommandZChar" se perde na execução do comando, não
		" permitindo repetição simples e por isso o workaround! By Questor
		let g:GrooVim_CommandZChar = "119"
	elseif a:repeatExecution == 1
		let g:block_GrooVim_HLNext = 1
		let g:GrooVim_XenPlayRunningWithSearch = 0
		let l:numberOfRepetitions = input("Number of repetitions (use \"x\" to excute to last/first line): ")
		" Note: Executa até a última/primeira linha! By Questor
		if l:numberOfRepetitions == "x"
			" Note: "set nowrapscan" serve para evitar voltar ao começo! By Questor
			set nowrapscan
			let l:stopWhile = 0
			let l:firstExecution = 1
			let l:executionDirection = ""
			while l:stopWhile == 0
				let l:posBefore = getpos(".")
				if (l:posBefore[1] >= getpos("$")[1] || l:posBefore[1] == 1) && l:firstExecution == 0 && g:GrooVim_XenPlayRunningWithSearch == 0
					let l:stopWhile = 1
				endif

				" Note: Se não houver mais ocorrências para uma pesquisa para a execução! By Questor
				try
					" Note: Testa se ainda existem ocorrências! By Questor
					if l:executionDirection != "" && g:GrooVim_XenPlayRunningWithSearch == 1
						if l:executionDirection == "d"
							exec "norm n"
						endif
						if l:executionDirection == "u"
							exec "norm N"
						endif
						call setpos(".", l:posBefore)
					endif
					exec "norm @a"

				catch
					let l:stopWhile = 1
				endtry

				let l:posAfter = getpos(".")

				if l:posBefore[1] == l:posAfter[1] && l:firstExecution == 1 && g:GrooVim_XenPlayRunningWithSearch == 0

					if l:posBefore[1] != getpos("$")[1] && l:posBefore[1] != 1
						call GrooVim_GrooVimBarMsg("This macro isn't compatible with the execution that you selected. The current line will be always the same!", 4)
					endif
					let l:stopWhile = 1

				endif

				if l:executionDirection != ""
					if l:executionDirection == "d"
						if l:posBefore[1] > l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
					if l:executionDirection == "u"
						if l:posBefore[1] < l:posAfter[1]
							let l:stopWhile = 1
						endif
					endif
				endif

				if l:executionDirection == ""
					if l:posBefore[1] < l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] < l:posAfter[2])
						let l:executionDirection = "d"
					endif
					if l:posBefore[1] > l:posAfter[1] || (l:posBefore[1] == l:posAfter[1] && l:posBefore[2] > l:posAfter[2])
						let l:executionDirection = "u"
					endif
				endif

				if l:stopWhile == 0 && g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: O "redraw!" é para garantir que
					" a menssagem seja exibida! By Questor
					redraw!
				endif

				" Note: See execution! By Questor
				redraw!

				let l:firstExecution = 0

			endwhile
			set wrapscan
		else

			" Note: Executa "n" vêzes! By Questor

			" Note: Check for valid numbers! By Questor
			let l:invalidNumber = 1
			while l:invalidNumber == 1

				let l:invalidNumber = 0

				if l:numberOfRepetitions != str2nr(l:numberOfRepetitions)
					let l:invalidNumber = 1
				endif

				if l:numberOfRepetitions <= 0
					let l:invalidNumber = 1
				endif

				if l:invalidNumber == 1
					let l:numberOfRepetitions = input("Number of repetitions (use a valid one!): ")
				endif

			endwhile

			for i in range(1, l:numberOfRepetitions)

				" Note: Se no houver mais ocorrências para uma pesquisa para a execução! By Questor
				try
					exec "norm @a"
				catch
					let l:stopWhile = 1
				endtry

				let g:onMoveScreen = 1
				if g:GrooVim_GrooVimBarMsgEnabled == 0
					call GrooVim_GrooVimBarMsg("Use Ctrl+C to stop!", 1)
					" Note: O "redraw!" é para garantir que
					" a menssagem seja exibida! By Questor
					redraw!
				endif
				" Note: See execution! By Questor
				redraw!
			endfor

		endif

		" Note: Por razões desconhecidas o valor da variável "g:GrooVim_CommandZChar" se perde na execução do comando, não 
		" permitindo repetição simples e por isso o workaround! By Questor
		let g:GrooVim_CommandZChar = "101"

		let g:GrooVim_XenPlayRunningWithSearch = 0

	endif

	let g:block_GrooVim_HLNext = 0

endfunc

" Note: Permite duplicar uma área de seleção de forma simples! By Questor
func! GrooVim_DuplicateVisualSelection() range
	let l:saved_reg = @+
	exec "norm gvygv\<Esc>p"
	let @+ = l:saved_reg
endfunc

" Note: Edit/reload the vimrc file! By Questor
nnoremap <silent> <leader>zv :tabedit $MYVIMRC<cr>
nnoremap <silent> <leader>zvv :tabdo source $MYVIMRC<cr><bar>:tabfirst<cr>

" Note: Clears the search register! By Questor
nnoremap <silent> <leader>z/ :nohlsearch<cr>

if g:enable_debugger_vim == 1 && g:enable_all_plugins == 1
	" Note: Abre e fecha o "VIM Debug" à depender se ele esteja aberto ou fechado! By Questor
	let g:NERDTreeIsOpen = 0
	func! GrooVim_ToggleDbg()
		if exists("g:Dbg")
			unlet g:Dbg
			Dbg quit
		else
			try
				if exists("g:NERDTreeIsOpen")
					unlet g:NERDTreeIsOpen
					NERDTreeTabsClose
				endif
					Dbg .
				let g:Dbg = 1
			catch
				echo "No Errors found!"
			endtry
		endif
	endfunc
endif

" Note: Salva no disco e abre em uma nova tab uma cópia do arquivo atual! By Questor
func! GrooVim_SaveACopy() range

		let l:valueToPath = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			let l:valueToPath = input("PATH to save your file copy (type \"0\" to use transfer area \"" . GrooVim_SubstringToPrompt(@+) . "\", \"1\" to use empty, \"2\" to use current file path or enter one): ")
			if l:valueToPath == "0"
				if !empty(matchstr(@+, "\/$"))
					let l:stopWhile = 1
					let l:valueToPath = @+
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					" Note: O "redraw!" é para garantir que a menssagem seja exibida! By Questor
					redraw!
				endif
			elseif l:valueToPath == "1"
				let l:stopWhile = 1
				let l:valueToPath = ""
			elseif l:valueToPath == "2"
				let l:stopWhile = 1
				let l:valueToPath = expand("%:h") . "/"
			elseif ("" . l:valueToPath . "") != ""
				if !empty(matchstr(l:valueToPath, "\/$"))
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Missing end \"/\"!", 1)
					redraw!
				endif
			endif
		endwhile

		let l:definePathWarning = ""
		let l:valueToName = ""
		let l:stopWhile = 0
		while l:stopWhile == 0
			if l:valueToPath == ""
				let l:definePathWarning = " (DEFINE A PATH TOO!)"
			endif
			let l:valueToName = input("NAME of the file copy to be saved" . l:definePathWarning . ": ")
			if ("" . l:valueToName . "") != ""
				if ("" . l:valueToName . "") != expand('%:t') || l:valueToPath != expand("%:h") . "/"
					let l:stopWhile = 1
				else
					call GrooVim_GrooVimBarMsg("Same name and path as the current file!", 1)
					redraw!
				endif
			endif
		endwhile

		try
			exec "w " . l:valueToPath . l:valueToName
			exec "tabnew " . l:valueToPath . l:valueToName
			call GrooVim_GrooVimBarMsg("A file copy was created!", 1)
			redraw!
		catch
			call GrooVim_GrooVimBarMsg("The file copy can't be saved! Reason: \"" . v:exception . "\"", 1)
			redraw!
		endtry

endfunc

" Note: Permite salvar estando no modo visual! By Questor
func! GrooVim_VisualWrite() range
	" Note: Witre! By Questor
	exec "w"
	" Note: Reselect area! By Questor
	exec "norm gv"
endfunc

" Note: Upper ou lower para a palavra ou seleção atual! By Questor
func! GrooVim_ToUpperLower(modType) range
	" Note: Reselect area! By Questor
	exec "norm gv"

	if a:modType == "Upper"
		exec "norm gU"
	endif

	if a:modType == "Lower"
		exec "norm gu"
	endif

	" Note: Repositioning on final! By Questor
	exec "norm gv\<Esc>"
endfunc

" Note: Sudo to write! By Questor
"cnoremap w!! w !sudo tee % >/dev/null

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"APPEARANCE
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Exibe o número de cada linha! By Questor
set number

" Note: Always show current position! By Questor
set ruler

" Note: Height of the command bar. By Questor
set cmdheight=2

" For regular expressions turn magic on
set magic

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set mat=2

" No annoying sound on errors
set noerrorbells
set novisualbell

" ToDo: O que vem a ser isso? By Questor
" set t_vb=

" ToDo: Line break? By Questor
set tm=500

" Note: Allow the cursor to go in to "invalid" places! By Questor
" set virtualedit=all

" Note: Always turn on syntax highlighting for diffs! By Questor
" select by the file-suffix directly...
augroup PatchDiffHighlight
	autocmd! BufEnter  *.patch,*.rej,*.diff   syntax enable
augroup end

" Note: Exibe avisos na barra de rolagem! By Questor
let g:GrooVim_GrooVimBarMsgValue = ""
let g:GrooVim_GrooVimBarMsgMoment = ""
let g:GrooVim_GrooVimBarMsgEnabled = 0
let g:GrooVim_GrooVimBarMsgDuration = 0
func! GrooVim_GrooVimBarMsg(msgValue, msgDuration)

	if g:GrooVim_CheckCapsLockReturn == 0
		if a:msgValue != ""
			let g:GrooVim_GrooVimBarMsgValue = " Hey: " . a:msgValue
			let g:GrooVim_GrooVimBarMsgMoment = strftime("%Y%m%d%H%M%S")
			let g:GrooVim_GrooVimBarMsgEnabled = 1
			let g:GrooVim_GrooVimBarMsgDuration = a:msgDuration
		else
			let g:GrooVim_GrooVimBarMsgValue = ""
			let g:GrooVim_GrooVimBarMsgEnabled = 0
		endif
		call GrooVim_GrooVimBar()
	endif

endfun

" Note: Exibe uma barra de informações! By Questor
set laststatus=2
func! GrooVim_GrooVimBar()

	let l:barContents = '%f [%{(&fenc==""?&enc:&fenc).((exists("+bomb") && &bomb)?",B":"")}%M%R%H%W] %y [%l/%L,%v] [%p%%]'
	return l:barContents . " Powered by [GrooVim =D " . g:grooVimVersion . "]!" . g:GrooVim_GrooVimBarMsgValue

endfun
set stl=%!GrooVim_GrooVimBar()
" Note: Exibe uma menssagem na execução inicial! By Questor
call GrooVim_GrooVimBarMsg("To see GrooVim help use F9!", 10)

" Note: Make the 81st column stand out (just the 80st column of wide lines...)! By Questor
highlight GrooVim_ColorColumn ctermbg=blue
augroup GrooVim_ColorColumn
	autocmd! VimEnter,WinEnter * call matchadd('GrooVim_ColorColumn', '\%81v', 100)
augroup end

" Note: Make tabs, trailing whitespace and non-breaking spaces visible! By Questor
set list
" Note: Type I! By Questor
"exec "set listchars=tab:\uBB\uBB,trail:\uB7,nbsp:~"
" Note: Type II! By Questor
exec "set listchars=tab:▒░,trail:\uB7,nbsp:~"

" Note: switch syntax highlighting on, when the terminal has colors! By Questor
if &t_Co > 2 || has("gui_running")
	syntax on
endif

" Note: Switch from block-cursor to vertical-line-cursor when going into/out of insert mode! By Questor
" let &t_SI = "\<Esc>]50;CursorShape=1\x7"
" let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" Note: " Cursor -> Orange in insert mode and red in command mode!
" if you want to use rgb color formatting: konsoleprofile
" CustomCursorColor=#255255255! By Questor
let g:cursorColorI = "orange"
let g:cursorColorNV = "red"
let g:cursorColorBlock = 0

func! SetCursorColor()
	let &t_SI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorI . ";BlinkingCursorEnabled=1\x7"
	let &t_EI = "\<Esc>]50;CustomCursorColor=" . g:cursorColorNV . ";BlinkingCursorEnabled=0\x7"
endfun

if &term =~ "xterm\\|rxvt" && $COLORTERM != "gnome-terminal"
	autocmd VimEnter * silent !konsoleprofile UseCustomCursorColor=1
	call SetCursorColor()
	silent !konsoleprofile CustomCursorColor=red
	autocmd VimLeave * silent !konsoleprofile CustomCursorColor=default;BlinkingCursorEnabled=0
endif

" " Note: Exibe a linha do cursor (causes slowdown)! By Questor
" if exists('+cursorline')
" 	set cursorline cursorcolumn
" endif
"
" " Note: Exibe a coluna do cursor (causes slowdown)! By Questor
" hi CursorLine cterm=NONE,underline guibg=#F4F4F4
" hi! link CursorColumn CursorLine

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"USABILITY
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always show what mode we're currently editing in! By Questor
set showmode

" Note: Don't wrap lines! By Questor
set nowrap

" Note: Allow backspacing over everything in insert mode! By Questor
set backspace=indent,eol,start

" Note: remember more commands and search history! By Questor
set history=1000

" Note: use many/muchos levels of undo! By Questor
set undolevels=1000

" Note: Ignore case when searching! By Questor
set ignorecase

" Note: When searching try to be smart about cases! By Questor 
" set smartcase

" Note: Makes search act like search in modern browsers ("acende" as
" ocorrências já na digitação)! By Questor
set incsearch

" Note: Search/replace "globally" (on a line) by default! By Questor
set gdefault

" Note: Return to last edit position when opening files (You want this!)! By Questor
autocmd! BufReadPost *
	\ if line("'\"") > 0 && line("'\"") <= line("$") |
	\   exe "normal! g`\"" |
	\ endif
set viminfo^=%

" Note: Bind <F1> to show the keyword under cursor general help can still be entered manually, with :h! By Questor
if has("autocmd")
	augroup vim_files
		autocmd! filetype vim noremap <buffer> <F1> <Esc>:help <C-r><C-w><cr>
		autocmd! filetype vim noremap! <buffer> <F1> <Esc>:help <C-r><C-w><cr>
	augroup end
endif

" Note: Turn persistent undo on means that you can undo even when you close a buffer/VIM! By Questor
" ToDo: Colocar a criação desse diretório no roteiro! By Questor
try
	set undodir=~/.vim/Temp/Undodir
	set undofile
catch
endtry

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"INDENTATION AND SYNTAX
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Always set autoindenting on! By Questor
" ToDo: (Rever)! By Questor"
" set autoindent

" Note: Copy the previous indentation on autoindenting! By Questor
" ToDo: (Rever)! By Questor
" set copyindent

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"PLUGINS CONFIGURATION
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

"* NERDTree

" Note: Store the bookmarks file! By Questor
let NERDTreeBookmarksFile = expand("$HOME/.vim/NERDTreeBookmarks")

" Note: Show the bookmarks table on startup! By Questor
let NERDTreeShowBookmarks = 1

" Note: Show hidden files, too! By Questor
let NERDTreeShowFiles = 1

" Note: Quit on opening files from the tree! By Questor
" let NERDTreeQuitOnOpen = 1

" Note: Highlight the selected entry in the tree! By Questor
let NERDTreeHighlightCursorline = 1

" Note: Use a single click to fold/unfold directories and a double click to open files! By Questor
let NERDTreeMouseMode=2

" Note: NERDTree always open on the right side! By Questor
let NERDTreeWinPos = "right"

"* move-vim

" Note: Mapping to move-vim! By Questor
if g:enable_move_vim == 1 && g:enable_all_plugins == 1
	let g:move_key_modifier = "C"
	inoremap <silent> <C-k> <C-o>:call GrooVim_Move_Vim_OnInsert("up")<cr>
	inoremap <silent> <C-j> <C-o>:call GrooVim_Move_Vim_OnInsert("down")<cr>
	" Note: Esse workaround serve para que o move-vim possa ser acionado no insert mode! By Questor
	func! GrooVim_Move_Vim_OnInsert(direc)
		if a:direc == "up"
			exec "norm \<C-k>"
		elseif a:direc == "down"
			exec "norm \<C-j>"
		endif
	endfun
endif

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"ENCODING
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,big5,gb2312,latin1

fun! ViewUTF8()
	set encoding=utf-8
	set termencoding=big5
endfun

fun! UTF8()
	set encoding=utf-8
	set termencoding=big5
	set fileencoding=utf-8
	set fileencodings=ucs-bom,big5,utf-8,latin1
endfun

fun! Big5()
	set encoding=big5
	set fileencoding=big5
endfun

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
"HELP
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" Note: Para facilitar esse texto sempre deve ser o último! By Questor

let g:GrooVimHelp = "*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*\n|GrooVim|=D|2.0.7b|-|Vi|IMproved\'n\'GrooVIed!|".
\"\n Last change: 2014 May 28\n Eduardo L\u00facio Amorim Costa~\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n".
\"\n                   {+}".
\"\n                  {+++}".
\"\n                 {+++++}".
\"\n                {+++++++}".
\"\n               {+++++++++}".
\"\n             {+++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n{+++++++++++++++++++++++++++++++++++++++}".
\"\n  {++++++++++++++GrooVim++++++++++++++}".
\"\n    {+++++++++++++++++++++++++++++++}".
\"\n      {+++++++++++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n           {+++++++++++++++++}".
\"\n          {+++++++++++++++++++}".
\"\n         {+++++++++++++++++++++}".
\"\n        {+++++++++++++++++++++++}".
\"\n       {++++++++}       {++++++++}".
\"\n      {+++++}               {+++++}".
\"\n     {++}                       {++}".
\"\n".
\"\n|BETA|VERSION!|".
\"\n".
\"\n * O que \u00e9 o GrooVim?~".
\"\n".
\"\n O|GrooVim|\u00e9 um extensivo script (\u00e9 um arquivo|.vimrc|) que modifica o comportamento do Vim visando os seguintes objetivos:".
\"\n*o*  Permitir o uso com apenas algumas instru\u00e7\u00f5es e por um p\u00fablico mais amplo acostumado aos editores/IDEs padr\u00e3o;".
\"\n*o*  Facilitar e acelerar extensamente sendo, tamb\u00e9m, uma \"UI\" integrada;".
\"\n*o*  Preservar sempre que poss\u00edvel o comportamento padr\u00e3o do Vim;".
\"\n*o*  Refor\u00e7ar o projeto Vim como uma IDE de prop\u00f3sito geral;".
\"\n*o*  Aproximar o Vim dos editores \"padr\u00e3o\" de texto no que for conveniente e positivo e modificar o Vim em seus aspectos negativos;".
\"\n*o*  Fomentar Vim como uma alternativa melhor e mais \u00e1gil aos editores de texto e IDEs do mercado assim como um editor de prop\u00f3sito geral;".
\"\n*o*  Refor\u00e7ar o projeto Vim como uma alternativa livre (esse script \u00e9 Apache License - Version 2.0), independente e apoiada pela comunidade aos editores do mercado;".
\"\n*o*  Incentivar o uso do Vim \"shell\";".
\"\n*o*  Ser um pacote \"tudo em um\", ou seja, depender apenas do conte\u00fado do arquivo|.vimrc|para funcionar (nos cen\u00e1rios onde n\u00e3o usamos nenhum plugin);".
\"\n*o*  Ser um script para todos os tipos de terminais;".
\"\n".
\"\n * Antes de come\u00e7ar com o GrooVim!~".
\"\n".
\"\n--------".
\"\n *IMPORTANTE_I!* Se voc\u00ea n\u00e3o conhece o Vim ou n\u00e3o sabe utiliza-lo abra um terminal e execute|vimtutor|e fa\u00e7a os exerc\u00edcios (leva 25 \u00e0 30 minutos). Depois continue a ler esse documento! \u00c9 MUITO IMPORTANTE CONHECER O VIM PADR\u00c3O NO SEU B\u00c1SICO, ASSIM VOC\u00ca PODER\u00c1 USA-LO DE FORMA MAIS AMPLA E CONTRIBUIR COM NOVAS FUNCIONALIDADES!".
\"\n *IMPORTANTE_II!* O Vim \u00e9 um poderos\u00edssimo editor de texto/IDE de prop\u00f3sito geral. Tenha em mente que o GrooVim s\u00f3 foi poss\u00edvel gra\u00e7as a vasta API (script) e grande versatilidade que o Vim oferece!".
\"\n *IMPORTANTE_III!* Perceba ainda que determinados emuladores de terminal limitam as possibilidade dos Vim e do GrooVim. Sendo assim, recomendamos que para o seu Vim de \"todo o dia\" use um terminal que permita uma gama maior de possibilidades!".
\"\n--------".
\"\n".
\"\n*o*  O GrooVim foi projetado e pensado para trabalhar com um vasto conjunto de atalhos de teclado. Eventualmente, tais atalhos podem apresentar conflitos com atalhos do seu OS visto a quantidede de distribui\u00e7\u00f5es e variantes que existem. Isso \u00e9 normal e caso ocorram conflitos recomendamos que modifique os atalhos do seu OS, pois o ambiente de terminal n\u00e3o permite uma quantidade muito grande de combina\u00e7\u00f5es de teclas para formar atalhos;".
\"\n*o*  Para facilitar ainda mais a sua vida e aumentar a produtividade recomendamos que fa\u00e7a um mapeamento em seu terminal para navegar entre as tabs/abas deste usando <Shift-Left>/<Shift-Right>. Esses dois atalhos de teclado (<Shift-Left>/<Shift-Right>) n\u00e3o est\u00e3o mapeados no GrooVim para que sejam usados da forma mencionada;".
\"\n   |-|Note: No ambiente de desktop KDE j\u00e1 funciona dessa forma;".
\"\n*o*  O GrooVim foi projetado para trabalhar com tabs;".
\"\n*o*  O GrooVim foi projetado para trabalhar|sem|o|uso|contante|de|\'virtualedit\' (\"set virtualedit=all\") para facilitar a navega\u00e7\u00e3o \"desprezando\" as \u00e1reas \"inv\u00e1lidas\" (ou sem caracter) quando conveniente;".
\"\n*o*  O GrooVim foi projetado para trabalhar com os melhores plugins;".
\"\n   |-|Recomendamos instalar TODOS os plugins a seguir:".
\"\n      |-|*NERDTree*".
\"\n         |[https://github.com/scrooloose/nerdtree]|".
\"\n      |-|*tcomment*".
\"\n         |[https://github.com/tomtom/tcomment_vim]|".
\"\n      |-|*move*".
\"\n         |[https://github.com/matze/vim-move]|".
\"\n*o*  Quando usando plugins o plugin *Pathogen* necessita estar intalado|[https://github.com/tpope/vim-pathogen]|;".
\"\n*o*  Por padr\u00e3o o GrooVim n\u00e3o tem nenhum plugin habilitado (veja em |let|g:enable_all_plugins|=|0|). Voc\u00ea tamb\u00e9m poder\u00e1 habilitar os plugins individualmente;".
\"\n".
\"\n * O GrooVim resolve os seguintes \"problemas\"!~".
\"\n".
\"\n*o*  <Ctrl-Left>/<Ctrl-Right> (normal mode/insert/visual) - Navega\u00e7\u00e3o por palavras de forma convencional e pr\u00e1tica;".
\"\n*o*  <Tab> (normal mode/visual)- Indenta de forma convencional e pr\u00e1tica;".
\"\n*o*  <Enter> (normal mode/visual) - Uso de forma convencional e pr\u00e1tica;".
\"\n*o*  <Backspace> (normal mode/visual) - Uso de forma convencional e pr\u00e1tica (normal e visual mode);".
\"\n*o*  <Del> (normal mode/visual) - Uso de forma convencional e pr\u00e1tica;".
\"\n*o*  <Space> (normal mode/visual) - Uso de forma convencional e pr\u00e1tica;".
\"\n*o*  Na altern\u00e2ncia entre os modos o cursor fica corretamente posicionando;".
\"\n*o*  Utiliza\u00e7\u00e3o de forma correta e convencional da \u00e1rea de transfer\u00eancia (copiar e colar);".
\"\n*o* |Replace|, <x> (apagar) e <d> (deletar) preservando a \u00e1rea de transfer\u00eancia;".
\"\n*o*  <PageDown>/<PageUp> - Com navega\u00e7\u00e3o por toda a tela (\u00e1reas inv\u00e1lidas);".
\"\n*o*  <MouseScrollDown>/<MouseScrollUp> - Com navega\u00e7\u00e3o por toda a tela (\u00e1reas inv\u00e1lidas);".
\"\n*o*  <MouseClick> (normal mode) - Em toda a tela (\u00e1reas inv\u00e1lidas);".
\"\n*o*  Apenas um <Ctrl-w> alterna entre as janelas;".
\"\n*o*  Etc...".
\"\n".
\"\n * Funcionalidades de edi\u00e7\u00e3o!~".
\"\n".
\"\n*o*  Alternar entre os modos:".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Entrar ou sair do insert mode;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Entrar ou sair do visual mode;".
\"\n".
\"\n*o*  Sele\u00e7\u00e3o de texto:".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert) - Sele\u00e7\u00e3o de palavras para \u00e0 direita/esquerda;".
\"\n   |-|<Alt-End>/<Alt-Home> (normal mode/insert) - Sele\u00e7\u00e3o do texto na linha at\u00e9 o final/in\u00edcio \u00e0 partir do ponto atual;".
\"\n".
\"\n*o*  Comandos convencionais de editores de texto \"default\":".
\"\n   |-|<Ctrl-c> (visual mode) - Copiar para a \u00e1rea de transfer\u00eancia;".
\"\n   |-|<Ctrl-v> (normal mode/insert/visual) - Colar da \u00e1rea de transfer\u00eancia;".
\"\n   |-|<Ctrl-x> (visual mode) - Recortar para a \u00e1rea de transfer\u00eancia;".
\"\n   |-|<Ctrl-u> (normal mode/insert/visual) - Desfazer;".
\"\n   |-|<Ctrl-r> (normal mode/insert/visual) - Refazer;".
\"\n".
\"\n*o*  Plugins:".
\"\n   |-|move-vim;|".
\"\n        <Ctrl-j>/<Ctrl-k> (normal mode/insert/visual) - Mover a linha ou sele\u00e7\u00e3o para cima ou para baixo;".
\"\n".
\"\n * Modifica\u00e7\u00f5es \"relevantes\" no comportamento padr\u00e3o do Vim!~".
\"\n".
\"\n   |-|Utilize |Ctrl+b| para acessar acessar o visual block mode;".
\"\n   |-|Ao passar do|visual|mode|para o|insert|mode|o cursor n\u00e3o move;".
\"\n   |-|Utiliza a \u00e1rea de transfer\u00eancia padr\u00e3o do OS;".
\"\n   |-|A \"inser\u00e7\u00e3o\" e o \"paste\" ocorrem \u00e0 partir de uma mesma posi\u00e7\u00e3o do cursor;".
\"\n".
\"\n * Funcionalidades do script!~".
\"\n".
\"\n*o*  Navega\u00e7\u00e3o".
\"\n".
\"\n   |-|<Shift-Alt-Arrows> (normal mode/insert/visual) - Navega\u00e7\u00e3o suave e por toda a tela com movimentos longos (\u00e1reas inv\u00e1lidas);".
\"\n   |-|<Ctrl-Alt-Arrows> (normal mode/insert/visual) - Navega\u00e7\u00e3o com as setas por toda a tela (\u00e1reas inv\u00e1lidas) usando movimentos curtos;".
\"\n   |-|<Alt-Down> (normal mode/insert/visual) - Retorna \u00e0 tab anterior;".
\"\n   |-|<Ctrl-Down>/<Ctrl-Up> (normal mode/insert/visual) - A acessa tabs \u00e0 esquerda/direita;".
\"\n".
\"\n*o*  Sele\u00e7\u00e3o de palavras".
\"\n".
\"\n   |-|<Alt-Right>/<Alt-Left> (normal mode/insert/visual) - Sele\u00e7\u00e3o de palavras para \u00e0 direita/esquerda;".
\"\n   |-|<2-leftmouse> (normal mode/insert) - Clica duas v\u00eazes com o mouse em uma palavra seguida pressiona a letra <z>. Todas as palavras com o mesmo conte\u00fado ser\u00e3o brilhadas;".
\"\n".
\"\n*o*  Comentar linhas".
\"\n".
\"\n   |-|<Alt-Up> (normal mode/insert/visual) - Comentar linhas usando o *tcomment.vim* ;".
\"\n".
\"\n * ATALHOS F\'S (CommandZ)!~".
\"\n".
\"\n  O|CommandZ|\u00e9 uma esp\u00e9cie de \"super leader\" que permite uma extensa combina\u00e7\u00e3o de teclas para criar atalhos de teclado para funcionalidades no Vim. Funciona pressionando as teclas <F2>, <F3> ou <F4> e depois outra tecla.".
\"\n".
\"\n*o*  Caracter\u00edsticas".
\"\n ".
\"\n |-|Permite replica\u00e7\u00e3o do \u00faltimo comando apenas pressionando a \u00faltima|F|usada. Se em determinado intervalo nenhuma tecla de combina\u00e7\u00e3o for informada o \u00faltimo comando \u00e9 repetido;".
\"\n |-|Se a|F|for mantida pressionada o comando ser\u00e1 replicado v\u00e1rias v\u00eazes;".
\"\n".
\"\n    <F2> e depois...".
\"\n      Note: Preferencialmente para comandos de edi\u00e7\u00e3o;".
\"\n        <h> - Alinha \u00e0 esquerda (normal mode/insert/visual);".
\"\n        <k> - Alinha \u00e0 direita (normal mode/insert/visual);".
\"\n        <j> - Alinha no centro (normal mode/insert/visual);".
\"\n        <Up> - Modifica para uppercase (normal mode/insert/visual);".
\"\n        <Down> - Modifica para lowercase (normal mode/insert/visual);".
\"\n        <c> - Copia todo o texto do buffer atual (normal mode/insert/visual);".
\"\n        <a> - Seleciona todo o texto do buffer atual (normal mode/insert/visual);".
\"\n        <d> - Duplica a linha atual (normal mode/insert/visual);".
\"\n            Note: Se no visual mode n\u00e3o ser\u00e1 poss\u00edvel repeti\u00e7\u00e3o simples;".
\"\n        <q> - Grava uma macro (normal mode/insert/visual);".
\"\n        <w> - Excuta uma macro (normal mode/insert/visual);".
\"\n        <e> - Excuta uma macro de forma repetida ou at\u00e9 a \u00faltima linha (normal mode/insert/visual);".
\"\n        <End> - Seleciona a palavra abaixo do cursor (normal mode/insert/visual);".
\"\n        <Del> - Seleciona uma \u00e1rea (normal mode/insert);".
\"\n".
\"\n    <F3> e depois...".
\"\n      Note: Preferencialmente para comandos que \"tradicionalmente\" envolveriam|Ctrl|em outros editores;".
\"\n        <n> - Abre uma nova tab (normal mode/insert/visual);".
\"\n        <c> - Fecha a tab atual (normal mode/insert/visual);".
\"\n        <o> - Fecha todas as demais tabs (normal mode/insert/visual);".
\"\n        <v> - Abre o arquivo|.vimrc|(normal mode/insert/visual);".
\"\n        <r> - Recarrega o arquivo|.vimrc|em todas as tabs (normal mode/insert/visual);".
\"\n       |</>|- Remove marcadores de pesquisa (normal mode/insert/visual);".
\"\n        <s> - Salva no para o disco (normal mode/insert/visual);".
\"\n        <f> - Abre para pesquisa (normal mode/insert/visual);".
\"\n        <d> - Abre para configurar a busca (normal mode/insert/visual);".
\"\n        <j> - Abre para replace (normal mode/insert/visual);".
\"\n        <h> - Abre para configurar o replace (normal mode/insert/visual);".
\"\n       |<[>|- Salva a sess\u00e3o atual (normal mode/insert/visual);".
\"\n       |<]>|- Recarrega a \u00faltima sess\u00e3o salva (normal mode/insert/visual);".
\"\n        <p> - Copia para a \u00e1rea de transfer\u00eancia o nome ou nome e caminho de pasta do buffer e/ou arquivo atual (normal mode/insert/visual);".
\"\n        <t> - Permite retornar para um determinada tab sempre (normal mode/insert/visual);".
\"\n        <End> - Seleciona e procura a palavra sob o cursor (case sensitive) (normal mode/insert/visual);".
\"\n        <Del> - Reseleciona \u00e1rea (normal mode/insert/visual);".
\"\n        <y> - Salva no disco e abre em uma nova tab uma c\u00f3pia do arquivo atual (normal mode/insert/visual);".
\"\n".
\"\n    <F4> e depois...".
\"\n      Note: Preferencialmente para acionar os plugins instalados ou suas funcionalidades;".
\"\n        <n> - Abre/fecha o *NERDTree* (normal mode/insert/visual);".
\"\n".
\"\n * Integra\u00e7\u00e3o com plugins~".
\"\n".
\"\n   *Por...fazer...*".
\"\n".
\"\n * Tarefas/Pend\u00eancias/Bugs~".
\"\n".
\"\n   *Por...fazer...*\n\n*=D=D=D=D=D=D=D=D_HELP_FOR_GrooVim_=D=D=D=D=D=D=D=D*".
\"\n".
\"\n"

" Note: Para testar o help use: "set wrap | set linebreak | set nolist | set textwidth=0 | set wrapḿargin=0 | set formatoptions+=l | set syntax=help"! By Questor

"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

" =D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D=D
